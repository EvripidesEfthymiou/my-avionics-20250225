/// <reference types="@microsoft/msfs-types/js/simplane" />
/// <reference types="node" />
/// <reference types="@microsoft/msfs-types/js/common" />
/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
import * as _microsoft_msfs_sdk from '@microsoft/msfs-sdk';
import { TodBodDetails, Accessible, VNavState, VNavPathMode, VNavAltCaptureType, APGpsSteerDirectorSteerCommand, SimVarPublisher, EventBus, PublishPacer, LNavInterceptFunc, LNavOverrideModule, FlightPlanner, LNavSteerCommand, LNavState, LNavAircraftState, LNavEventBusTopicPublisherRecord, ExtendedApproachType, ApproachProcedure, RnavTypeFlags, VorFacility, OneWayRunway, FlightPlanLeg, NavRadioIndex, VNavPathCalculator, GeoPoint, FacilityLoader, EventSubscriber, Consumer, FlightPlan, IcaoValue, UserFacility, Facility, LegDefinition, AirportFacility, VerticalFlightPhase, AltitudeRestrictionType, SpeedUnit, SpeedRestrictionType, FlightPathCalculator, AirwayData, IntersectionFacility, SubscribableSet, Subscribable, NavToNavManager2, APValues, GPSSystemState, VNavDataEvents as VNavDataEvents$1, BaseVNavEvents, VNavManager, FlightPlanSegment, VNavConstraint, VerticalFlightPlan, TocBocDetails, APConfig, APLateralModes, APVerticalModes, AutopilotDriverOptions, APConfigDirectorEntry, PlaneDirector, APStateManager, KeyEventManager, KeyEventData, APGpsSteerDirectorState, APNavDirectorNavData, APNavDirectorActivateNavData, APBackCourseDirectorNavData, APBackCourseDirectorActivateNavData, APGSDirectorNavData, APGSDirectorActivateNavData, MinimumsMode, AltitudeSelectManagerOptions, MetricAltitudeSettingsManager, Autopilot, SetSubject, AltitudeSelectManager, ConsumerValue, ObjectSubject, ConsumerSubject, Subject, APModePressEvent, SpeedConstraint, ChecklistSetDef, ChecklistActionableItemDef, ChecklistBranchItemDef, ChecklistLinkItemDef, ChecklistNoteItemDef, ChecklistTitleItemDef, ChecklistItemType, ChecklistItemTypeMap, ChecklistItemDef, ChecklistItem, ChecklistDOMParser, ChecklistDOMParseOptionsToUse, ComponentProps, SubscribableArray, CasActiveMessage, DisplayComponent, VNode, AnnunciationType, MutableSubscribable, ToggleableClassNameRecord, ApproachUtils, DepartureProcedure, ArrivalProcedure, FlightPlanSegmentType, AbstractNumberUnitDisplayProps, NavAngleUnitFamily, NumberUnitInterface, NavAngleUnit, AbstractNumberUnitDisplay, Unit, LatLonInterface, UnitFamily, NodeInstance, MappedSubject, MappedSubscribable, Vec2Subject, Subscription, Waypoint, UserSettingRecord, UserSettingManager, UserSetting, UserSettingValue, UserSettingMap, Tcas, Adsb, MapIndexedRangeModule, MapSystemKeys, MapAirspaceModule, MapSystemController, MapSystemContext, MapDataIntegrityModule, MapOwnAirplaneIconModule, ResourceModerator, MapOwnAirplanePropsModule, SubEventInterface, LNavTrackingState, SubEvent, GeoProjectionPathStreamStack, AbstractFlightPathPlanRenderer, MapWaypointRenderer as MapWaypointRenderer$1, MapCullableTextLabelManager, FacilityWaypointCache, MapFieldOfView, MapProjection, FacilityWaypoint, FlightPathWaypoint, GeoPointSubject, CustomWaypoint, ReadonlyFloat64Array, MapAutopilotPropsModule, BaseLNavDataEvents as BaseLNavDataEvents$1, VorToFrom, TcasTcaParameters, AbstractTcasIntruder, TrafficContact, TrafficInstrument, TcasSensitivity, TcasSensitivityParameters, AdsbOperatingMode, TcasAdvisoryParameters, TcasOperatingMode, NumberUnitSubject, BasicFacilityWaypoint, AirportRunway, MapRotationModule, MapTerrainColorsModule, MapTrafficModule, MapWxrModule, MapLayer, MapLayerProps, MapFollowAirplaneModule, MapRangeModule, MapLabeledRingLayer, MapSyncedCanvasLayer, AbstractMapTrafficIntruderIcon, TcasIntruder, AbstractWaypoint, GeoPointInterface, MapWaypointIcon, MapWaypointSpriteIcon, AbstractMapWaypointIconOptions, AbstractMapWaypointIcon, MapLocationTextLabelOptions, MapWaypointRendererIconFactory, MapWaypointRendererLabelFactory, EmptyRecord, MapLineLayerProps, MapAltitudeArcLayerProps, MapGenericLayerProps, MapSystemBuilder, MapTrafficIntruderIconFactory, MapAltitudeArcLayerModules, MapOwnAirplaneIconOrientation, LodBoundary, MapAirspaceRenderer, NumberUnitReadOnly, SubscribableType, ReadonlyConsumerValue, DefaultUserSettingManager, GNSSEvents, LNavEvents, PressurizationEvents, AdcEvents, EngineEvents, ClockEvents, AccelerometerEvents, AhrsEvents, FamilyOfUnit, UnitOfNumber, DurationDisplayOptions, DurationDisplayFormat, DurationDisplayDelim, HorizonSharedCanvasSubLayer, HorizonProjection, HorizonLayerProps, HorizonLayer, MarkerBeaconState, MetricAltitudeSelectSetting, ReadonlySubEvent, BasicNavAngleSubject, TcasAdvisoryDataProvider, GeoPointReadOnly, AnimatorEasingFunc, Animator, ReadonlyFlightPlanRoute, FlightPlanRouteManager, FlightPlanRoute, FlightPlanRouteEnrouteLeg, AvionicsSystemStateEvent, BasicAvionicsSystem, SystemPowerKey, AvionicsSystemState, AbstractSubscribableArray, FacilityRepository, SubscribableMap, NavSourceId, ApproachGuidanceMode, ComputedSubject, NavSourceType, AdfRadioIndex, BaseAdcEvents, BaseAhrsEvents, GPSSatComputer, GPSSatComputerEvents, SubscribableSetEventType, FlightTimerMode, FlightTimerEventSuffix } from '@microsoft/msfs-sdk';

/**
 * Glidepath service levels.
 */
declare enum GlidepathServiceLevel {
    /** No glidepath. */
    None = 0,
    /** Visual. */
    Visual = 1,
    /** Visual with baro-VNAV. */
    VisualBaro = 2,
    /** LNAV+V. */
    LNavPlusV = 3,
    /** LNAV+V with baro-VNAV. */
    LNavPlusVBaro = 4,
    /** LNAV/VNAV. */
    LNavVNav = 5,
    /** LNAV/VNAV with baro-VNAV. */
    LNavVNavBaro = 6,
    /** LP+V. */
    LpPlusV = 7,
    /** LPV. */
    Lpv = 8,
    /** RNP. */
    Rnp = 9,
    /** RNP with baro-VNAV. */
    RnpBaro = 10
}
/**
 * Details about the next TOD and BOD for Garmin VNAV.
 */
interface GarminTodBodDetails extends Omit<TodBodDetails, 'currentConstraintLegIndex'> {
    /** The index of the VNAV constraint defining the BOD altitude, or `-1` if there is no BOD. */
    bodConstraintIndex: number;
    /** The index of the VNAV constraint defining the descent path along which the TOD lies, or `-1` if there is no TOD. */
    todConstraintIndex: number;
}
/**
 * Autopilot values used by a Garmin VNAV computer.
 */
type GarminVNavComputerAPValues = {
    /** The selected reference altitude, in feet. */
    selectedAltitude: Accessible<number>;
    /** The selected reference vertical speed, in feet per minute. */
    selectedVerticalSpeed: Accessible<number>;
    /** The active lateral mode. */
    lateralActive: Accessible<number>;
    /** The active vertical mode. */
    verticalActive: Accessible<number>;
    /** The armed vertical mode. */
    verticalArmed: Accessible<number>;
};
/**
 * An object describing Garmin VNAV guidance.
 */
type GarminVNavGuidance = {
    /** The state of VNAV. */
    state: VNavState;
    /** Whether VNAV guidance is active. */
    isActive: boolean;
    /** The current VNAV path mode. */
    pathMode: VNavPathMode;
    /** The climb mode to arm. */
    armedClimbMode: number;
    /** Whether the armed climb mode should be activated. */
    shouldActivateClimbMode: boolean;
    /** The current VNAV altitude capture type. */
    altitudeCaptureType: VNavAltCaptureType;
    /** Whether an altitude should be captured. */
    shouldCaptureAltitude: boolean;
    /** The altitude to capture, in feet. */
    altitudeToCapture: number;
};
/**
 * Vertical path guidance issued by Garmin VNAV.
 */
type GarminVNavPathGuidance = {
    /** Whether this guidance is valid. */
    isValid: boolean;
    /**
     * The flight path angle of the vertical track, in degrees. Positive angles indicate a downward-sloping
     * track.
     */
    fpa: number;
    /**
     * The deviation of the vertical track from the airplane, in feet. Positive values indicate the track lies above
     * the airplane.
     */
    deviation: number;
};
/**
 * Glidepath guidance issued by Garmin VNAV.
 */
type GarminVNavGlidepathGuidance = {
    /** Whether the currently loaded approach has glidepath guidance. */
    approachHasGlidepath: boolean;
    /** Whether this guidance is valid. */
    isValid: boolean;
    /** Whether the glidepath can be captured from an armed state. */
    canCapture: boolean;
    /** The flight path angle of the glidepath, in degrees. Positive angles indicate a downward-sloping path. */
    fpa: number;
    /**
     * The deviation of the glidepath from the airplane, in feet. Positive values indicate the path lies above the
     * airplane.
     */
    deviation: number;
};

/**
 * Configuration options for {@link APExternalGuidanceProvider}.
 */
type APExternalGuidanceProviderOptions = {
    /** Whether the provider supports GPS steering command data. Defaults to `false`. */
    supportGpsSteer?: boolean;
    /** Whether the provider supports VNAV guidance and VNAV path guidance data. Defaults to `false`. */
    supportVNav?: boolean;
    /** Whether the provider supports glidepath guidance data. Defaults to `false`. */
    supportGlidepath?: boolean;
};
/**
 * A provider of external autopilot guidance data. Data are sourced from indexed SimVars whose roots are defined in
 * `APExternalGpsSteerCommandSimVars`, `APExternalVNavGuidanceSimVars`, `APExternalVerticalPathGuidanceSimVars`, and
 * `APExternalGlidepathGuidanceSimVars`.
 */
declare class APExternalGuidanceProvider {
    private readonly index;
    private static readonly GPS_STEER_SIMVAR_UNITS;
    private static readonly VNAV_SIMVAR_UNITS;
    private static readonly VERT_PATH_SIMVAR_UNITS;
    private static readonly GLIDEPATH_SIMVAR_UNITS;
    private readonly supportGpsSteer;
    private readonly supportVNav;
    private readonly supportGlidepath;
    private readonly simVarIds;
    private readonly _gpsSteerCommand;
    /** The current external GPS steer command. */
    get gpsSteerCommand(): Readonly<APGpsSteerDirectorSteerCommand>;
    private readonly _vnavGuidance;
    /** The current external VNAV guidance. */
    get vnavGuidance(): Readonly<GarminVNavGuidance>;
    private readonly _verticalPathGuidance;
    /** The current external vertical path guidance. */
    get verticalPathGuidance(): Readonly<GarminVNavPathGuidance>;
    private readonly _glidepathGuidance;
    /** The current external glidepath guidance. */
    get glidepathGuidance(): Readonly<GarminVNavGlidepathGuidance>;
    /**
     * Creates a new instance of APExternalGuidanceProvider.
     * @param index The index of the guidance SimVars from which this provider sources data.
     * @param options Options with which to configure the provider.
     * @throws Error if `index` is not a non-negative integer.
     */
    constructor(index: number, options?: Readonly<APExternalGuidanceProviderOptions>);
    /**
     * Updates this provider's data.
     */
    update(): void;
    /**
     * Updates this provider's GPS steer command.
     */
    private updateGpsSteerCommand;
    /**
     * Updates this provider's VNAV guidance.
     */
    private updateVNavGuidance;
    /**
     * Updates this provider's vertical path guidance.
     */
    private updateVerticalPathGuidance;
    /**
     * Updates this provider's glidepath guidance.
     */
    private updateGlidepathGuidance;
}

/**
 * SimVar names for Garmin external GPS steering command data.
 */
declare enum APExternalGpsSteerCommandSimVars {
    IsValid = "L:1:WT_Garmin_External_GPS_Steer_Command_Is_Valid",
    IsHeading = "L:1:WT_Garmin_External_GPS_Steer_Command_Is_Heading",
    CourseToSteer = "L:1:WT_Garmin_External_GPS_Steer_Command_Course_To_Steer",
    TrackRadius = "L:1:WT_Garmin_External_GPS_Steer_Command_Track_Radius",
    Dtk = "L:1:WT_Garmin_External_GPS_Steer_Command_Dtk",
    Xtk = "L:1:WT_Garmin_External_GPS_Steer_Command_Xtk",
    Tae = "L:1:WT_Garmin_External_GPS_Steer_Command_Tae"
}
/**
 * SimVar names for Garmin external VNAV guidance data.
 */
declare enum APExternalVNavGuidanceSimVars {
    State = "L:1:WT_Garmin_External_VNav_State",
    IsActive = "L:1:WT_Garmin_External_VNav_Is_Active",
    PathMode = "L:1:WT_Garmin_External_VNav_Path_Mode",
    ArmedClimbMode = "L:1:WT_Garmin_External_VNav_Armed_Climb_Mode",
    ShouldActivateClimbMode = "L:1:WT_Garmin_External_VNav_Should_Activate_Climb_Mode",
    AltitudeCaptureType = "L:1:WT_Garmin_External_VNav_Alt_Capture_Type",
    ShouldCaptureAltitude = "L:1:WT_Garmin_External_VNav_Should_Capture_Alt",
    AltitudeToCapture = "L:1:WT_Garmin_External_VNav_Alt_To_Capture"
}
/**
 * SimVar names for Garmin external vertical path guidance data.
 */
declare enum APExternalVerticalPathGuidanceSimVars {
    IsValid = "L:1:WT_Garmin_External_Vertical_Path_Is_Valid",
    Fpa = "L:1:WT_Garmin_External_Vertical_Path_Fpa",
    Deviation = "L:1:WT_Garmin_External_Vertical_Path_Deviation"
}
/**
 * SimVar names for Garmin external glidepath guidance data.
 */
declare enum APExternalGlidepathGuidanceSimVars {
    ApproachHasGp = "L:1:WT_Garmin_External_Glidepath_Approach_Has_Gp",
    IsValid = "L:1:WT_Garmin_External_Glidepath_Is_Valid",
    CanCapture = "L:1:WT_Garmin_External_Glidepath_Can_Capture",
    Fpa = "L:1:WT_Garmin_External_VNav_Path_Fpa",
    Deviation = "L:1:WT_Garmin_External_VNav_Path_Deviation"
}

/**
 * SimVar names for Garmin autopilot data.
 */
declare enum GarminAPVars {
    /** Whether the autopilot NAV mode is on. */
    NavModeOn = "L:WTAP_Garmin_Nav_Mode_On",
    /** Whether the autopilot approach mode is on. */
    ApproachModeOn = "L:WTAP_Garmin_Approach_Mode_On"
}
/**
 * Garmin autopilot events derived from SimVars.
 */
interface GarminAPSimVarEvents {
    /** Whether the autopilot NAV mode is on. */
    ap_garmin_nav_mode_on: boolean;
    /** Whether the autopilot approach mode is on. */
    ap_garmin_approach_mode_on: boolean;
}
/**
 * Events related to Garmin autopilots.
 */
type GarminAPEvents = GarminAPSimVarEvents;
/**
 * A publisher for Garmin autopilot events derived from SimVars.
 */
declare class GarminAPSimVarPublisher extends SimVarPublisher<GarminAPSimVarEvents> {
    /**
     * Creates a new instance of GarminAPSimVarPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the pace of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<GarminAPSimVarEvents>);
}

/**
 * Events related to Garmin autopilot heading sync.
 */
interface HeadingSyncEvents {
    /** Whether automatic adjustment of selected heading during a turn is active. */
    hdg_sync_turn_adjust_active: boolean;
    /** Whether HDG sync mode is active. */
    hdg_sync_mode_active: boolean;
    /** The selected heading was changed manually. */
    hdg_sync_manual_select: void;
}

/**
 * Options for {@link GarminObsLNavModule}.
 */
type GarminObsLNavModuleOptions = {
    /**
     * A function used to translate DTK and XTK into a track intercept angle. If not defined, then a function that
     * computes intercept angles tuned for slow GA aircraft will be used.
     */
    intercept?: LNavInterceptFunc;
    /**
     * Whether to use the sim's native OBS state. If `true`, then the sim's OBS state as exposed through the event bus
     * topics defined in `NavEvents` will be used, and standard sim OBS key events will be used to control the state. If
     * `false`, then the OBS state exposed through the event bus topics defined in `LNavObsEvents` will be used, and
     * control events defined in `LNavObsControlEvents` will be used to control the state. Defaults to `true`.
     */
    useSimObsState?: boolean;
};
/**
 * An LNAV computer module that calculates lateral navigation for an OBS course to the active flight plan waypoint.
 */
declare class GarminObsLNavModule implements LNavOverrideModule {
    readonly index: number;
    private readonly bus;
    private readonly flightPlanner;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly publisher;
    private readonly useSimObsState;
    private readonly setActiveTopic;
    private readonly setCourseTopic;
    private isObsActive;
    private obsCourse;
    private legIndex;
    private leg;
    private readonly obsFix;
    private readonly obsMagVar;
    private dtk;
    private xtk;
    private distanceRemaining;
    private alongTrackSpeed;
    private courseToSteer;
    private readonly steerCommand;
    private readonly interceptFunc?;
    private _isActive;
    /**
     * Creates a new instance of GarminObsLNavModule.
     * @param index The index of this module's parent computer.
     * @param bus The event bus.
     * @param flightPlanner The flight planner from which to source the active flight plan.
     * @param options Options with which to configure the new module.
     */
    constructor(index: number, bus: EventBus, flightPlanner: FlightPlanner, options?: Readonly<GarminObsLNavModuleOptions>);
    /** @inheritDoc */
    getSteerCommand(): Readonly<LNavSteerCommand>;
    /** @inheritDoc */
    isActive(): boolean;
    /** @inheritDoc */
    canActivate(): boolean;
    /** @inheritDoc */
    activate(lnavState: LNavState, aircraftState: Readonly<LNavAircraftState>, eventBusTopicRecord: LNavEventBusTopicPublisherRecord): void;
    /** @inheritDoc */
    deactivate(lnavState: LNavState): void;
    /** @inheritDoc */
    update(lnavState: LNavState, aircraftState: Readonly<LNavAircraftState>, eventBusTopicRecord?: LNavEventBusTopicPublisherRecord): void;
    /**
     * Calculates tracking data for this module's current OBS course.
     * @param aircraftState The current state of the airplane.
     */
    private calculateTracking;
    /**
     * Updates this module's steering command using guidance generated from this module's currently tracked OBS course.
     * @param aircraftState The current state of the airplane.
     */
    private updateSteerCommand;
    /**
     * Sets whether OBS is active.
     * @param active Whether OBS should be set to active.
     */
    private setObsActive;
    /**
     * Sets the OBS course.
     * @param course The course to set, in degrees.
     */
    private setObsCourse;
}

declare enum DirectToState {
    NONE = 0,
    TOEXISTING = 1,
    TORANDOM = 2
}
declare enum ProcedureType {
    DEPARTURE = 0,
    ARRIVAL = 1,
    APPROACH = 2,
    VISUALAPPROACH = 3
}
declare enum AirwayLegType {
    NONE = 0,
    ENTRY = 1,
    EXIT = 2,
    ONROUTE = 3,
    EXIT_ENTRY = 4
}
/**
 * Additional Garmin approach types.
 */
declare enum GarminAdditionalApproachType {
    APPROACH_TYPE_VFR = 200
}
/**
 * Types of approaches supported by Garmin.
 */
type GarminApproachType = ExtendedApproachType | GarminAdditionalApproachType;
/**
 * A Garmin VFR approach procedure.
 */
type GarminVfrApproachProcedure = Omit<ApproachProcedure, 'approachType'> & {
    /** The approach type. */
    readonly approachType: GarminAdditionalApproachType.APPROACH_TYPE_VFR;
    /** Information about the published approach on which this VFR approach is based. */
    readonly parentApproachInfo: Pick<ApproachProcedure, 'approachType' | 'rnavTypeFlags'>;
};
/**
 * A Garmin approach procedure.
 */
type GarminApproachProcedure = ApproachProcedure | GarminVfrApproachProcedure;
/**
 * Details on the primary flight plan's loaded approach procedure.
 */
type ApproachDetails = {
    /** Whether an approach is loaded. */
    isLoaded: boolean;
    /** The type of the loaded approach. */
    type: GarminApproachType;
    /** Whether the loaded approach is an RNAV RNP (AR) approach. */
    isRnpAr: boolean;
    /** The best RNAV minima type available on the loaded approach. */
    bestRnavType: RnavTypeFlags;
    /** The RNAV minima types available on the loaded approach. */
    rnavTypeFlags: RnavTypeFlags;
    /** Whether the loaded approach is circling */
    isCircling: boolean;
    /** Whether the loaded approach is a vectors-to-final approach. */
    isVtf: boolean;
    /** The reference navaid facility for the loaded approach. */
    referenceFacility: VorFacility | null;
    /** The runway associated with the loaded approach. */
    runway: OneWayRunway | null;
};
/**
 * Details on the current FMS phase of flight.
 */
type FmsFlightPhase = {
    /** Whether the approach is active. */
    isApproachActive: boolean;
    /** Whether the active leg is the leg to the final approach fix. */
    isToFaf: boolean;
    /** Whether the active leg is past the final approach fix. */
    isPastFaf: boolean;
    /** Whether the missed approach is active. */
    isInMissedApproach: boolean;
};

/**
 * Events published by `Fms` keyed by base topic names.
 */
interface BaseFmsEvents {
    /** Details related to the primary flight plan approach. */
    fms_approach_details: Readonly<ApproachDetails>;
    /** Details related to the current FMS phase of flight. */
    fms_flight_phase: Readonly<FmsFlightPhase>;
    /** An approach was manually activated. */
    fms_approach_activate: void;
    /** Whether the primary flight plan's currently loaded approach is active and supports glidepath guidance. */
    approach_supports_gp: boolean;
}
/**
 * The event topic suffix for an `Fms` with a specific ID.
 */
type FmsEventSuffix<ID extends string> = ID extends '' ? '' : `_${ID}`;
/**
 * Events published by an `Fms` with a specific ID.
 */
type FmsEventsForId<ID extends string> = {
    [P in keyof BaseFmsEvents as `${P}${FmsEventSuffix<ID>}`]: BaseFmsEvents[P];
};
/**
 * All possible events published by `Fms`.
 */
interface FmsEvents extends BaseFmsEvents, FmsEventsForId<string> {
}

/**
 * Options for visual approach procedures.
 */
type FmsVisualApproachOptions = {
    /** The distance from the FINAL fix to the runway fix, in nautical miles. */
    finalFixDistance: number;
    /** The distance from the STRGHT fix to the FINAL fix, in nautical miles. */
    strghtFixDistance: number;
};
/**
 * Configuration options for {@link Fms}.
 */
type FmsOptions = {
    /** The index of the LNAV associated with the FMS's active flight plan. Defaults to `0`. */
    lnavIndex?: number;
    /**
     * Whether to use the sim's native OBS state. If `true`, then the sim's OBS state as exposed through the event bus
     * topics defined in `NavEvents` will be used, and standard sim OBS key events will be used to control the state. If
     * `false`, then the OBS state exposed through the event bus topics defined in `LNavObsEvents` will be used, and
     * control events defined in `LNavObsControlEvents` will be used to control the state. Defaults to `true`.
     */
    useSimObsState?: boolean;
    /**
     * The index of the VNAV associated with the FMS's flight plans. Defaults to `0`. If a vertical path calculator is
     * not provided to the FMS, then this option will be ignored.
     */
    vnavIndex?: number;
    /** The ID of the CDI associated with the FMS. Defaults to the empty string (`''`). */
    cdiId?: string;
    /** Whether advanced VNAV is supported. Defaults to `false`. */
    isAdvancedVnav?: boolean;
    /**
     * A function that maps flight plan legs in a procedure to flight plan legs to insert into a flight plan when loading
     * the procedure. If the function returns `undefined`, then the corresponding procedure leg will be omitted from the
     * flight plan entirely. If not defined, then all procedure flight plan legs are inserted into the flight plan
     * without modification.
     */
    procedureLegMapper?: (leg: FlightPlanLeg) => undefined | FlightPlanLeg;
    /**
     * Options for visual approach procedures. If not defined, then visual approach fix distances will default to 2.5
     * nautical miles for both runway to FINAL and FINAL to STRGHT.
     */
    visualApproachOptions?: Readonly<FmsVisualApproachOptions>;
    /**
     * The indexes of the sim NAV radios for which the FMS automatically tunes approach frequencies. The FMS will respect
     * changes made to the iterable after the FMS is created. Defaults to `[1, 2]`.
     */
    navRadioIndexes?: Iterable<NavRadioIndex>;
    /**
     * Whether to prevent the FMS from publishing the FMS flight phase approach active status to the `approach_available`
     * event bus topic. Defaults to `false`.
     */
    disableApproachAvailablePublish?: boolean;
};
/**
 * A Garmin flight management system.
 */
declare class Fms<ID extends string = any> {
    readonly isPrimary: boolean;
    readonly bus: EventBus;
    readonly flightPlanner: FlightPlanner<ID>;
    readonly verticalPathCalculator?: VNavPathCalculator | undefined;
    /** The index of the primary flight plan. */
    static readonly PRIMARY_PLAN_INDEX = 0;
    /** The index of the off-route direct-to flight plan. */
    static readonly DTO_RANDOM_PLAN_INDEX = 1;
    /** The index of the procedure preview flight plan. */
    static readonly PROC_PREVIEW_PLAN_INDEX = 2;
    /** Amount to offset runway leg altitude constraints from runway elevation, in meters. */
    private static readonly RUNWAY_LEG_ALTITUDE_OFFSET;
    private static readonly DEFAULT_VISUAL_APPROACH_OPTIONS;
    private static readonly VTF_FAF_DATA_KEY;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private readonly fmsTopicMap;
    private readonly eventSubscriber;
    private readonly publisher;
    /** The index of the LNAV associated with the FMS's active flight plan. */
    readonly lnavIndex: number;
    private readonly useSimObsState;
    private readonly lnavControlTopicMap;
    private readonly obsControlTopicMap;
    /** The index of the VNAV associated with the FMS's flight plans, or `-1` if this FMS does not support VNAV functionality. */
    readonly vnavIndex: number;
    private readonly vnavControlTopicMap?;
    /** The ID of the CDI associated with this FMS. */
    readonly cdiId: string;
    private readonly cdiControlTopicMap;
    /** Whether advanced VNAV is supported. */
    readonly isAdvancedVnav: boolean;
    private readonly procedureLegMapFunc;
    private readonly visualApproachOptions;
    private readonly navRadioIndexes;
    private readonly disableApproachAvailablePublish;
    readonly ppos: GeoPoint;
    private readonly facRepo;
    /** A facility loader instance. */
    readonly facLoader: FacilityLoader;
    private readonly approachDetails;
    private needPublishApproachDetails;
    private updateApproachDetailsOpId;
    private readonly flightPhase;
    private needPublishFlightPhase;
    private readonly flightPhaseDebounceTimer;
    private readonly updateFlightPhaseFunc;
    private readonly activateMaprState;
    private readonly navActiveFreqs;
    private cdiSource;
    private readonly indicatedAlt;
    private readonly lnavTrackedLegIndex;
    private readonly lnavLegDistanceRemaining;
    private readonly isObsActive;
    private readonly obsCourse;
    private readonly needConvertObsToDtoSimVar;
    /**
     * Creates an instance of the FMS.
     * @param isPrimary Whether this FMS is the primary instance. Only the primary FMS will execute certain operations
     * that have global effects across the entire airplane.
     * @param bus The event bus.
     * @param flightPlanner The flight planner.
     * @param verticalPathCalculator The vertical path calculator. Required to support the vertical direct-to
     * functionality.
     * @param options Options with which to configure the FMS.
     */
    constructor(isPrimary: boolean, bus: EventBus, flightPlanner: FlightPlanner<ID>, verticalPathCalculator?: VNavPathCalculator, options?: Readonly<FmsOptions>);
    /**
     * Creates an instance of the FMS.
     * @param isPrimary Whether this FMS is the primary instance. Only the primary FMS will execute certain operations
     * that have global effects across the entire airplane.
     * @param bus The event bus.
     * @param flightPlanner The flight planner.
     * @param verticalPathCalculator The vertical path calculator. Required to support the vertical direct-to
     * functionality.
     * @param isAdvancedVnav Whether advanced VNAV is supported. Defaults to `false`.
     * @param procedureLegMapper A function which transforms unsupported leg types in procedures to supported leg types.
     * If not defined, all legs in procedures will retain their original types.
     * @param visualApproachOptions Options for visual approach procedures. If not defined, then visual approach fix
     * distances will default to 2.5 nautical miles for both runway to FINAL and FINAL to STRGHT.
     */
    constructor(isPrimary: boolean, bus: EventBus, flightPlanner: FlightPlanner<ID>, verticalPathCalculator?: VNavPathCalculator, isAdvancedVnav?: boolean, procedureLegMapper?: (leg: FlightPlanLeg) => undefined | FlightPlanLeg, visualApproachOptions?: Readonly<FmsVisualApproachOptions>);
    /**
     * Initializes a listener which listens for OBS deactivation and converts the deactivated OBS to an on-route
     * Direct-To.
     */
    private initObsDeactivationListener;
    /**
     * Gets an event bus subscriber for topics published by this FMS.
     * @returns An event bus subscriber for topics published by this flight planner.
     */
    getEventSubscriber(): EventSubscriber<FmsEventsForId<ID>>;
    /**
     * Subscribes to one of the event bus topics published by this FMS.
     * @param baseTopic The base name of the topic to which to subscribe.
     * @returns A consumer for the specified event bus topic.
     */
    onEvent<K extends keyof BaseFmsEvents>(baseTopic: K): Consumer<BaseFmsEvents[K]>;
    /**
     * Initializes the primary flight plan. Does nothing if the primary flight plan already exists.
     *
     * @param force Whether to force a new primary flight plan to be created, even if one already exists
     */
    initPrimaryFlightPlan(force?: boolean): Promise<void>;
    /**
     * Checks whether an indexed flight plan exists.
     * @param index A flight plan index.
     * @returns Whether a flight plan at the specified index exists.
     */
    hasFlightPlan(index: number): boolean;
    /**
     * Gets a specified flightplan, or by default the primary flight plan.
     * @param index The index of the flight plan.
     * @returns the requested flight plan
     * @throws Error if no flight plan exists at the specified index.
     */
    getFlightPlan(index?: number): FlightPlan;
    /**
     * Checks whether the primary flight plan exists.
     * @returns Whether the primary flight plan exists.
     */
    hasPrimaryFlightPlan(): boolean;
    /**
     * Gets the primary flight plan.
     * @returns The primary flight plan.
     * @throws Error if the primary flight plan does not exist.
     */
    getPrimaryFlightPlan(): FlightPlan;
    /**
     * Checks whether the Direct To Random flight plan exists.
     * @returns Whether the Direct To Random flight plan exists.
     */
    hasDirectToFlightPlan(): boolean;
    /**
     * Gets the Direct To Random flight plan.
     * @returns The Direct To Random flight plan.
     * @throws Error if the Direct To Random flight plan does not exist.
     */
    getDirectToFlightPlan(): FlightPlan;
    /**
     * Gets the approach runway:
     * @returns Selected approach runway
     */
    getApproachRunway(): OneWayRunway | null;
    /**
     * Sets the name of the flight plan.
     * @param planIndex The index of the plan the change the name for.
     * @param name The new name for the flight plan.
     */
    setFlightPlanName(planIndex: number, name: string): void;
    /**
     * Clears the name of the flight plan.
     * @param planIndex The index of the plan the clear the name for.
     */
    deleteFlightPlanName(planIndex: number): void;
    /**
     * Schedules a flight phase update operation if one is not already pending.
     */
    private scheduleUpdateFlightPhase;
    /**
     * Updates flight phase information.
     */
    private updateFlightPhase;
    /**
     * A method to check the current approach state.
     */
    private updateApproachDetails;
    /**
     * Removes the direct to existing legs from the primary flight plan. If a direct to existing is currently active,
     * this will effectively cancel it.
     * @param lateralLegIndex The index of the leg to set as the active lateral leg after the removal operation. Defaults
     * to the index of the current active primary flight plan leg.
     */
    private removeDirectToExisting;
    /**
     * Checks whether a leg in the primary flight plan can be manually activated.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg can be manually activated.
     */
    canActivateLeg(segmentIndex: number, segmentLegIndex: number): boolean;
    /**
     * Checks whether a leg in the primary flight plan is a valid direct to target.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg is a valid direct to target.
     * @throws Error if a leg could not be found at the specified location.
     */
    canDirectTo(segmentIndex: number, segmentLegIndex: number): boolean;
    /**
     * Gets the current Direct To State.
     * @returns the DirectToState.
     */
    getDirectToState(): DirectToState;
    /**
     * Gets the ICAO string (V1) of the current Direct To target.
     * @returns The ICAO string (V1) of the current Direct To target, or undefined if Direct To is not active.
     * @deprecated Please use `getDirectToTargetIcaoValue()` instead.
     */
    getDirectToTargetIcao(): string | undefined;
    /**
     * Gets the ICAO value of the current Direct To target.
     * @returns The ICAO value of the current Direct To target, or undefined if Direct To is not active.
     */
    getDirectToTargetIcaoValue(): IcaoValue | undefined;
    /**
     * Gets the current DTO Target Flight Plan Leg.
     * @returns the FlightPlanLeg.
     */
    private getDirectToLeg;
    /**
     * Checks if a segment is the first enroute segment that is not an airway.
     * @param segmentIndex is the segment index of the segment to check
     * @returns whether or not the segment is the first enroute segment that is not an airway.
     */
    isFirstEnrouteSegment(segmentIndex: number): boolean;
    /**
     * Adds a user facility.
     * @param userFacility the facility to add.
     */
    addUserFacility(userFacility: UserFacility): void;
    /**
     * Removes a user facility.
     * @param userFacility the facility to remove.
     */
    removeUserFacility(userFacility: UserFacility): void;
    /**
     * Adds a visual or runway facility from the FlightPlanLeg.
     * @param leg the leg to build the facility from.
     * @param visualRunwayDesignation is the visual runway this facility belongs to.
     */
    private addVisualFacilityFromLeg;
    /**
     * Inserts a waypoint into the primary flight plan.
     * @param segmentIndex The index of the flight plan segment into which to insert the waypoint.
     * @param facility The waypoint facility to insert.
     * @param legIndex The index in the segment at which to insert the waypoint. If a leg already exists at the index,
     * the existing leg and all subsequent legs will be shifted to the right. If not defined, the waypoint will be
     * inserted at the end of the segment.
     * @returns The leg that was inserted into the flight plan, or `undefined` if the insertion operation could not be
     * carried out.
     */
    insertWaypoint(segmentIndex: number, facility: Facility, legIndex?: number): LegDefinition | undefined;
    /**
     * Handles inserting a flight plan leg into an airway segment.
     * @param plan The flight plan into which to insert the leg.
     * @param segmentIndex The index of the airway segment.
     * @param leg The leg to insert.
     * @param segmentLegIndex The index in the airway segment at which to insert the leg. If not defined, the leg will be
     * inserted at the end of the segment.
     * @returns The leg that was inserted into the airway segment, or `undefined` if the segment does not exist or is not
     * an airway segment.
     */
    private handleAirwayInsertLeg;
    /**
     * Removes a leg to a waypoint from the primary flight plan.
     * @param segmentIndex The index of the segment containing the leg to remove.
     * @param segmentLegIndex The index of the leg to remove in its segment.
     * @returns Whether the waypoint was successfully removed.
     */
    removeWaypoint(segmentIndex: number, segmentLegIndex: number): boolean;
    /**
     * Gets the airway leg type of a flight plan leg.
     * @param plan The flight plan containing the query leg.
     * @param segmentIndex The index of the flight plan segment containing the query leg.
     * @param segmentLegIndex The index of the query leg in its segment.
     * @returns The airway leg type of the query leg.
     */
    private getAirwayLegType;
    /**
     * Method to get the distance of an airway segment.
     * @param segmentIndex is the index of the segment of the airway.
     * @returns the cumulative distance for the airway segment.
     */
    getAirwayDistance(segmentIndex: number): number;
    /**
     * Sets the primary flight plan's origin airport and runway. Any departure procedure loaded in the flight plan will
     * be removed.
     * @param airport The origin airport to set or its ICAO, or `undefined` if the origin airport should be cleared from
     * the flight plan.
     * @param runway The origin runway to set, or `undefined` if the origin runway should be cleared from the flight
     * plan. Ignored if `airport` is `undefined`.
     */
    setOrigin(airport: AirportFacility | string | undefined, runway?: OneWayRunway): void;
    /**
     * Sets the primary flight plan's destination airport and runway.
     * @param airport The destination airport to set or its ICAO, or `undefined` if the destination airport should be
     * cleared from the flight plan.
     * @param runway The destination runway to set, or `undefined` if the destination runway should be cleared from the
     * flight plan. Ignored if `airport` is `undefined`.
     */
    setDestination(airport: AirportFacility | string | undefined, runway?: OneWayRunway): void;
    /**
     * Moves any current legs in the destination segment to the end of the last enroute segment.
     */
    moveCurrentDestinationLegToEnroute(): void;
    /**
     * Method to remove runway or airport legs from segments where they shouldn't exist.
     */
    removeDestLegFromSegments(): void;
    /**
     * Method to ensure only one segment of a specific type exists in the flight plan and optionally insert it if needed.
     * @param segmentType is the segment type we want to evaluate.
     * @param insert is whether to insert the segment if missing
     * @returns segmentIndex of the only segment of this type in the flight plan.
     */
    private ensureOnlyOneSegmentOfType;
    /**
     * Method to invert the flightplan.
     */
    invertFlightplan(): void;
    /**
     * Method to add or replace a departure procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param departureIndex is the index of the departure
     * @param departureRunwayIndex is the index of the runway transition
     * @param enrouteTransitionIndex is the index of the enroute transition
     * @param oneWayRunway is the one way runway to set as the origin leg.
     */
    insertDeparture(facility: AirportFacility, departureIndex: number, departureRunwayIndex: number, enrouteTransitionIndex: number, oneWayRunway?: OneWayRunway | undefined): void;
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    private buildDepartureLegs;
    /**
     * Method to add or replace an arrival procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param arrivalIndex is the index of the arrival procedure.
     * @param arrivalRunwayTransitionIndex is the index of the arrival runway transition.
     * @param enrouteTransitionIndex is the index of the enroute transition.
     * @param arrivalRunway is the one way runway to set as the destination leg.
     */
    insertArrival(facility: AirportFacility, arrivalIndex: number, arrivalRunwayTransitionIndex: number, enrouteTransitionIndex: number, arrivalRunway?: OneWayRunway): void;
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param arrivalRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    private buildArrivalLegs;
    /**
     * Method to move a direct to destination to a specified target segment.
     * @param plan is the primary flight plan.
     * @param targetSegmentType is the target segment type.
     * @param arrivalSegmentIndex is the arrival segment index
     * @returns whether a direct to destination was moved.
     */
    private moveDirectToDestinationLeg;
    /**
     * Method to find the first enroute segment of the supplied flight plan.
     * @param plan is the flight plan to find the first enroute segment in.
     * @returns a segment index.
     */
    findFirstEnrouteSegmentIndex(plan: FlightPlan): number;
    /**
     * Method to find the last enroute segment of the supplied flight plan.
     * @param plan is the flight plan to find the last enroute segment in.
     * @returns a segment index.
     */
    findLastEnrouteSegmentIndex(plan: FlightPlan): number;
    /**
     * Method manage the destination leg in the last enroute segment.
     * @param plan is the flight plan.
     * @param currentDestination is the currently set destination airport icao.
     */
    private manageAirportLeg;
    /**
     * Method to check whether an approach can load, or only activate.
     * @returns true if the approach can be loaded and not activated, otherwise the approach can only be immediatly activated.
     */
    canApproachLoad(): boolean;
    private insertApproachOpId;
    /**
     * Method to add or replace an approach procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param approachIndex is the index of the approach procedure.
     * @param approachTransitionIndex is the index of the approach transition.
     * @param visualRunwayNumber is the visual runway number, if any.
     * @param visualRunwayDesignator is the visual runway designator, if any.
     * @param skipCourseReversal Whether to skip the course reversal. False by default.
     * @param activate Whether to activate the approach once it is loaded into the flight plan. Defaults to `false`.
     * @returns A Promise which is fulfilled with whether the approach was inserted.
     */
    insertApproach(facility: AirportFacility, approachIndex: number, approachTransitionIndex: number, visualRunwayNumber?: number, visualRunwayDesignator?: RunwayDesignator, skipCourseReversal?: boolean, activate?: boolean): Promise<boolean>;
    /**
     * Method to insert the approach legs.
     * @param facility The facility to build legs from.
     * @param approachIndex The approach procedure index to build legs from.
     * @param approachTransitionIndex The transition index to build legs from.
     * @param visualRunway If this is a visual approach, the visual approach one way runway object.
     * @param skipCourseReversal Whether to skip the course reversal.
     * @returns A Promise which is fulfilled with an `InsertProcedureObject` containing the flight plan legs to insert
     * into the flight plan.
     */
    private buildApproachLegs;
    /**
     * Inserts a VFR approach into the primary flight plan, replacing any approach that is already loaded.
     *
     * VFR approaches are distinct from both _visual instrument approaches_, which are a type of published IFR approach,
     * and _Garmin visual approaches_, which are auto-generated approaches not based on any published approach. A VFR
     * approach is based on a published IFR approach, but only includes the flight plan legs between and including those
     * ending at the final approach fix (faf) and missed approach point (map). Flight plan legs in the missed approach
     * procedure are not included.
     * @param facility The airport facility containing the published approach on which the VFR approach to insert is
     * based.
     * @param approachIndex The index of the published approach on which the VFR approach to insert is based.
     * @param isVtf Whether to insert the approach as a vectors-to-final (VTF) approach.
     * @param activate Whether to activate the approach once it is loaded into the flight plan. Defaults to `false`.
     * @returns A Promise which is fulfilled with whether the approach was inserted.
     */
    insertVfrApproach(facility: AirportFacility, approachIndex: number, isVtf: boolean, activate?: boolean): Promise<boolean>;
    /**
     * Builds a set of VFR approach flight plan legs.
     * @param facility The airport facility containing the approach procedure for which build the legs.
     * @param approachIndex The index of the approach procedure for which to build the legs.
     * @param isVtf Whether to build a set of legs for a vectors-to-final (VTF) approach.
     * @returns A Promise which will be fulfilled with an `InsertProcedureObject` containing the flight plan legs to
     * insert into the flight plan, or with `undefined` if a set of legs could not be built for the specified procedure.
     */
    private buildVfrApproachLegs;
    /**
     * Inserts a vector-to-final (VTF) leg into a procedure insertion object. A VTF leg is a CF leg to the final approach
     * fix with the {@link LegDefinitionFlags.VectorsToFinalFaf} flag applied to it.
     *
     * The course of the VTF leg is defined as follows:
     * * If the leg to the faf is a CF leg, the VTF course is equal to the CF leg course.
     * * If the leg to the faf is not an IF leg, the VTF course is defined by the great-circle path from the fix
     * immediately prior to the faf to the faf.
     * * If the leg to the faf is an IF leg, the VTF course is defined by the great-circle path from the faf to the fix
     * immediately following it.
     *
     * If a VTF course cannot be defined, then the normal faf leg is inserted instead of the VTF leg.
     * @param insertProcedureObject The procedure insertion object into which to insert the leg.
     * @param fafLeg The leg to the final approach fix.
     * @param prevLeg The leg before the faf leg.
     * @param nextLeg The leg after the faf leg.
     */
    private insertVtfLeg;
    /**
     * Manages the altitude constraints when adding a procedure by creating a VerticalData object for each leg.
     * @param plan The Flight Plan.
     * @param segmentIndex The segment index for the inserted procedure.
     */
    private autoDesignateProcedureConstraints;
    /**
     * Checks whether an altitude constraint defined for a flight plan leg in a procedure can be auto-designated.
     * @param segment The procedure segment containing the flight plan leg to evaluate.
     * @param leg The flight plan leg to evaluate.
     * @returns Whether an altitude constraint defined for the specified orocedure flight plan leg can be
     * auto-designated.
     */
    private isAltitudeAutoDesignable;
    /**
     * Method to set a user altitude constraint.
     * @param segmentIndex The segment index to insert the constraint at.
     * @param segmentLegIndex The leg index to insert the constraint at.
     * @param altitudeFeet The altitude, in feet, to set the constraint at; if undefined, delete user constraint.
     * @param displayAsFlightLevel Whether the constraint should be displayed as a flight level. Defaults to false.
     * @throws Error if altitude is NaN.
     */
    setUserConstraint(segmentIndex: number, segmentLegIndex: number, altitudeFeet?: number, displayAsFlightLevel?: boolean): void;
    /**
     * Method to set a user altitude constraint.
     * @param segmentIndex The segment index to insert the constraint at.
     * @param segmentLegIndex The leg index to insert the constraint at.
     * @param phase The vertical restriction type.
     * @param altDesc The altitude restriction type.
     * @param altitude1Meters The altitude 1 in meters.
     * @param displayAltitude1AsFlightLevel Whether to display altitude 1 as a flight level.
     * @param altitude2Meters The altitude 2 in meters. Optional.
     * @param displayAltitude2AsFlightLevel Whether to display altitude 2 as a flight level.
     * @throws Error if either altitude is NaN.
     */
    setUserConstraintAdvanced(segmentIndex: number, segmentLegIndex: number, phase: VerticalFlightPhase, altDesc: AltitudeRestrictionType, altitude1Meters: number, displayAltitude1AsFlightLevel: boolean, altitude2Meters?: number, displayAltitude2AsFlightLevel?: boolean): void;
    /**
     * Reverts an altitude constraint to the published data.
     * @param segmentIndex The segment index to revert the constraint at.
     * @param segmentLegIndex The leg index to revert the constraint at.
     */
    revertAltitudeConstraint(segmentIndex: number, segmentLegIndex: number): void;
    /**
     * Method to set a user speed constraint.
     * @param planIndex The flight plan index to use.
     * @param segmentIndex The segment index to insert the constraint at.
     * @param segmentLegIndex The leg index to insert the constraint at.
     * @param speed The speed, in knots IAS or Mach (should match the given speedDesc),
     * to set the constraint at; if undefined, delete user constraint.
     * @param speedUnit The speed units.
     * @param speedDesc The speed restriction type to set.
     * @throws Error if speed is NaN.
     */
    setUserSpeedConstraint(planIndex: number, segmentIndex: number, segmentLegIndex: number, speed?: number, speedUnit?: SpeedUnit, speedDesc?: SpeedRestrictionType): void;
    /**
     * Method to revert the speed constraint back to published value.
     * @param planIndex The flight plan index to use.
     * @param segmentIndex The segment index to revert the constraint at.
     * @param segmentLegIndex The leg index to revert the constraint at.
     */
    revertSpeedConstraint(planIndex: number, segmentIndex: number, segmentLegIndex: number): void;
    /**
     * Method to set a user flight path angle.
     * @param planIndex The flight plan index to use.
     * @param segmentIndex The segment index to insert the fpa at.
     * @param segmentLegIndex The leg index to insert the fpa at.
     * @param fpa The fpa, in degrees, to set the fpa to; if undefined, deletes the fpa.
     * @throws Error if fpa is NaN.
     */
    setUserFpa(planIndex: number, segmentIndex: number, segmentLegIndex: number, fpa?: number): void;
    /**
     * Sets vertical data into the plan and the direct to if necessary, then calculates the plan.
     * @param plan The flight plan to use.
     * @param segmentIndex The segment index to set the vertical data for.
     * @param segmentLegIndex The leg index to set the vertical data for.
     * @param verticalData The vertical data to set, will be merged with existing data.
     */
    private setLegVerticalData;
    /**
     * Method to check if a leg has a user specified constraint.
     * @param segmentIndex The segment index to insert the constraint at.
     * @param segmentLegIndex The leg index to insert the constraint at.
     * @deprecated Use FmsUtils.isLegAltitudeEdited in preference to this.
     * @returns Whether the leg has a user constraint.
     */
    isConstraintUser(segmentIndex: number, segmentLegIndex: number): boolean;
    /**
     * Method to check if a leg constraint can be reverted to the nav data constraint.
     * @param segmentIndex The segment index to insert the constraint at.
     * @param segmentLegIndex The leg index to insert the constraint at.
     * @returns Whether the leg has a nav data constraint to be reverted to.
     */
    hasConstraint(segmentIndex: number, segmentLegIndex: number): number | undefined;
    /**
     * Manages the altitude constraints for FAF legs where vertical angle info is also provided.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    private manageFafAltitudeRestriction;
    /**
     * Inserts an IF leg at the beginning of a procedure if it begins with a leg type which defines a fixed origin.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    private tryInsertIFLeg;
    /**
     * Checks the approach legs for an IAF fix type flag, and if one exists, amend the approach to ensure that
     * the IAF is not on a hold/pt leg and that we do not add legs prior to the IAF except in cases where we needed to add
     * an IF leg type.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    private tryReconcileIAFLeg;
    /**
     * Inserts a MAP fix type flag if none exists on the approach.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    private tryInsertMap;
    /**
     * Method to remove the duplicate leg after the hold leg.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    private tryCleanupHold;
    /**
     * Method to remove a course reversal in an approach procedure.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    private tryRemoveCourseReversal;
    /**
     * Method to remove the departure from the flight plan.
     */
    removeDeparture(): Promise<void>;
    /**
     * Method to remove the arrival from the flight plan.
     */
    removeArrival(): Promise<void>;
    /**
     * Method to remove the approach from the flight plan.
     */
    removeApproach(): Promise<void>;
    /**
     * Activates a flight plan leg.
     * @param segmentIndex The index of the flight plan segment containing the leg to activate.
     * @param segmentLegIndex The index of the leg to activate in its containing segment.
     * @param planIndex The index of the flight plan containing the leg to activate. Defaults to the index of the primary
     * flight plan.
     * @param inhibitImmediateSequence Whether to inhibit immediate automatic sequencing past the activated leg. Defaults
     * to `false`.
     */
    activateLeg(segmentIndex: number, segmentLegIndex: number, planIndex?: number, inhibitImmediateSequence?: boolean): void;
    /**
     * Activates a flight plan leg.
     * @param planIndex The index of the flight plan containing the leg to activate.
     * @param segmentIndex The index of the flight plan segment containing the leg to activate.
     * @param segmentLegIndex The index of the leg to activate in its containing segment.
     * @param inhibitImmediateSequence Whether to inhibit immediate automatic sequencing past the activated leg.
     */
    private _activateLeg;
    /**
     * Gets the required flight path angle, in degrees, for a vertical direct-to if it were to be activated immediately.
     * Positive angles represent descending paths.
     * @param constraintGlobalLegIndex The global index of the target flight plan leg of the vertical direct-to.
     * @param altitudeMeters The target altitude, in meters, of the vertical direct-to.
     * @returns The required flight path angle, in degrees, for the specified vertical direct-to if it were to be
     * activated immediately, or `undefined` if an angle cannot be calculated. Positive angles represent descending
     * paths.
     */
    getVerticalDirectRequiredFpa(constraintGlobalLegIndex: number, altitudeMeters: number): Promise<number | undefined>;
    /**
     * Activates a vertical direct to a selected constraint.
     * @param constraintGlobalLegIndex The global index of the target flight plan leg of the vertical direct-to.
     * @param altitudeMeters The target altitude, in meters, of the vertical direct-to.
     * @param displayAsFlightLevel Whether the target altitude should be displayed as a flight level. Defaults to false.
     * @param fpa The flight path angle, in degrees, for the vertical direct-to. Positive values indicate descending
     * paths. The FPA will be clamped to between 0 and 6 degrees. If not defined, then the flight path angle will be set
     * to the default VNAV descent FPA.
     * @returns Whether the vertical direct was activated or not.
     */
    activateVerticalDirect(constraintGlobalLegIndex: number, altitudeMeters: number, displayAsFlightLevel: boolean | undefined, fpa: number | undefined): boolean;
    /**
     * Cancels the currently active vertical direct-to.
     */
    cancelVerticalDirectTo(): void;
    /**
     * Publishes a command to cancel the current vertical direct-to for a given flight plan.
     * @param planIndex The index of the flight plan for which to cancel the vertical direct-to.
     */
    private publishCancelVerticalDirectTo;
    /**
     * Computes the desired flight path angle, in degrees, for a vertical direct-to. Positive angles represent descending
     * paths. The FPA is computed such that the vertical path for the direct-to is placed 200 feet above the airplane,
     * with the TOD some distance in front of the airplane.
     *
     * If there are any uncalculated or VNAV-ineligible legs between the active leg and the vertical direct-to target leg
     * (inclusive), the FPA cannot be computed and will be `undefined`. If the airplane's indicated altitude is at or
     * below the vertical direct-to target altitude, the computed FPA will be zero.
     * @param plan The lateral flight plan for which to
     * @param directLegIndex The global index of the vertical direct-to target flight plan leg.
     * @param directAltitude The target altitude of the vertical direct-to, in meters.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param legDistanceRemaining The along-track distance from the airplane's present position to the end of the active
     * flight plan leg, in meters.
     * @param indicatedAlt The indicated altitude of the airplane, in meters.
     * @returns The desired flight path angle, in degrees, for the specified vertical direct-to, or `undefined` if the
     * FPA could not be computed. Positive angles represent descending paths.
     */
    private getVerticalDirectFpa;
    /**
     * Checks whether an approach can be activated. An approach can be activated if and only if the primary flight plan
     * has a non-vectors-to-final approach loaded.
     * @returns Whether an approach can be activated.
     */
    canActivateApproach(): boolean;
    /**
     * Activates an approach. Activating an approach activates a Direct To to the first approach waypoint of the primary
     * flight plan, and attempts to load the primary approach frequency (if one exists) to the nav radios. If the primary
     * flight plan does not have an approach loaded, this method has no effect.
     */
    activateApproach(): void;
    /**
     * Checks whether vectors-to-final can be activated. VTF can be activated if and only if the primary flight plan has
     * an approach loaded.
     * @returns Whether vectors-to-final can be activated.
     */
    canActivateVtf(): boolean;
    /**
     * Activates vectors-to-final. Activating vectors-to-final activates the primary flight plan's vectors-to-final leg,
     * and attempts to load the primary approach frequency (if one exists) to the nav radios. If the primary flight plan
     * has a non-VTF approach loaded, it will be replaced by its VTF counterpart. If the primary flight plan has no
     * approach loaded, this method has no effect.
     */
    activateVtf(): Promise<void>;
    /**
     * Method to check if the approach is VTF.
     * @returns whether the approach is VTF.
     */
    isApproachVtf(): boolean;
    /**
     * Checks if the missed approach can be activated.
     * @returns whether the missed approach can be activated.
     */
    canMissedApproachActivate(): boolean;
    /**
     * Activates the missed approach.
     */
    activateMissedApproach(): void;
    /**
     * Creates and activates a Direct-To targeting a waypoint not in the primary flight plan (off-route Direct-To).
     * @param target The Direct-To's target waypoint facility or its ICAO.
     * @param course The magnetic course for the Direct-To, in degrees. If not defined, then the Direct-To will be
     * initiated from the airplane's present position.
     */
    createDirectToRandom(target: Facility | string, course?: number): void;
    /**
     * Creates and activates a Direct-To to an existing waypoint in the primary flight plan (on-route Direct-To).
     * @param segmentIndex The index of the segment containing the Direct-To's target flight plan leg.
     * @param segmentLegIndex The index of the Direct-To's target flight plan leg in its containing segment.
     * @param course The magnetic course for the Direct-To, in degrees. If not defined, then the Direct-To will be
     * initiated from the airplane's present position.
     * @param deletePriorConstraints Whether to delete all altitude constraints before the Direct-To target leg.
     * User-defined flight path angles will be preserved.
     */
    createDirectToExisting(segmentIndex: number, segmentLegIndex: number, course?: number, deletePriorConstraints?: boolean): void;
    /**
     * Creates a Direct-To origin IF leg.
     * @param ppos The current plane position.
     * @returns a Direct-To origin IF leg.
     */
    private createDTOOriginLeg;
    /**
     * Creates a Direct-To target leg.
     * @param icao is the icao.
     * @param leg The FlightPlanLeg.
     * @param course The magnetic course for the Direct To.
     * @returns a Direct-To leg.
     */
    private createDTODirectLeg;
    /**
     * Handles the automatic activation of a vertical direct-to after a lateral direct-to has been activated. This will
     * activate a vertical direct-to targeting the first constraint at or after the target leg of the lateral direct-to,
     * with a minimum flight path angle of 3 degrees. If the first constraint at or after the target leg of the lateral
     * direct-to is not a descent constraint, the vertical direct-to will not be activated.
     * @param segmentIndex The index of the segment containing the target flight plan leg of the new lateral direct-to.
     * @param segmentLegIndex The index of the target flight plan leg of the new lateral direct-to in its segment.
     */
    private handleDirectToVerticalDirect;
    /**
     * Cancels the currently active on-route or off-route direct-to.
     * @returns Whether an active direct-to was cancelled.
     */
    cancelDirectTo(): boolean;
    /**
     * Empties the primary flight plan.
     */
    emptyPrimaryFlightPlan(): Promise<void>;
    /**
     * Empties the primary flight plan and deletes its name.
     */
    deletePrimaryFlightPlan(): Promise<void>;
    /**
     * Resets all flight plans to their initial empty states, and cancels any active off-route Direct-To.
     */
    resetAllFlightPlans(): Promise<void>;
    /**
     * Builds a flight plan to preview a procedure.
     * @param calculator The flight path calculator to assign to the preview plan.
     * @param facility The airport facility to load the approach from
     * @param procType The type of procedure to preview.
     * @param procIndex The procedure index selected.
     * @param transIndex The transition index selected.
     * @param oneWayRunway The one way runway to build the preview with, if any.
     * @param rwyTransIndex The runway transition index selected, if any.
     * @param visualRunwayNumber is the visual runway number, if any.
     * @param visualRunwayDesignator is the visual runway designator, if any.
     * @returns A Promise which is fulfilled with whether the preview plan was successfully built.
     */
    buildProcedurePreviewPlan(calculator: FlightPathCalculator, facility: AirportFacility, procType: ProcedureType, procIndex: number, transIndex: number, oneWayRunway?: OneWayRunway, rwyTransIndex?: number, visualRunwayNumber?: number, visualRunwayDesignator?: RunwayDesignator): Promise<FlightPlan>;
    /**
     * Builds a flight plan to preview procedure transitions.
     * @param calculator The flight path calculator to assign to the preview plan.
     * @param facility The airport facility to which the procedure to preview belongs.
     * @param procType The type of procedure to preview.
     * @param procIndex The index of the procedure to preview.
     * @param excludeTransitionIndex The index of the transition to exclude in the preview.
     * @param rwyTransIndex The index of the procedure's runway transition.
     * @returns The index of the procedure transition preview plan.
     */
    buildProcedureTransitionPreviewPlan(calculator: FlightPathCalculator, facility: AirportFacility, procType: ProcedureType, procIndex: number, excludeTransitionIndex: number, rwyTransIndex?: number): Promise<FlightPlan>;
    /**
     * Builds a sequence of legs for a departure transition preview. The sequence consists of the legs of each departure
     * transition in order. Discontinuity legs separate legs of different transitions.
     * @param departure A departure.
     * @param excludeTransitionIndex The index of the transition to exclude in the preview.
     * @param rwyTransIndex The runway transition index of the departure.
     * @returns A sequence of legs for a departure transition preview.
     */
    private buildDepartureTransitionPreviewLegs;
    /**
     * Builds a sequence of legs for an arrival transition preview. The sequence consists of the legs of each arrival
     * transition in order. Discontinuity legs separate legs of different transitions.
     * @param arrival An arrival.
     * @param excludeTransitionIndex The index of the transition to exclude in the preview.
     * @param rwyTransIndex The runway transition index of the arrival.
     * @returns A sequence of legs for an arrival transition preview.
     */
    private buildArrivalTransitionPreviewLegs;
    /**
     * Builds a sequence of legs for an approach transition preview. The sequence consists of the legs of each approach
     * transition in order, followed by the first leg of the final approach. Discontinuity legs separate legs of
     * different transitions.
     * @param approach An approach.
     * @param excludeTransitionIndex The index of the transition to exclude in the preview.
     * @returns A sequence of legs for an approach transition preview.
     */
    private buildApproachTransitionPreviewLegs;
    /**
     * Builds a flight plan to preview a VFR approach procedure.
     * @param calculator The flight path calculator to assign to the preview plan.
     * @param facility The airport facility containing the published approach on which the VFR approach to preview is
     * based.
     * @param approachIndex The index of the published approach on which the VFR approach to preview is based.
     * @param isVtf Whether to preview the approach as a vectors-to-final (VTF) approach.
     * @returns A Promise which will be fulfilled with the preview plan after it has been built.
     */
    buildVfrApproachPreviewPlan(calculator: FlightPathCalculator, facility: AirportFacility, approachIndex: number, isVtf: boolean): Promise<FlightPlan>;
    /**
     * Builds a temporary flight plan to preview an airway entry.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the index of the temporary flight plan.
     */
    buildAirwayPreviewSegment(airway: AirwayData, entry: IntersectionFacility, exit: IntersectionFacility): number;
    /**
     * Inserts an airway segment into the flight plan.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @param segmentIndex The index of the segment containing the airway entry leg.
     * @param segmentLegIndex The index of the airway entry leg in its containing leg.
     * @returns The index of the inserted airway segment.
     */
    insertAirwaySegment(airway: AirwayData, entry: IntersectionFacility, exit: IntersectionFacility, segmentIndex: number, segmentLegIndex: number): number;
    /**
     * Prepares a new, empty airway segment in the primary flight plan which is ready to accept airway legs. Also
     * modifies the segment containing the entry leg, if necessary, either splitting it following the entry leg if it is
     * a non-airway enroute segment, or removing all legs following the entry leg if it is an airway segment. If the
     * entry leg is the last leg in its segment, a new non-airway enroute segment will be inserted after the entry leg
     * segment if the entry leg segment is the last segment in the flight plan or if the following segment is not an
     * enroute segment. If the entry leg is the entry for an existing airway segment, the existing airway segment will be
     * removed.
     * @param airwayName The name of the airway.
     * @param entrySegmentIndex The index of the segment containing the airway entry leg.
     * @param entrySegmentLegIndex The index of the airway entry leg in its segment.
     * @returns The index of the new airway segment.
     */
    private prepareAirwaySegment;
    /**
     * Splits a segment in preparation for inserting an airway segment after an entry leg within the segment to be split.
     * If the segment containing the entry leg is an enroute segment, it will be split into two enroute segments, with
     * the split occurring immediately after the entry leg. If the segment containing the entry leg is a departure
     * segment, all legs after the entry leg will be removed from the segment.
     * @param plan The flight plan to edit.
     * @param segmentIndex The index of the segment containing the airway entry leg.
     * @param segmentLegIndex The index of the airway entry leg in its containing segment.
     * @returns The index into which to insert the new airway segment now that the segment containing the entry leg has
     * been split.
     */
    private splitSegmentForAirway;
    /**
     * Builds a legs for an airway.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the InsertProcedureObject.
     */
    private buildAirwayLegs;
    /**
     * Method to remove an airway from the flight plan.
     * @param segmentIndex is the segment index of the airway to remove.
     */
    removeAirway(segmentIndex: number): void;
    /**
     * Merges the legs of two consecutive segments into a single segment. All legs in the second segment are moved to the
     * first, and the second segment is removed from the flight plan.
     * @param plan The flight plan to modify.
     * @param segmentIndex The index of the first segment to merge.
     */
    private mergeSegments;
    /**
     * Inserts a hold-at-waypoint leg to a flight plan. The hold leg will be inserted immediately after the specified
     * parent leg. The hold leg must have the same fix as the parent leg.
     * @param planIndex The index of the flight plan to add the hold to.
     * @param segmentIndex The index of the segment that contains the hold's parent leg.
     * @param segmentLegIndex The index of the hold's parent leg in its segment.
     * @param holdLeg The hold leg to add.
     * @returns The inserted hold-at-waypoint leg, or `undefined` if the leg could not be inserted.
     */
    insertHold(planIndex: number, segmentIndex: number, segmentLegIndex: number, holdLeg: FlightPlanLeg): LegDefinition | undefined;
    /**
     * Edits a hold in a flight plan. The existing hold leg will be removed from the flight plan and a new hold leg with
     * the edited parameters will be inserted in its place.
     * @param planIndex The index of the flight plan containing the hold to edit.
     * @param segmentIndex The index of the segment containing the hold to edit.
     * @param segmentLegIndex The index of the hold leg in its containing segment.
     * @param holdLeg A leg describing the new hold parameters to apply.
     * @returns The edited hold leg, or `undefined` if the hold could not be edited.
     */
    editHold(planIndex: number, segmentIndex: number, segmentLegIndex: number, holdLeg: FlightPlanLeg): LegDefinition | undefined;
    /**
     * Activates the nearest and most applicable leg of the primary flight plan.
     * @param allowMissedApproach Whether to allow activation of missed approach legs. Defaults to `false`.
     * @returns Whether a leg was successfully activated.
     */
    activateNearestLeg(allowMissedApproach?: boolean): boolean;
    /**
     * Gets the normalized leg reference position from the leg.
     * @param leg The leg to get the position for.
     * @returns The normalized reference position.
     */
    private getLegReferencePosition;
    /**
     * Gets the XTK of the closest vector on the leg.
     * @param leg The leg to get the XTK for.
     * @returns The closest leg vector XTK.
     */
    private getClosestLegXtk;
    /**
     * Returns the index of the last element in the array where predicate is true, and -1
     * otherwise.
     * @param array The source array to search in
     * @param predicate find calls predicate once for each element of the array, in descending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.
     * @param defaultReturn is the default value
     * @returns either the index or the default if the predicate criteria is not met
     */
    private findLastSegmentIndex;
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param index The index of the leg in the segment to insert. Will add to the end of the segment if ommitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the new leg definition.
     */
    private planAddLeg;
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove.
     * @param notify Whether or not to send notifications after the operation. True by default.
     * @param skipDupCheck Whether to skip checking for duplicates. False by default.
     * @param skipCancelDirectTo Whether to skip canceling a direct to existing if the removed leg is equal to or is
     * located before the direct to target. False by default.
     * @returns whether a leg was removed.
     */
    private planRemoveLeg;
    /**
     * Handles removing a leg that is either in an airway segment or is an entry for an airway segment.
     * @param plan The flight plan containing the leg to remove.
     * @param airwayLegType The type of the leg to remove with respect to its associated airway.
     * @param segmentIndex The index of the segment containing the leg to remove.
     * @param segmentLegIndex The index of the leg to remove in its segment.
     * @returns Whether this handler processed the remove request.
     */
    private removeLegAirwayHandler;
    /**
     * Checks if a flight plan segment is empty, and removes the segment if it is eligible to be removed. Only Enroute
     * segments that are followed by another Enroute segment are eligible to be removed if empty.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment to check.
     * @returns Whether the segment was removed.
     */
    private checkAndRemoveEmptySegment;
    /**
     * Checks if a remove left an empty segment that also needs to be removed.
     * @param plan is the flight plan
     * @param segmentIndex The segment to add the leg to.
     * @returns whether to remove the segment.
     */
    private checkIfRemoveLeftEmptySegmentToDelete;
    /**
     * Adds an appropriate origin or destination leg (either an airport or runway fix) to the primary flight plan. Origin
     * legs are added to the beginning of the specified segment. Destination legs are added to the end of the specified
     * segment.
     * @param isOrigin Whether to add an origin leg.
     * @param segmentIndex The index of the segment to which to add the leg.
     * @param airportIcao The ICAO of the leg's airport.
     * @param runway The leg's runway.
     */
    private planAddOriginDestinationLeg;
    /**
     * Method to add a segment to the flightplan.
     * @param segmentType is the FlightPlanSegmentType.
     * @param index is the optional segment index to insert the segment.
     * @returns the segment index of the inserted segment.
     */
    private planInsertSegmentOfType;
    /**
     * Method to remove all legs from a segment.
     * @param segmentIndex is the index of the segment to delete all legs from.
     * @param segmentType is the type if segment to delete all legs from, if known.
     */
    private planClearSegment;
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    private planInsertSegment;
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    private planRemoveSegment;
    /**
     * Checks whether of two consecutive flight plan legs, the second is a duplicate of the first. The second leg is
     * considered a duplicate if and only if it is an IF, TF, or DF leg with the same terminator fix as the first leg,
     * which is also an IF, TF, or DF leg.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is a duplicate of the first.
     */
    private isDuplicateLeg;
    /**
     * Checks whether of two consecutive flight plan legs, the second is an IF leg and is a duplicate of the first. The
     * IF leg is considered a duplicate if and only if its fix is the same as the fix at which the first leg terminates.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is an duplicate IF leg of the first.
     */
    private isDuplicateIFLeg;
    /**
     * Merges two duplicate legs such that the new merged leg contains the fix type and altitude data from the source leg
     * and all other data is derived from the target leg.
     * @param target The target leg.
     * @param source The source leg.
     * @returns the merged leg.
     */
    private mergeDuplicateLegData;
    /**
     * Deletes one of two consecutive duplicate legs. If one leg is in a procedure and the other is not, the leg that is
     * not in a procedure will be deleted. If the legs are in different procedures, the earlier leg will be deleted.
     * Otherwise, the later leg will be deleted. If the deleted leg is the target leg of a direct to, the legs in the
     * direct to sequence will be copied and moved to immediately follow the duplicate leg that was not deleted.
     * @param leg1 The first duplicate leg.
     * @param leg2 The second duplicate leg.
     * @returns the leg that was deleted, or null if neither leg was deleted.
     * @throws Error if direct to legs could not be updated.
     */
    private planRemoveDuplicateLeg;
    /**
     * Cancels OBS and optionally converts the OBS course to a Direct-To.
     * @param convertToDto Whether to convert the OBS course to a Direct-To.
     * @returns The net number of legs inserted into the active flight plan as a result of converting the OBS course to
     * a Direct-To.
     */
    private cancelObs;
    /**
     * Converts an OBS course to a Direct-To. The OBS's target leg is assumed to be the currently active flight plan leg.
     * @returns The net number of legs inserted into the active flight plan as a result of converting the OBS course to
     * a Direct-To.
     */
    private convertObsToDirectTo;
    /**
     * Loads an approach frequency into a NAV radio.
     * @param radioIndex The index of the NAV radio into which to load the frequency.
     */
    private setLocFrequency;
    /**
     * Sets the approach details for the loaded approach and sends an event across the bus.
     * @param sync Whether to sync the details to other instruments.
     * @param isLoaded Whether an approach is loaded.
     * @param type The approach type.
     * @param bestRnavType The best available approach RNAV type.
     * @param rnavTypeFlags The RNAV minimum type flags for the approach.
     * @param isCircling Whether the approach is a circling approach.
     * @param isVtf Whether the approach is a vectors-to-final approach.
     * @param referenceFacility The approach's reference facility.
     * @param runway The assigned runway for the approach
     */
    private setApproachDetails;
    /**
     * Checks whether the approach details indicate that vertical guidance (GP) can be supported.
     * @returns whether or not vertical guidance is supported.
     */
    private doesApproachSupportGp;
    /**
     * Sets the approach details when an approach_details_set event is received from the bus.
     * @param approachDetails The approachDetails received from the bus.
     */
    private onApproachDetailsSet;
}

/**
 * Configuration options for {@link GarminNavToNavComputer}.
 */
type GarminNavToNavComputerOptions = {
    /** The ID of the CDI associated with the computer. Defaults to the empty string (`''`). */
    cdiId?: string;
    /** The indexes of the NAV radios that are allowable targets of a CDI source switch. */
    navRadioIndexes?: Iterable<NavRadioIndex> | SubscribableSet<NavRadioIndex>;
    /** The frequency, in hertz, with which the computer updates whether a CDI source switch is allowed. Defaults to `1`. */
    canSwitchUpdateFrequency?: number;
    /**
     * Whether to inhibit multiple CDI source switches for the same approach. If `true`, then after the CDI changes from
     * a GPS source to a NAV source while a CDI source switch is allowed by the computer, further source switches will be
     * disallowed by the computer until the approach is activated again or another approach is loaded.
     */
    inhibitMultipleSwitches?: boolean;
};
/**
 * A computer that calculates Garmin guidance data for an autopilot nav-to-nav manager.
 *
 * The guidance data produced by the computer allows automatic CDI source switching to be armed while all of the
 * following conditions are met:
 * - A localizer-based approach is loaded and active in the flight plan.
 * - The approach frequency is tuned in the active frequency bank of one or more supported NAV radios.
 *
 * While the guidance data allows automatic CDI source switching to be armed, it also allows the autopilot's LOC and GS
 * modes to be armed.
 *
 * The guidance data allows automatic CDI source switching to occur when the conditions for arming in addition to all
 * of the following conditions are met:
 * - The approach leg ending at the faf fix is active in the flight plan.
 * - The airplane is within 15 nautical miles of the faf fix.
 * - LNAV CDI deviation is less than 1.2 times full-scale deviation.
 */
declare class GarminNavToNavComputer {
    private readonly bus;
    private static readonly EMPTY_APPROACH_DETAILS;
    private readonly cdiId;
    private readonly flightPlanner?;
    private readonly fms?;
    private readonly navRadioIndexes;
    private readonly navRadioData;
    private readonly inhibitMultipleSwitches;
    private readonly cdiSource;
    private readonly planePos;
    private lnavIsTracking;
    private readonly lnavDataXtk;
    private readonly lnavDataCdiScale;
    private approachDetails;
    private isApproachActive;
    private inhibitSwitchArmed;
    private inhibitSwitch;
    private readonly _armableNavRadioIndex;
    /**
     * The index of the NAV radio that can be armed for a CDI source switch, or `-1` if a CDI source switch cannot be
     * armed.
     */
    readonly armableNavRadioIndex: Subscribable<-1 | NavRadioIndex>;
    private readonly _armableLateralMode;
    /**
     * The autopilot lateral mode that can be armed prior to a CDI source switch, or `APLateralModes.NONE` if no modes
     * can be armed.
     */
    readonly armableLateralMode: Subscribable<number>;
    private readonly _armableVerticalMode;
    /**
     * The autopilot vertical mode that can be armed prior to a CDI source switch, or `APVerticalModes.NONE` if no modes
     * can be armed.
     */
    readonly armableVerticalMode: Subscribable<number>;
    private readonly _canSwitchCdi;
    /** Whether a CDI source switch is allowed at the current time. */
    readonly canSwitchCdi: Subscribable<boolean>;
    private readonly fmsSubs;
    private readonly canSwitchUpdateSub;
    private readonly inhibitSwitchSub?;
    /**
     * Creates a new instance of GarminNavToNavComputer.
     * @param bus The event bus.
     * @param arg2 The FMS from which to source data.
     * @param options Options with which to configure the computer.
     */
    constructor(bus: EventBus, fms: Fms | Subscribable<Fms>, options?: Readonly<GarminNavToNavComputerOptions>);
    /**
     * Creates a new instance of GarminNavToNavComputer.
     * @param bus The event bus.
     * @param arg2 The FMS from which to source data.
     * @param options Options with which to configure the computer.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, options?: Readonly<GarminNavToNavComputerOptions>);
    /**
     * Responds to when this computer's supported NAV radio indexes change.
     * @param set The set containing the supported NAV radio indexes.
     * @param type The type of change that occurred.
     * @param index The NAV radio index that was added or removed.
     */
    private onNavRadioIndexesChanged;
    /**
     * Responds to when the FMS approach details change.
     * @param approachDetails The new FMS approach details.
     */
    private onApproachDetailsChanged;
    /**
     * Responds to when the FMS flight phase changes.
     * @param flightPhase The new FMS flight phase.
     */
    private onFmsFlightPhaseChanged;
    /**
     * Responds to when the FMS flight phase changes.
     */
    private onApproachActivated;
    /**
     * Responds to when the source for this computer's associated CDI changes.
     * @param source The new CDI source.
     */
    private onCdiSourceChanged;
    /**
     * Updates the CDI switch armable state calculated by this computer.
     */
    private updateArmableState;
    /**
     * Updates whether a CDI switch is allowed at the current time.
     */
    private updateCanSwitchCdi;
}

/**
 * Guidance data for {@link GarminNavToNavManager2}.
 */
interface GarminNavToNavManager2Guidance {
    /** The ID of the CDI for which a CDI switch should be commanded. */
    readonly cdiId: Accessible<string>;
    /**
     * The index of the NAV radio that can be armed for a CDI source switch, or `-1` if a CDI source switch cannot be
     * armed.
     */
    readonly armableNavRadioIndex: Accessible<NavRadioIndex | -1>;
    /**
     * The autopilot lateral mode that can be armed prior to a CDI source switch, or `APLateralModes.NONE` if no modes
     * can be armed.
     */
    readonly armableLateralMode: Accessible<number>;
    /**
     * The autopilot vertical mode that can be armed prior to a CDI source switch, or `APVerticalModes.NONE` if no modes
     * can be armed.
     */
    readonly armableVerticalMode: Accessible<number>;
    /** Whether a CDI source switch is allowed at the current time. */
    readonly canSwitchCdi: Accessible<boolean>;
    /** Whether an external entity is currently in the process of switching the autopilot's CDI source. */
    readonly isExternalCdiSwitchInProgress: Accessible<boolean>;
}
/**
 * Configuration options for {@link GarminNavToNavManager2}.
 */
type GarminNavToNavManager2Options = {
    /**
     * A function that checks whether an armed autopilot lateral mode can be activated as part of a CDI source switch.
     * @param navRadioIndex The index of the NAV radio that is armed for a potential CDI source switch.
     * @param armedLateralMode The armed autopilot lateral mode.
     * @returns Whether the specified armed autopilot lateral mode can be activated as part of a CDI source switch.
     */
    canArmedModeActivate?: (navRadioIndex: NavRadioIndex, armedLateralMode: number) => boolean;
};
/**
 * An implementation of `NavToNavManager2` that uses guidance data generated from an outside source to determine when
 * CDI source switching can be armed and triggered.
 */
declare class GarminNavToNavManager2 implements NavToNavManager2 {
    private readonly bus;
    private readonly apValues;
    private readonly guidance;
    /** @inheritDoc */
    readonly isNavToNavManager2 = true;
    onTransferred?: ((activateLateralMode: number, activateVerticalMode: number) => void) | undefined;
    private readonly cdiSource;
    private readonly canArmedModeActivate;
    private isNavToNavInProgress;
    private navToNavInProgressCdiId;
    private navToNavInProgressLateralMode;
    /**
     * Creates a new instance of GarminNavToNavManager2.
     * @param bus The event bus.
     * @param apValues Autopilot values from this manager's parent autopilot.
     * @param guidance The guidance data used by this manager.
     * @param options Options with which to configure the manager.
     */
    constructor(bus: EventBus, apValues: APValues, guidance: GarminNavToNavManager2Guidance, options?: Readonly<GarminNavToNavManager2Options>);
    /** @inheritDoc */
    getArmableNavRadioIndex(): NavRadioIndex | -1;
    /** @inheritDoc */
    getArmableLateralMode(): number;
    /** @inheritDoc */
    getArmableVerticalMode(): number;
    /** @inheritDoc */
    isTransferInProgress(): boolean;
    /** @inheritDoc */
    onBeforeUpdate(): void;
    /** @inheritDoc */
    onAfterUpdate(): void;
    /**
     * Updates this manager in the default state while a CDI source switch is not in progress.
     */
    private updateDefault;
    /**
     * Updates this manager while a CDI source switch is in progress.
     */
    private updateInProgress;
    /**
     * Starts a CDI source switch.
     * @param cdiId The ID of the CDI for which to command the switch.
     * @param navRadioIndex The index of the NAV radio to which to switch the CDI.
     * @param armedLateralMode The armed autopilot lateral mode to activate as part of the switch.
     */
    private startNavToNav;
    /**
     * Cancels a CDI source switch.
     */
    private cancelNavToNav;
    /**
     * Completes a CDI source switch.
     */
    private completeNavToNav;
    /**
     * Checks whether an armed autopilot lateral mode can be activated as part of a CDI source switch using criteria that
     * reproduce the default localizer capture criteria for the autopilot's LOC director.
     * @param navRadioIndex The index of the NAV radio that is armed for a potential CDI source switch.
     * @param armedLateralMode The armed autopilot lateral mode.
     * @returns Whether the specified armed autopilot lateral mode can be activated as part of a CDI source switch using
     * criteria that reproduce the default localizer capture criteria for the autopilot's LOC director.
     */
    private static defaultCanArmedModeActivate;
}

/**
 * Configuration options for {@link GarminGlidepathComputer}.
 */
interface GarminGlidepathComputerOptions {
    /** The index of the flight plan for which to provide vertical guidance. Defaults to `0`. */
    primaryPlanIndex?: number;
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** Whether to allow +V approach service levels when no SBAS is present. Defaults to `true`. */
    allowPlusVWithoutSbas?: boolean;
    /** Whether to allow approach service levels requiring baro VNAV. Defaults to `false`. */
    allowApproachBaroVNav?: boolean;
    /** Whether to allow RNP (AR) approach service levels. Defaults to `false`. */
    allowRnpAr?: boolean;
    /**
     * The current GPS system state. If not defined, then the computer behaves as if a 3D solution with differential
     * corrections applied is available at all times.
     */
    gpsSystemState?: Subscribable<GPSSystemState>;
}
/**
 * A computer that calculates Garmin glidepath guidance for an active flight plan.
 */
declare class GarminGlidepathComputer {
    readonly index: number;
    private readonly bus;
    private readonly flightPlanner;
    private readonly publisher;
    private readonly simVarMap;
    private readonly vnavTopicMap;
    private readonly lnavIndex;
    private isLNavIndexValid;
    private readonly planePos;
    private currentAltitude;
    private currentGpsAltitude;
    private readonly fmsFlightPhase;
    private readonly approachDetails;
    private readonly glidepathServiceLevelCalculator;
    private readonly glidepathCalculator;
    private readonly approachHasGp;
    private readonly gpVerticalDeviation;
    private readonly gpDistance;
    private readonly gpFpa;
    private readonly gpServiceLevel;
    private readonly lnavLegIndex;
    private readonly lnavLegDistanceAlong;
    private readonly lnavDataXtk;
    private readonly lnavDataCdiScale;
    private readonly gpSupported;
    private readonly primaryPlanIndex;
    private readonly gpsSystemState;
    private readonly glidepathGuidanceBuffer;
    private readonly _glidepathGuidance;
    /** The glidepath guidance calculated by this computer. */
    readonly glidepathGuidance: Subscribable<Readonly<GarminVNavGlidepathGuidance>>;
    /**
     * Creates a new instance of GarminGlidepathComputer.
     * @param index The index of this computer.
     * @param bus The event bus.
     * @param flightPlanner The flight planner containing the flight plan for which this computer provides guidance.
     * @param options Options with which to configure the computer.
     */
    constructor(index: number, bus: EventBus, flightPlanner: FlightPlanner, options?: Partial<Readonly<GarminGlidepathComputerOptions>>);
    /**
     * Applies the failed state to this computer's glidepath calculations.
     */
    private failGlidepath;
    /**
     * Updates this computer.
     */
    update(): void;
    /**
     * Updates the glidepath guidance provided by this computer.
     */
    private updateGlidepathGuidance;
    /**
     * Method to monitor VNavVars.
     */
    private monitorVars;
    /**
     * Initializes glidepath-related SimVars.
     */
    private initVars;
    /**
     * Resets glidepath-related SimVars.
     */
    private resetGpVars;
    /**
     * Manages glidepath state.
     * @param lateralPlan The lateral flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param distanceAlongLeg The along-track distance from the start of the active flight plan leg to the airplane's
     * position, in meters.
     */
    private manageGlidepath;
}

/**
 * Configuration options for {@link GarminVNavComputer}.
 */
interface GarminVNavComputerOptions {
    /** The index of the flight plan for which to provide vertical guidance. Defaults to `0`. */
    primaryPlanIndex?: number;
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** Whether to enable advanced VNAV. Defaults to `false`. */
    enableAdvancedVNav?: boolean;
}
/**
 * A computer that calculates Garmin vertical navigation guidance for an active flight plan.
 */
declare class GarminVNavComputer {
    readonly index: number;
    private readonly bus;
    private readonly flightPlanner;
    private readonly calculator;
    private readonly apValues;
    /** The distance, in meters, from the first TOD in the flight plan the airplane must reach in order to enter descent phase. */
    private static readonly DESCENT_PHASE_TOD_DISTANCE;
    /** The vertical distance, in feet, below the cruise altitude the airplane must reach in order to enter cruise phase. */
    private static readonly CRUISE_PHASE_ALTITUDE_THRESHOLD;
    /**
     * The vertical distance, in meters, above the TOC altitude which defines the BOC suppression threshold. If the
     * airplane's indicated altitude is above this threshold, any existing BOC will be suppressed.
     */
    private static readonly BOC_SUPPRESS_ALTITUDE_THRESHOLD;
    /**
     * The vertical distance, in meters, below the TOC altitude which defines the TOC suppression threshold. If the
     * airplane's indicated altitude is above this threshold, any existing TOC will be suppressed.
     */
    private static readonly TOC_SUPPRESS_ALTITUDE_THRESHOLD;
    /**
     * The time to TOD threshold, in seconds, below which the descent path on which the TOD lies becomes the active
     * descent path and can be captured by VPATH.
     */
    private static readonly ACTIVE_PATH_TOD_TIME_THRESHOLD;
    /**
     * The amount of hysteresis applied to the time to TOD threshold, in seconds, after a descent path has become active.
     */
    private static readonly ACTIVE_PATH_TOD_TIME_HYSTERESIS;
    /**
     * The amount of time, in seconds, remaining to a vertical track change, at or below which a vertical track alert can
     * be issued.
     */
    private static readonly TRACK_ALERT_ISSUE_THRESHOLD;
    /**
     * The amount of time, in seconds, remaining to a vertical track change, at or above which the corresponding vertical
     * track alert is re-armed.
     */
    private static readonly TRACK_ALERT_REARM_THRESHOLD;
    private readonly publisher;
    private readonly simVarMap;
    private readonly vnavTopicMap;
    private readonly lnavIndex;
    private isLNavIndexValid;
    private readonly simRate;
    private lastUpdateTime?;
    private isEnabled;
    private state;
    private isActive;
    private readonly pathMode;
    private readonly planePos;
    private currentAltitude;
    private currentGpsAltitude;
    private currentGroundSpeed;
    private currentVS;
    private trueTrack;
    private readonly isAltSelectInitialized;
    private apSelectedAltitude;
    private apSelectedVs;
    private apLateralActiveMode;
    private apVerticalActiveMode;
    private apVerticalArmedMode;
    private readonly isVNavUnavailable;
    private isAwaitingAltCapture;
    private altitudeToCapture;
    private isAltCaptured;
    private capturedAltitude;
    private stagedIsClimbArmed;
    private isClimbArmed;
    private shouldActivateClimbMode;
    private stagedIsAwaitingPathRearm;
    private stagedPathRearmIndex;
    private isAwaitingPathRearm;
    private pathRearmIndex;
    private isPathActivationInhibited;
    private pathReactivationTimeRemaining;
    private pathReactivationDeviationStage;
    private lastCapturedPathDesiredAltitude?;
    /** The highest VNAV constraint altitude that appears in the primary flight plan. */
    private highestConstraintAltitude;
    /** The global index of the last leg in the last non-missed approach climb constraint in the primary flight plan. */
    private lastClimbConstraintLegIndex;
    /** The global index of the last leg in the first descent constraint in the primary flight plan. */
    private firstDescentConstraintLegIndex;
    private activePathConstraintIndex;
    private readonly todBodDetails;
    private readonly tocBocDetails;
    private readonly todBodDetailsSubject;
    private readonly tocBocDetailsSubject;
    private readonly allTrackAlertTypes;
    private readonly isTrackAlertArmed;
    private readonly vnavState;
    private readonly pathAvailable;
    private readonly currentConstraintLegIndex;
    private readonly vnavActiveConstraintLegIndex;
    private readonly targetAltitude;
    private readonly fpa;
    private readonly verticalDeviation;
    private readonly requiredVS;
    private readonly captureType;
    private readonly cruiseAltitude;
    private readonly vnavFlightPhase;
    private readonly vnavTrackingPhase;
    private readonly currentAltitudeConstraintDetailsWorking;
    private readonly currentAltitudeConstraintDetails;
    private readonly lnavLegIndex;
    private readonly lnavLegDistanceAlong;
    private readonly lnavXtk;
    private readonly lnavDtk;
    private readonly lnavDataCdiScale;
    private readonly activateMaprState;
    private readonly noVNavTae;
    private readonly noVNavXtk;
    private readonly pathArmedError;
    private readonly pathBelowAircraft;
    private readonly noPathThisLeg;
    private readonly noPathConditionDisco;
    private readonly noPathVectors;
    private readonly checkAltSel;
    private readonly withinOneMinuteTod;
    private readonly withinFiveSecondsTod;
    private readonly checkFplnAlt;
    private readonly primaryPlanIndex;
    private readonly enableAdvancedVNav;
    private readonly guidanceBuffer;
    private readonly _guidance;
    /** The VNAV guidance calculated by this computer. */
    readonly guidance: Subscribable<Readonly<GarminVNavGuidance>>;
    private readonly pathGuidanceBuffer;
    private readonly _pathGuidance;
    /** The vertical path guidance calculated by this computer. */
    readonly pathGuidance: Subscribable<Readonly<GarminVNavPathGuidance>>;
    /**
     * Creates a new instance of GarminVNavComputer.
     * @param index The index of this computer.
     * @param bus The event bus.
     * @param flightPlanner The flight planner containing the flight plan for which this computer provides guidance.
     * @param calculator The VNAV path calculator providing the vertical flight path for which this computer provides
     * guidance.
     * @param apValues Autopilot values for the autopilot associated with this computer.
     * @param options Options with which to configure the computer.
     */
    constructor(index: number, bus: EventBus, flightPlanner: FlightPlanner, calculator: VNavPathCalculator, apValues: Readonly<GarminVNavComputerAPValues>, options?: Partial<Readonly<GarminVNavComputerOptions>>);
    /**
     * Attempts to activate VNAV.
     */
    tryActivate(): void;
    /**
     * Attempts to deactivate VNAV.
     */
    tryDeactivate(): void;
    /**
     * Sets whether VNAV is enabled.
     * @param enabled Whether VNAV is enabled.
     */
    private setEnabled;
    /**
     * Sets this computer's VNAV state.
     * @param vnavState The state to set.
     */
    private setState;
    /**
     * Applies the failed state to this computer's VNAV calculations.
     */
    private failVNav;
    /**
     * Activates altitude capture mode.
     * @param altitude The altitude to capture, in feet.
     * @param flightPhase The vertical flight phase for which to arm a vertical mode once the altitude has been
     * captured, or `undefined` if no vertical mode should be armed. If the flight phase is `VerticalFlightPhase.Climb`,
     * then FLC will be armed. If the flight phase is `VerticalFlightPhase.Descent`, then PATH will be armed.
     * @param pathRearmIndex The global flight plan leg index at which PATH mode can be armed. Ignored if `flightPhase`
     * is not `VerticalFlightPhase.Descent`. Defaults to the index of the leg after the active flight plan leg at the
     * time the method is called.
     */
    private activateAltCap;
    /**
     * Cancels altitude capture mode.
     */
    private cancelAltCap;
    /**
     * Disarms climb (FLC) mode.
     */
    private disarmClimb;
    /**
     * Arms PATH mode.
     */
    private armPath;
    /**
     * Activates PATH mode.
     */
    private activatePath;
    /**
     * Deactivates and disarms PATH mode.
     */
    private disarmPath;
    /**
     * Resets this computer's PATH mode re-activation inhibit state.
     */
    private resetPathReactivationInhibit;
    /**
     * Updates this computer.
     */
    update(): void;
    /**
     * Updates the autopilot values used by this computer.
     */
    private updateAPValues;
    /**
     * Updates the autopilot's active lateral mode.
     * @param mode The active lateral mode.
     */
    private updateApLateralActiveMode;
    /**
     * Updates the autopilot's active vertical mode.
     * @param mode The active vertical mode.
     */
    private updateApVerticalActiveMode;
    /**
     * Updates the autopilot's armed vertical mode.
     * @param mode The armed vertical mode.
     */
    private updateApVerticalArmedMode;
    /**
     * Responds to when the autopilot's PATH director is deactivated.
     */
    private onPathDirectorDeactivated;
    /**
     * Updates the guidance provided by this computer.
     */
    private updateGuidance;
    /**
     * Updates the vertical path guidance provided by this computer.
     */
    private updatePathGuidance;
    /**
     * Updates vertical track alerts for the climb phase.
     * @param tocBocDetails The computed TOC/BOC details.
     */
    private updateClimbTrackAlerts;
    /**
     * Updates vertical track alerts for the descent phase.
     * @param todBodDetails The computed TOD/BOD details.
     */
    private updateDescentTrackAlerts;
    /**
     * Issues a vertical track alert.
     * @param type The type of alert to issue.
     */
    private issueTrackAlert;
    /**
     * Updates vertical tracking for climb.
     * @param verticalPlan The vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param tocBocDetails The computed TOC/BOC details.
     * @param activeConstraintIndex The index of the VNAV constraint containing the active flight plan leg, or `-1` if
     * there is no such constraint.
     */
    private trackClimb;
    /**
     * Gets the next altitude constraint to be sequenced that defines an altitude to be met for required vertical speed
     * calculations.
     * @param verticalPlan The vertical flight plan.
     * @param activeConstraintIndex The index of the VNAV constraint containing the active flight plan leg.
     * @param globalLegIndex The index of the active flight plan leg.
     * @param distanceAlongLeg The along-track distance from the start of the active flight plan leg to the the
     * airplane's position, in meters.
     * @returns The next altitude constraint to be sequenced that defines an altitude to be met for required vertical
     * speed calculations, or `undefined` if there is no such constraint.
     */
    private getClimbRequiredVs;
    /**
     * Updates vertical tracking for descent.
     * @param dt The elapsed simulation time since the last update cycle, in milliseconds.
     * @param verticalPlan The vertical flight Plan.
     * @param lateralPlan The lateral flight Plan.
     * @param todBodDetails The computed TOD/BOD details.
     * @param activeConstraintIndex The index of the VNAV constraint containing the active flight plan leg, or `-1` if
     * there is no such constraint.
     * @param activePathConstraintIndex The index of the constraint defining the active descent path, or `-1` if there is
     * no active descent path.
     */
    private trackDescent;
    /**
     * Gets the next altitude constraint to be sequenced that defines an altitude to be met for required vertical speed
     * calculations.
     * @param verticalPlan The vertical flight plan.
     * @param pathConstraintIndex The current vertical flight phase.
     * @param globalLegIndex The index of the active flight plan leg.
     * @param distanceAlongLeg The along-track distance from the start of the active flight plan leg to the the
     * airplane's position, in meters.
     * @returns The next altitude constraint to be sequenced that defines an altitude to be met for required vertical
     * speed calculations, or `undefined` if there is no such constraint.
     */
    private getDescentRequiredVs;
    /**
     * Checks whether the VNav Path can arm.
     * @returns Whether Path can arm.
     */
    private canPathArm;
    /**
     * Checks whether V PATH can be activated from an armed state.
     * @param pathFpa The flight path angle of the active descent path, in degrees.
     * @param verticalDeviation The vertical deviation from the active descent path, in feet.
     * @param deviationFromTarget The deviation from the target altitude of the descent path, in feet.
     * @returns Whether V PATH can be activated from an armed state.
     */
    private canPathActivate;
    /**
     * Arms PATH if it is not already armed and can be armed, and disarms PATH if it is already armed and current
     * conditions do not allow it to be armed.
     */
    private updatePathArmState;
    /**
     * Updates this manager's track error states - whether LNAV track angle error or cross-track error have exceeded
     * the allowed limits for VNAV to provide vertical tracking.
     */
    private updateTrackErrorState;
    /**
     * Checks whether PATH mode should be deactivated.
     * @param desiredAltitude The current desired altitude, in feet, at the airplane's current position along the
     * vertical path.
     * @param verticalDeviation The current vertical deviation, in feet, of the vertical path from the airplane. Positive
     * values indicate the path lies above the airplane.
     * @returns Whether PATH mode should be deactivated.
     */
    private shouldDeactivatePath;
    /**
     * Checks whether the XTK is out of limits for vnav.
     * @returns if the XTK is out of limits.
     */
    private isXtkOutsideLimits;
    /**
     * Chekcs if the TAE is out of limits for vnav.
     * @returns if TAE is out of limits.
     */
    private isTaeOutsideLimits;
    /**
     * Method to reset all error messages.
     */
    private clearAllMessages;
    /**
     * Method to monitor message state.
     */
    private monitorMessages;
    /**
     * Method to monitor VNavVars.
     */
    private monitorVars;
    /**
     * Method to reset VNAV Vars.
     */
    private initVars;
    /**
     * Resets the VNAV constraint simvars.
     */
    private resetVNavConstraintVars;
    /**
     * Resets the VNAV flight and tracking phases.
     */
    private resetVNavPhase;
    /**
     * Resets the VNAV tracking simvars.
     */
    private resetVNavTrackingVars;
    /**
     * Resets the TOD/BOD simvars.
     */
    private resetTodBodVars;
    /**
     * Resets the TOC/BOC simvars.
     */
    private resetTocBocVars;
    /**
     * Resets vertical track alert state.
     */
    private resetTrackAlerts;
    /**
     * Manages the TOD/BOD and BOC/TOC details simvars.
     * @param activeLateralLegIndex The index of the active lateral flight plan leg.
     * @param todBodDetails The computed TOD/BOD details.
     * @param bocTocDetails The computed BOC/TOC details.
     */
    private manageTodBodTocBocDetails;
    /**
     * Sets the current constraint details.
     * @param verticalPlan The vertical plan.
     * @param constraintIndex The index of the current constraint.
     * @param activeLegIndex The global index of the active flight plan leg.
     */
    private setCurrentConstraintDetails;
    /**
     * Gets the required vertical speed to meet an altitude constraint.
     * @param distance The distance to the constraint, in nautical miles.
     * @param targetAltitude The target altitude for the constraint, in feet.
     * @param currentAltitude The current altitude, in feet. Defaults to the airplane's current indicated altitude.
     * @returns The required vertical speed, in feet per minute, to meet the altitude constraint.
     */
    private getRequiredVs;
    /**
     * Publishes TOD/BOD details to simvars.
     * @param details The TOD/BOD details object.
     * @param key The key to publish.
     * @param value The value to publish.
     */
    private publishTodBodDetails;
    /**
     * Publishes BOC/TOC details to simvars.
     * @param details The BOC/TOC details object.
     * @param key The key to publish.
     * @param value The value to publish.
     */
    private publishBocTocDetails;
}

/**
 * Garmin VNAV flight phases.
 */
declare enum GarminVNavFlightPhase {
    None = "None",
    Climb = "Climb",
    Cruise = "Cruise",
    Descent = "Descent"
}
/**
 * Garmin VNAV tracking phases.
 */
declare enum GarminVNavTrackingPhase {
    None = "None",
    Climb = "Climb",
    Cruise = "Cruise",
    Descent = "Descent",
    MissedApproach = "MissedApproach"
}
/**
 * Garmin VNAV track alert types.
 */
declare enum GarminVNavTrackAlertType {
    TodOneMinute = "TodOneMinute",
    BodOneMinute = "BodOneMinute",
    TocOneMinute = "TocOneMinute",
    BocOneMinute = "BocOneMinute"
}
/**
 * Garmin VNAV-related data events keyed by base topic names.
 */
interface BaseGarminVNavDataEvents extends VNavDataEvents$1 {
    /** The current VNAV cruise altitude, in feet. */
    vnav_cruise_altitude: number;
    /** The current VNAV flight phase. */
    vnav_flight_phase: GarminVNavFlightPhase;
    /** The current VNAV tracking phase. */
    vnav_tracking_phase: GarminVNavTrackingPhase;
    /** The global index of the leg that contains the active VNAV constraint. */
    vnav_active_constraint_global_leg_index: number;
    /** A VNAV track alert has been issued. */
    vnav_track_alert: GarminVNavTrackAlertType;
}
/**
 * Garmin VNAV-related data events keyed by indexed topic names.
 */
type IndexedGarminVNavDataEvents<Index extends number = number> = {
    [P in keyof BaseGarminVNavDataEvents as `${P}_${Index}`]: BaseGarminVNavDataEvents[P];
};
/**
 * Events related to Garmin VNAV data.
 */
interface GarminVNavDataEvents extends BaseGarminVNavDataEvents, IndexedGarminVNavDataEvents {
}
/**
 * Events related to Garmin VNAV data.
 * @deprecated
 */
type VNavDataEvents = GarminVNavDataEvents;

/**
 * Events published by Garmin VNAV keyed by base topic names.
 */
interface BaseGarminVNavEvents extends BaseVNavEvents {
    /** Whether VNAV is enabled. */
    vnav_is_enabled: boolean;
}
/**
 * Events published by Garmin VNAV keyed by indexed topic names.
 */
type IndexedGarminVNavEvents<Index extends number = number> = {
    [P in keyof BaseGarminVNavEvents as `${P}_${Index}`]: BaseGarminVNavEvents[P];
};
/**
 * Events published by Garmin VNAV.
 */
interface GarminVNavEvents extends BaseGarminVNavEvents, IndexedGarminVNavEvents {
}

/**
 * Options for {@link GarminVNavManager2}.
 */
interface GarminVNavManager2Options {
    /**
     * A function that creates an internal VNAV computer for the VNAV manager. The internal computer will be updated by
     * the VNAV manager, and the manager will use the internal computer's VNAV and VNAV path guidance.
     * @param apValues The autopilot's state values.
     * @returns An internal VNAV computer for the VNAV manager.
     */
    internalVNavComputer?: (apValues: APValues) => GarminVNavComputer;
    /**
     * A function that creates an internal glidepath computer for the VNAV manager. The internal computer will be updated
     * by the VNAV manager, and the manager will use the internal computer's glidepath guidance.
     * @param apValues The autopilot's state values.
     * @returns An internal glidepath computer for the VNAV manager.
     */
    internalGlidepathComputer?: (apValues: APValues) => GarminGlidepathComputer;
    /** The VNAV guidance to use. Ignored if `internalVNavComputer` is defined. */
    guidance?: Accessible<Readonly<GarminVNavGuidance>> | undefined;
    /** The glidepath guidance to use. Ignored if `internalGlidepathComputer` is defined. */
    glidepathGuidance?: Accessible<Readonly<GarminVNavGlidepathGuidance>> | undefined;
}
/**
 * A new Garmin VNav Manager.
 */
declare class GarminVNavManager2 implements VNavManager {
    private readonly bus;
    private readonly apValues;
    private readonly publisher;
    /** @inheritDoc */
    state: VNavState;
    /** @inheritDoc */
    onActivate?: () => void;
    /** @inheritDoc */
    onDeactivate?: () => void;
    /** @inheritDoc */
    armMode?: (mode: number) => void;
    /** @inheritDoc */
    activateMode?: (mode: number) => void;
    /** Whether VNAV is active. */
    get isActive(): boolean;
    /** This manager's internal VNAV computer. */
    readonly vnavComputer?: GarminVNavComputer;
    /** This manager's internal glidepath computer. */
    readonly glidepathComputer?: GarminGlidepathComputer;
    private readonly guidance?;
    private readonly glidepathGuidance?;
    private inhibitPathMode;
    /**
     * Creates a new instance of GarminVNavManager2 that uses VNAV guidance from an external source.
     * @param bus The event bus.
     * @param apValues Autopilot values from this manager's parent autopilot.
     * @param options Options with which to configure the manager.
     */
    constructor(bus: EventBus, apValues: APValues, options?: Readonly<GarminVNavManager2Options>);
    /** @inheritDoc */
    setState(): void;
    /** @inheritDoc */
    tryActivate(): void;
    /** @inheritDoc */
    tryDeactivate(): void;
    /** @inheritDoc */
    canVerticalModeActivate(mode: number): boolean;
    /** @inheritDoc */
    onPathDirectorDeactivated(): void;
    /**
     * Method called to delegate altitude capture to the Alt Cap Director.
     * @param altitude The altitude to capture.
     */
    private delegateAltCap;
    /**
     * Arms a climb mode. The mode will be armed only if the currently active vertical mode is an altitude hold mode.
     * @param mode The mode to arm.
     */
    private armClimb;
    /**
     * Activates a climb mode.
     * @param mode The mode to activate.
     */
    private activateClimb;
    /**
     * Disarms climb (FLC) mode.
     */
    private disarmClimb;
    /**
     * Arms PATH mode. The mode will be armed only if the currently active vertical mode is not an altitude capture mode.
     */
    private armPath;
    /**
     * Activates PATH mode.
     */
    private activatePath;
    /**
     * Deactivates and disarms PATH mode.
     */
    private disarmPath;
    /** @inheritDoc */
    update(): void;
}

/**
 * Events published by Garmin VNAV managers.
 */
interface GarminVNavManagerEvents {
    /** The VNAV manager was activated. */
    vnav_manager_activated: void;
    /** The VNAV manager was deactivated. */
    vnav_manager_deactivated: void;
}

/**
 * A utility class for working with Garmin VNAV.
 */
declare class GarminVNavUtils {
    /**
     * Checks if a lateral flight plan leg is eligible for VNAV.
     * @param lateralLeg A lateral flight plan leg.
     * @returns Whether the specified leg is eligible for VNAV.
     */
    static isLegVNavEligible(lateralLeg: LegDefinition): boolean;
    /**
     * Checks whether an altitude constraint defined for a lateral flight plan leg should be used for VNAV.
     * @param lateralPlan The lateral flight plan that hosts the altitude constraint.
     * @param lateralLeg The lateral flight plan leg that hosts the altitude constraint.
     * @param globalLegIndex The global index of the lateral flight plan leg that hosts the altitude constraint.
     * @param segment The lateral flight plan segment containing the flight plan leg that hosts the altitude constraint.
     * @param segmentLegIndex The index of the lateral flight plan leg that hosts the altitude constraint in its
     * containing segment.
     * @returns Whether the altitude constraint defined for the specified lateral flight plan leg should be used for
     * VNAV.
     */
    static shouldUseConstraint(lateralPlan: FlightPlan, lateralLeg: LegDefinition, globalLegIndex: number, segment: FlightPlanSegment, segmentLegIndex: number): boolean;
    /**
     * A function which checks whether a climb constraint should be invalidated.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check if it is already in the vertical flight plan. If the constraint
     * is not already in the vertical flight plan (i.e. the constraint has been previously invalidated), then this value
     * equals `-(index + 1)` where `index` is the index at which the constraint would appear in the vertical flight plan
     * if it were included.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param firstDescentConstraintIndex The index of the first descent constraint in the vertical flight plan, if one
     * exists.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * constraints of the same category (climb or missed approach) are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * constraints of the same category (climb or missed approach) are included.
     * @returns Whether the specified climb constraint should be invalidated.
     */
    static invalidateClimbConstraint(constraint: VNavConstraint, index: number, constraints: readonly VNavConstraint[], firstDescentConstraintIndex: number, priorMinAltitude: number, priorMaxAltitude: number): boolean;
    /**
     * A function which checks whether a descent constraint should be invalidated.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check if it is already in the vertical flight plan. If the constraint
     * is not already in the vertical flight plan, then this value equals `-(index + 1)`
     * if it is not, where `index`.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param requiredFpa The minimum flight path angle, in degrees, required to meet the maximum altitude of the
     * constraint to check, assuming a descent starting from the constraint defining the most recent prior minimum
     * altitude. Positive values indicate a descending path. If there is no required FPA because there is no defined
     * prior minimum altitude or maximum altitude for the constraint to check, or if the constraint to check is higher
     * than the prior minimum altitude, then this value will equal zero.
     * @param maxFpa The maximum allowed flight path angle, in degrees. Positive values indicate a descending path.
     * @returns Whether the specified descent constraint should be invalidated.
     */
    static invalidateDescentConstraint(constraint: VNavConstraint, index: number, constraints: readonly VNavConstraint[], priorMinAltitude: number, priorMaxAltitude: number, requiredFpa: number, maxFpa: number): boolean;
    /**
     * Gets the VNAV TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeConstraintIndex The index of the VNAV constraint containing the active flight plan leg.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param distanceAlongLeg The along-track distance from the start of the active flight plan leg to the airplane's
     * position, in meters.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    static getTodBodDetails(verticalPlan: VerticalFlightPlan, activeConstraintIndex: number, activeLegIndex: number, distanceAlongLeg: number, currentAltitude: number, currentVS: number, out: GarminTodBodDetails): GarminTodBodDetails;
    /**
     * Gets the VNAV TOC/BOC details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeConstraintIndex The index of the vertical constraint containing the active flight plan leg.
     * @param activeLegIndex The index of the active flight plan leg.
     * @param distanceAlongLeg The distance the plane is along the active flight plan leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param isMapr Whether to get TOC/BOC details for the missed approach.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC details.
     */
    static getTocBocDetails(verticalPlan: VerticalFlightPlan, activeConstraintIndex: number, activeLegIndex: number, distanceAlongLeg: number, currentGroundSpeed: number, currentAltitude: number, currentVS: number, isMapr: boolean, out: TocBocDetails): TocBocDetails;
    /**
     * Gets the along-track distance, in meters, from a point along the flight plan to the end of a VNAV constraint.
     * @param verticalPlan The vertical flight plan.
     * @param constraintIndex The index of the VNAV constraint to calculate the distance to.
     * @param globalLegIndex The global index of the flight plan leg along which the point to check lies.
     * @param distanceAlongLeg The distance, in meters, from the start of the flight plan leg to the point to check.
     * @returns The along-track distance, in meters, from the specified point to the end of the VNAV constraint.
     */
    static getDistanceToConstraint(verticalPlan: VerticalFlightPlan, constraintIndex: number, globalLegIndex: number, distanceAlongLeg: number): number;
    /**
     * Gets the desired altitude, in meters, along a descent path at a specific point.
     * @param verticalPlan The vertical flight plan.
     * @param pathConstraintIndex The index of the VNAV constraint defining the descent path.
     * @param distance The distance, in meters, from the point to check to the end of the VNAV constraint defining the
     * descent path.
     */
    static getPathDesiredAltitude(verticalPlan: VerticalFlightPlan, pathConstraintIndex: number, distance: number): number;
    /**
     * Gets the desired altitude, in meters, along a descent path at a specific point.
     * @param verticalPlan The vertical flight plan.
     * @param pathConstraintIndex The index of the VNAV constraint defining the descent path.
     * @param globalLegIndex The global index of the flight plan leg along which the point to check lies.
     * @param distanceAlongLeg The distance, in meters, from the start of the flight plan leg to the point to check.
     * @returns The desired altitude, in meters, along the descent path at the specified point.
     */
    static getPathDesiredAltitude(verticalPlan: VerticalFlightPlan, pathConstraintIndex: number, globalLegIndex: number, distanceAlongLeg: number): number;
}

/**
 * Data describing autopilot status used by Garmin FMAs.
 */
type FmaData = {
    /** The active vertical mode. */
    verticalActive: number;
    /** The armed vertical mode. */
    verticalArmed: number;
    /** The armed vertical approach mode. */
    verticalApproachArmed: number;
    /** The armed altitude capture mode. */
    verticalAltitudeArmed: number;
    /** Whether an altitude capture mode is armed. */
    altitudeCaptureArmed: boolean;
    /** The target altitude capture value, in feet. */
    altitudeCaptureValue: number;
    /** The active lateral mode. */
    lateralActive: number;
    /** The armed lateral mode. */
    lateralArmed: number;
    /** Whether the lateral mode is in a failed state. */
    lateralModeFailed: boolean;
    /** The state of VNAV to be displayed on the FMA. */
    vnavState: FmaVNavState;
};
/**
 * Events related to the Garmin FMA.
 */
interface FmaDataEvents {
    /** Data describing autopilot status used by the FMA. */
    fma_data: Readonly<FmaData>;
}
declare enum FmaVNavState {
    OFF = 0,
    ARMED = 1,
    ACTIVE = 2
}

/**
 * A Garmin Autopilot Configuration.
 */
interface GarminAPConfigInterface extends APConfig {
    /**
     * Whether the autopilot should use mach number calculated from the impact pressure derived from indicated airspeed
     * and ambient pressure instead of the true mach number.
     */
    readonly useIndicatedMach: boolean;
}

/**
 * Options for configuring a Garmin GPS (LNAV) director.
 */
type GarminLNavDirectorOptions = {
    /**
     * The steering command to send to the autopilot's GPS roll-steering director.
     */
    steerCommand: Accessible<Readonly<APGpsSteerDirectorSteerCommand>>;
    /**
     * Whether to disable arming on the GPS director. If `true`, then the director will skip the arming phase and instead
     * immediately activate itself when requested. Defaults to `false`.
     */
    disableArming?: boolean;
};
/**
 * Options for configuring Garmin autopilots.
 */
type GarminAPConfigOptions = {
    /** The ID of the CDI associated with the autopilot. Defaults to the empty string (`''`). */
    cdiId?: string;
    /**
     * Whether the autopilot should use mach number calculated from the impact pressure derived from indicated airspeed
     * and ambient pressure instead of the true mach number. Defaults to `false`.
     */
    useIndicatedMach?: boolean;
    /** The default rate at which commanded pitch changes, in degrees per second. Defaults to `5`. */
    defaultPitchRate?: number;
    /** The default rate at which commanded bank changes, in degrees per second. Defaults to `10`. */
    defaultBankRate?: number;
    /** Options for the LNAV (GPSS) director. If not defined, then the autopilot will not include an LNAV director */
    lnavOptions?: Readonly<GarminLNavDirectorOptions>;
    /**
     * A function that creates an internal VNAV computer for the autopilot's VNAV manager. The internal computer will be
     * updated by the VNAV manager, and the autopilot will use the internal computer's VNAV and VNAV path guidance.
     * @param apValues The autopilot's state values.
     * @returns An internal VNAV computer for the autopilot's VNAV manager.
     */
    internalVNavComputer?: (apValues: APValues) => GarminVNavComputer;
    /**
     * A function that creates an internal glidepath computer for the autopilot's VNAV manager. The internal computer
     * will be updated by the VNAV manager, and the autopilot will use the internal computer's glidepath guidance.
     * @param apValues The autopilot's state values.
     * @returns An internal glidepath computer for the autopilot's VNAV manager.
     */
    internalGlidepathComputer?: (apValues: APValues) => GarminGlidepathComputer;
    /** VNAV guidance for the autopilot's VNAV manager to use. Ignored if `internalVNavComputer` is defined. */
    vnavGuidance?: Accessible<Readonly<GarminVNavGuidance>>;
    /** Guidance for the autopilot's VNAV path director to use. Ignored if `internalVNavComputer` is defined. */
    verticalPathGuidance?: Accessible<Readonly<GarminVNavPathGuidance>>;
    /** Guidance for the autopilot's glidepath director to use. Ignored if `internalGlidepathComputer` is defined. */
    glidepathGuidance?: Accessible<Readonly<GarminVNavGlidepathGuidance>>;
    /**
     * Guidance for the autopilot's nav-to-nav manager to use. If defined, then a `GarminNavToNavManager2` will be
     * created as the autopilot's nav-to-nav manager and the guidance will be passed to it. If not defined, then the
     * autopilot will not support nav-to-nav.
     */
    navToNavGuidance?: GarminNavToNavManager2Guidance;
    /**
     * Options with which to configure the autopilot's `GarminNavToNavManager2` nav-to-nav manager. Ignored if
     * `navToNavGuidance` is undefined.
     */
    navToNavOptions?: Readonly<GarminNavToNavManager2Options>;
    /** The minimum bank angle, in degrees, supported by the ROL director. Defaults to `6`. */
    rollMinBankAngle?: number;
    /** The maximum bank angle, in degrees, supported by the ROL director. Defaults to `25`. */
    rollMaxBankAngle?: number;
    /** The maximum bank angle, in degrees, supported by the HDG director. Defaults to `25`. */
    hdgMaxBankAngle?: number;
    /** The maximum bank angle, in degrees, supported by the VOR director. Defaults to `25`. */
    vorMaxBankAngle?: number;
    /** The maximum bank angle, in degrees, supported by the LOC director. Defaults to `25`. */
    locMaxBankAngle?: number;
    /** The maximum bank angle, in degrees, supported by the LNAV director. Defaults to `25`. */
    lnavMaxBankAngle?: number;
    /**
     * The maximum bank angle, in degrees, to apply to the HDG, VOR, LOC, and LNAV directors while in Low Bank Mode.
     * Defaults to `15`.
     */
    lowBankAngle?: number;
    /**
     * The target pitch angle, in degrees, commanded by the TO director. Positive values indicate upward pitch. Defaults
     * to `10`.
     */
    toPitchAngle?: number;
    /**
     * The target pitch angle, in degrees, commanded by the GA director. Positive values indicate upward pitch. Defaults
     * to `7.5`.
     */
    gaPitchAngle?: number;
    /**
     * The threshold difference between selected heading and current heading, in degrees, at which the heading director
     * unlocks its commanded turn direction and chooses a new optimal turn direction to establish on the selected
     * heading, potentially resulting in a turn reversal. Any value less than or equal to 180 degrees effectively
     * prevents the director from locking a commanded turn direction. Any value greater than or equal to 360 degrees will
     * require the selected heading to traverse past the current heading in the desired turn direction in order for the
     * director to issue a turn reversal. Defaults to `331`.
     */
    hdgTurnReversalThreshold?: number;
    /** Whether to deactivate the autopilot when GA mode is armed in response to a TO/GA mode button press. Defaults to `true`. */
    deactivateAutopilotOnGa?: boolean;
};
/**
 * A Garmin Autopilot Configuration.
 */
declare class GarminAPConfig implements GarminAPConfigInterface {
    private readonly bus;
    /** The default commanded pitch angle rate, in degrees per second. */
    static readonly DEFAULT_PITCH_RATE = 5;
    /** The default commanded bank angle rate, in degrees per second. */
    static readonly DEFAULT_BANK_RATE = 10;
    /** The default minimum bank angle, in degrees, for ROL director. */
    static readonly DEFAULT_ROLL_MIN_BANK_ANGLE = 6;
    /** The default maximum bank angle, in degrees, for ROL, HDG, NAV, and LNAV directors. */
    static readonly DEFAULT_MAX_BANK_ANGLE = 25;
    /** The default maximum bank angle, in degrees, in Low Bank Mode. */
    static readonly DEFAULT_LOW_BANK_ANGLE = 15;
    /** The default target pitch angle, in degrees, commanded by the TO director. Positive values indicate upward pitch. */
    static readonly DEFAULT_TO_PITCH_ANGLE = 10;
    /** The default target pitch angle, in degrees, commanded by the GA director. Positive values indicate upward pitch. */
    static readonly DEFAULT_GA_PITCH_ANGLE = 7.5;
    /** The default HDG director turn direction unlock threshold, in degrees. */
    static readonly DEFAULT_HDG_DIRECTION_UNLOCK_THRESHOLD = 331;
    defaultLateralMode: APLateralModes;
    defaultVerticalMode: APVerticalModes;
    defaultMaxBankAngle: number;
    /** @inheritDoc */
    readonly cdiId: string;
    /** @inheritDoc */
    readonly deactivateAutopilotOnGa: boolean;
    autopilotDriverOptions: AutopilotDriverOptions;
    /**
     * Whether the autopilot should use mach number calculated from the impact pressure derived from indicated airspeed
     * and ambient pressure instead of the true mach number.
     */
    readonly useIndicatedMach: boolean;
    /** Options for the LNAV director. */
    private readonly lnavOptions?;
    private readonly rollMinBankAngle;
    private readonly rollMaxBankAngle;
    private readonly hdgMaxBankAngle;
    private readonly vorMaxBankAngle;
    private readonly locMaxBankAngle;
    private readonly lnavMaxBankAngle;
    private readonly lowBankAngle;
    private readonly toPitchAngle;
    private readonly gaPitchAngle;
    private readonly hdgTurnReversalThreshold;
    private vnavManager?;
    private readonly internalVNavComputer?;
    private readonly internalGlidepathComputer?;
    private readonly vnavGuidance?;
    private readonly defaultVerticalPathGuidance;
    private readonly verticalPathGuidance;
    private readonly defaultGlidepathGuidance;
    private readonly glidepathGuidance;
    private readonly navToNavGuidance?;
    private readonly navToNavOptions?;
    /**
     * Creates a new instance of GarminAPConfig.
     * @param bus The event bus.
     * @param options Options to configure the directors.
     */
    constructor(bus: EventBus, options?: Readonly<GarminAPConfigOptions>);
    /** @inheritDoc */
    createLateralDirectors(apValues: APValues): Iterable<Readonly<APConfigDirectorEntry>>;
    /** @inheritDoc */
    createVerticalDirectors(apValues: APValues): Iterable<Readonly<APConfigDirectorEntry>>;
    /**
     * Creates the autopilot's roll mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's roll mode director, or `undefined` to omit the director.
     */
    protected createRollDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's wing level mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's wing level mode director, or `undefined` to omit the director.
     */
    protected createWingLevelerDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's heading mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's heading mode director, or `undefined` to omit the director.
     */
    protected createHeadingDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's track mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's track mode director, or `undefined` to omit the director.
     */
    protected createTrackDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's GPSS mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's GPSS mode director, or `undefined` to omit the director.
     */
    protected createGpssDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's VOR mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's VOR mode director, or `undefined` to omit the director.
     */
    protected createVorDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's localizer mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's localizer mode director, or `undefined` to omit the director.
     */
    protected createLocDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's localizer backcourse mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's localizer backcourse mode director, or `undefined` to omit the director.
     */
    protected createBcDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's takeoff lateral mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's takeoff lateral mode director, or `undefined` to omit the director.
     */
    protected createToLateralDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's go-around lateral mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's go-around lateral mode director, or `undefined` to omit the director.
     */
    protected createGaLateralDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's pitch mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's pitch mode director, or `undefined` to omit the director.
     */
    protected createPitchDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's pitch level mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's pitch level mode director, or `undefined` to omit the director.
     */
    protected createPitchLevelerDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's vertical speed mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's vertical speed mode director, or `undefined` to omit the director.
     */
    protected createVsDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's flight level change mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's flight level change mode director, or `undefined` to omit the director.
     */
    protected createFlcDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's altitude hold mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's altitude hold mode director, or `undefined` to omit the director.
     */
    protected createAltHoldDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's altitude capture mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's altitude capture mode director, or `undefined` to omit the director.
     */
    protected createAltCapDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's VNAV path mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's VNAV path mode director, or `undefined` to omit the director.
     */
    protected createVNavPathDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's glidepath mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's glidepath mode director, or `undefined` to omit the director.
     */
    protected createGpDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's glideslope mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's glideslope mode director, or `undefined` to omit the director.
     */
    protected createGsDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's takeoff vertical mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's takeoff vertical mode director, or `undefined` to omit the director.
     */
    protected createToVerticalDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's go-around vertical mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's go-around vertical mode director, or `undefined` to omit the director.
     */
    protected createGaVerticalDirector(apValues: APValues): PlaneDirector | undefined;
    /** @inheritDoc */
    createVNavManager(apValues: APValues): VNavManager | undefined;
    /** @inheritDoc */
    createNavToNavManager(apValues: APValues): NavToNavManager2 | undefined;
}

/**
 * A Garmin autopilot state manager.
 */
declare class GarminAPStateManager extends APStateManager {
    private vsLastPressed;
    /** @inheritDoc */
    protected onAPListenerRegistered(): void;
    /** @inheritDoc */
    protected setupKeyIntercepts(manager: KeyEventManager): void;
    /** @inheritDoc */
    protected handleKeyIntercepted({ key, value0 }: KeyEventData): void;
    /** @inheritDoc */
    protected onBeforeInitialize(): void;
    /** @inheritDoc */
    protected initFlightDirector(): void;
}

/**
 * A utility class for working with Garmin autopilots.
 */
declare class GarminAPUtils {
    /**
     * Checks whether a GPSS director can be activated from an armed state.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param state State provided by the director for use in determing whether the director can be activated.
     * @returns Whether the director can be activated from an armed state.
     */
    static gpssCanActivate(apValues: APValues, state: Readonly<APGpsSteerDirectorState>): boolean;
    /**
     * Checks whether a nav director can be armed.
     * @param mode The director's lateral mode.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param navData The current radio navigation data received by the director.
     * @returns Whether the director can be armed.
     */
    static navCanArm(mode: APLateralModes, apValues: APValues, navData: Readonly<APNavDirectorNavData>): boolean;
    /**
     * Checks whether a nav director can be activated from an armed state.
     * @param mode The director's lateral mode.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param navData The current radio navigation data received by the director.
     * @returns Whether the director can be activated from an armed state.
     */
    static navCanActivate(mode: APLateralModes, apValues: APValues, navData: Readonly<APNavDirectorNavData>): boolean;
    /**
     * Checks whether a nav director can remain in the active state.
     * @param mode The director's lateral mode.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param navData The current radio navigation data received by the director.
     * @param isInZoneOfConfusion Whether the source of the radio navigation data is a VOR and the airplane's position
     * is close enough to the VOR to render lateral deviation values unreliable.
     * @param activateNavData The radio navigation data received by the director at the moment of activation.
     * @returns Whether the director can remain in the active state.
     */
    static navCanRemainActive(mode: APLateralModes, apValues: APValues, navData: Readonly<APNavDirectorNavData>, isInZoneOfConfusion: boolean, activateNavData: Readonly<APNavDirectorActivateNavData>): boolean;
    /**
     * Checks whether a localizer back-course director can be armed.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param navData The current radio navigation data received by the director.
     * @returns Whether the director can be armed.
     */
    static backCourseCanArm(apValues: APValues, navData: Readonly<APBackCourseDirectorNavData>): boolean;
    /**
     * Checks whether a localizer back-course director can be activated from an armed state.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param navData The current radio navigation data received by the director.
     * @returns Whether the director can be activated from an armed state.
     */
    static backCourseCanActivate(apValues: APValues, navData: Readonly<APBackCourseDirectorNavData>): boolean;
    /**
     * Checks whether a localizer back-course director can remain in the active state.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param navData The current radio navigation data received by the director.
     * @param activateNavData The radio navigation data received by the director at the moment of activation.
     * @returns Whether the director can remain in the active state.
     */
    static backCourseCanRemainActive(apValues: APValues, navData: Readonly<APBackCourseDirectorNavData>, activateNavData: Readonly<APBackCourseDirectorActivateNavData>): boolean;
    /**
     * Checks whether a glideslope director can be armed.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param navData The current radio navigation data received by the director.
     * @returns Whether the director can be armed.
     */
    static glideslopeCanArm(apValues: APValues, navData: Readonly<APGSDirectorNavData>): boolean;
    /**
     * Checks whether a glideslope director can be activated from an armed state.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param navData The current radio navigation data received by the director.
     * @returns Whether the director can be activated from an armed state.
     */
    static glideslopeCanActivate(apValues: APValues, navData: Readonly<APGSDirectorNavData>): boolean;
    /**
     * Checks whether a glideslope director can remain in the active state.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @param navData The current radio navigation data received by the director.
     * @param activateNavData The radio navigation data received by the director at the moment of activation.
     * @returns Whether the director can remain in the active state.
     */
    static glideslopeCanRemainActive(apValues: APValues, navData: Readonly<APGSDirectorNavData>, activateNavData: Readonly<APGSDirectorActivateNavData>): boolean;
    /**
     * Checks whether a glidepath director can be armed.
     * @param apValues Autopilot values from the director's parent autopilot.
     * @returns Whether the director can be armed.
     */
    static glidepathCanArm(apValues: APValues): boolean;
    /**
     * Calculates intercept angles for radio nav.
     * @param distanceToSource The distance from the plane to the source of the navigation signal, in nautical miles.
     * @param deflection The lateral deflection of the desired track relative to the plane, normalized from `-1` to `1`.
     * Positive values indicate that the desired track is to the right of the plane.
     * @param xtk The cross-track error of the plane from the desired track, in nautical miles. Positive values indicate
     * indicate that the plane is to the right of the track.
     * @param tas The true airspeed of the plane, in knots.
     * @param isLoc Whether the source of the navigation signal is a localizer. Defaults to `false`.
     * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
     */
    static navIntercept(distanceToSource: number, deflection: number, xtk: number, tas: number, isLoc: boolean): number;
    /**
     * Calculates intercept angles for LNAV.
     * @param dtk The desired track, in degrees true.
     * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
     * desired track.
     * @param tas The true airspeed of the plane, in knots.
     * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
     */
    static lnavIntercept(dtk: number, xtk: number, tas: number): number;
    /**
     * Calculates intercept angles for localizers.
     * @param xtk The cross-track error of the plane from the desired track, in nautical miles. Positive values indicate
     * indicate that the plane is to the right of the track.
     * @param tas The true airspeed of the plane, in knots.
     * @returns The intercept angle, in degrees, to capture the localizer course.
     */
    static localizerIntercept(xtk: number, tas: number): number;
    /**
     * Calculates non-localizer intercept angles.
     * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
     * desired track.
     * @param tas The true airspeed of the plane, in knots.
     * @returns The intercept angle, in degrees, to capture the desired track.
     */
    private static defaultIntercept;
    /**
     * Calculates an intercept angle to a track such that the intercept course, projected forward from the plane's
     * position, intercepts the desired track at the same point as a constant-radius turn overlapping the plane's
     * position configured to be tangent to the desired track. This has the effect of producing an intercept angle which
     * guarantees a no-overshoot intercept for all initial ground tracks for which a no-overshoot intercept is possible
     * given the specified turn radius and cross-track error.
     *
     * If the magnitude of the cross-track error is greater than twice the turn radius, no constant-radius turn
     * overlapping the plane's position will be tangent to the desired track; in this case the maximum possible intercept
     * angle of 90 degrees is returned.
     * @param turnRadius The turn radius, in the same units as `xtk`.
     * @param xtk The cross-track error, in the same units as `turnRadius`.
     * @returns The calculated intercept angle, in degrees.
     */
    private static calculateTurnBasedInterceptAngle;
}

/**
 * A data provider for a minimums display.
 */
interface MinimumsDataProvider {
    /** The current minimums mode. */
    readonly mode: Subscribable<MinimumsMode>;
    /** The current active minimums, in feet, or `null` if no such value exists. */
    readonly minimums: Subscribable<number | null>;
    /** The current baro minimums, in feet. */
    readonly baroMinimums: Subscribable<number>;
    /** The current radar minimums, in feet. */
    readonly radarMinimums: Subscribable<number>;
}
/**
 * A default implementation of {@link MinimumsDataProvider}.
 */
declare class DefaultMinimumsDataProvider implements MinimumsDataProvider {
    private readonly bus;
    private readonly supportRadarMinimums;
    private readonly _mode;
    readonly mode: Subscribable<MinimumsMode>;
    private readonly _minimums;
    /** @inheritdoc */
    readonly minimums: Subscribable<number | null>;
    private readonly baroMinimumsSource;
    /** @inheritdoc */
    readonly baroMinimums: Subscribable<number>;
    private readonly radarMinimumsSource;
    /** @inheritdoc */
    readonly radarMinimums: Subscribable<number>;
    private isInit;
    private isAlive;
    private isPaused;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param supportRadarMinimums Whether to support radar minimums.
     */
    constructor(bus: EventBus, supportRadarMinimums: boolean);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Options with which to configure a {@link GarminAutopilot}.
 */
type GarminAutopilotOptions = {
    /**
     * Options for the autopilot's altitude select manager. The following default options will be applied if they are not
     * explicitly provided:
     * ```
     * supportMetric: true,
     * minValue: UnitType.FOOT.createNumber(-1000),
     * maxValue: UnitType.FOOT.createNumber(50000),
     * inputIncrLargeThreshold: 999,
     * incrSmall: UnitType.FOOT.createNumber(100),
     * incrLarge: UnitType.FOOT.createNumber(1000),
     * incrSmallMetric: UnitType.METER.createNumber(50),
     * incrLargeMetric: UnitType.METER.createNumber(500),
     * initOnInput: true,
     * initToIndicatedAlt: true,
     * transformSetToIncDec: false
     * ```
     */
    altSelectOptions?: Readonly<Partial<AltitudeSelectManagerOptions>>;
    /**
     * A manager of metric altitude mode user settings. Required for the autopilot's altitude select manager to support
     * metric mode.
     */
    metricAltSettingsManager?: MetricAltitudeSettingsManager;
    /**
     * A provider of minimums data. If defined, the autopilot's altitude select manager will add an additional selected
     * altitude stop at the baro minimums altitude if one is set.
     */
    minimumsDataProvider?: MinimumsDataProvider;
    /** Whether to support mach number as the selected airspeed reference. Defaults to `false`. */
    supportMachSelect?: boolean;
};
/**
 * A Garmin autopilot.
 */
declare class GarminAutopilot extends Autopilot<GarminAPConfigInterface> {
    protected static readonly ALT_SELECT_OPTIONS_DEFAULT: AltitudeSelectManagerOptions;
    protected readonly resetAltSelectInitialization: boolean;
    protected readonly altSelectStops: SetSubject<number>;
    protected readonly altSelectManager: AltitudeSelectManager;
    protected readonly isAltSelectInitialized: ConsumerValue<boolean>;
    protected readonly fmaData: ObjectSubject<FmaData>;
    protected readonly fmaDataPublisher: _microsoft_msfs_sdk.Publisher<FmaDataEvents>;
    protected needPublishFmaData: boolean;
    protected readonly machToKias: ConsumerValue<number>;
    protected readonly selSpeedIsMach: ConsumerSubject<boolean>;
    protected readonly supportMachSelect: boolean;
    protected readonly isNavModeOn: Subject<boolean>;
    protected readonly isApproachModeOn: Subject<boolean>;
    /**
     * Creates a new instance of GarminAutopilot.
     * @param bus The event bus.
     * @param flightPlanner This autopilot's associated flight planner.
     * @param config This autopilot's configuration.
     * @param stateManager This autopilot's state manager.
     * @param options Options with which to configure the new autopilot.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, config: GarminAPConfigInterface, stateManager: APStateManager, options?: Readonly<GarminAutopilotOptions>);
    /**
     * Sets the initialized state of this autopilot's selected altitude.
     * @param initialized The state to set.
     */
    setSelectedAltitudeInitialized(initialized: boolean): void;
    /**
     * Resets this autopilot. Resets the altitude preselector, sets AP MASTER to off, and deactivates the flight
     * director.
     */
    reset(): void;
    /** @inheritDoc */
    protected initVerticalModeDirector(mode: number, director: PlaneDirector, setPitch?: (pitch: number, resetServo?: boolean, maxNoseDownPitch?: number, maxNoseUpPitch?: number) => void, drivePitch?: (pitch: number, adjustForAoa?: boolean, adjustForVerticalWind?: boolean, rate?: number, maxNoseDownPitch?: number, maxNoseUpPitch?: number) => void): void;
    /**
     * Monitors Garmin autopilot-specific events.
     */
    protected monitorGarminEvents(): void;
    /** @inheritDoc */
    protected onInitialized(): void;
    /** @inheritDoc */
    protected monitorAdditionalEvents(): void;
    /**
     * Checks and sets the proper armed altitude mode.
     */
    protected manageAltitudeCapture(): void;
    /** @inheritDoc */
    protected onAfterUpdate(): void;
    /**
     * Updates this autopilot's NAV mode state.
     */
    protected updateNavModeState(): void;
    /**
     * Updates this autopilot's approach mode state.
     */
    protected updateApproachModeState(): void;
    /**
     * Publishes data for the FMA.
     */
    protected updateFma(): void;
    /** @inheritDoc */
    protected lateralPressed(data: APModePressEvent): void;
    /**
     * Handles input from the State Manager when a vertical mode button is pressed.
     * @param data is the AP Vertical Mode Event Data
     */
    protected verticalPressed(data: APModePressEvent): void;
    /** @inheritDoc */
    protected approachPressed(set?: boolean): void;
    /**
     * Activates approach mode. Activating approach mode will arm lateral and vertical modes based on the current CDI
     * source and nav-to-nav guidance.
     */
    protected activateApproachMode(): void;
    /**
     * Arms lateral and vertical approach modes. The vertical mode will only be armed if the lateral mode is successfully
     * armed.
     * @param lateralMode The lateral mode to arm.
     * @param verticalMode The vertical mode to arm.
     */
    protected armModesForApproach(lateralMode: APLateralModes, verticalMode: APVerticalModes): void;
    /**
     * Deactivates approach mode. Deactivating approach mode will deactivate any armed or active lateral and vertical
     * approach modes.
     * @param preserveLateralMode Whether to preserve armed or active lateral modes. If true, then any armed or active
     * lateral approach mode that is deactivated will be replaced with its non-approach counterpart, if one exists.
     */
    protected deactivateApproachMode(preserveLateralMode: boolean): void;
    /**
     * Reconciles the nominal approach mode state with the state of this autopilot's directors.
     */
    protected reconcileApproachState(): void;
    /** @inheritDoc */
    protected checkModes(): void;
}

/**
 * Configuration options for {@link GarminGoAroundManager}.
 */
type GarminGoAroundManagerOptions = {
    /** The ID of the CDI controlled by the manager. Defaults to the empty string (`''`). */
    cdiId?: string | Subscribable<string>;
};
/**
 * A manager which responds to autopilot go-around mode activation by attempting to switch the active navigation
 * soruce to GPS and activate the missed approach.
 */
declare class GarminGoAroundManager {
    private readonly bus;
    private readonly fms;
    private isLNavIndexValid;
    private readonly cdiId;
    private isGaActive?;
    private readonly isLNavTracking;
    private readonly activeNavSource;
    private readonly gpsSelectedDebounceTimer;
    private readonly gpsSelectedCallback;
    private isInit;
    private isAlive;
    private isPaused;
    private fmsSub?;
    private cdiIdSub?;
    private fmaDataSub?;
    private activeNavSourceSub?;
    /**
     * Creates a new instance of GarminGoAroundManager.
     * @param bus The event bus.
     * @param fms The FMS.
     * @param options Options with which to configure the manager.
     */
    constructor(bus: EventBus, fms: Fms | Subscribable<Fms>, options?: Readonly<GarminGoAroundManagerOptions>);
    /**
     * Initializes this manager. Once initialized, this manager will automatically attempt to switch the active
     * navigation source to GPS and activate the missed approach and when autopilot go-around mode is activated.
     * @param paused Whether to initialize this manager as paused. Defaults to `false`.
     * @throws Error if this manager has been destroyed.
     */
    init(paused?: boolean): void;
    /**
     * Responds to when go-around mode has been activated. This will switch the active navigation source to GPS and the
     * autopilot lateral mode to NAV (GPS/FMS) if an approach is loaded and LNAV guidance is available. Additionally,
     * this will activate the missed approach if such an action is possible.
     */
    private onGaActivated;
    /**
     * Responds to when GPS has been selected as the active navigation source after go-around mode has been activated.
     */
    private onGpsNavSourceSelected;
    /**
     * Resumes this manager. Once resumed, this manager will automatically attempt to switch the active navigation source
     * to GPS and activate the missed approach and when autopilot go-around mode is activated.
     * @throws Error if this manager has been destroyed.
     */
    resume(): void;
    /**
     * Pauses this manager. Once paused, this data provider will not respond to go-around mode activations until it is
     * resumed.
     * @throws Error if this manager has been destroyed.
     */
    pause(): void;
    /**
     * Destroys this manager. Once destroyed, this manager will cease responding to go-around mode activations, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Options for {@link GarminHeadingSyncManager}.
 */
type GarminHeadingSyncManagerOptions = {
    /**
     * Whether to support automatic selected heading adjustment after receiving a heading sync event while HDG mode is
     * active and the aircraft is banked. Defaults to `false`.
     */
    supportTurnHeadingAdjust?: boolean;
    /**
     * Whether to support toggling HDG sync mode after receiving a heading sync event while a NAV mode is active.
     * Defaults to `false`.
     */
    supportHeadingSyncMode?: boolean;
    /**
     * The bank threshold, in degrees, below which the manager will not automatically adjust selected heading after
     * receiving a heading sync event while HDG mode is active. Ignored if `supportTurnHeadingAdjust` is `false`.
     * Defaults to 6 degrees.
     */
    turnHeadingAdjustBankThreshold?: number;
    /** The H event to map to heading sync events. Defaults to `Garmin_AP_HDG_Sync`. */
    headingSyncHEvent?: string;
};
/**
 * A manager which handles heading sync events for the Garmin autopilot. The manager syncs the autopilot's selected
 * heading to current heading in response to heading sync H events. In addition, the manager has option support for
 * automatic adjustment of selected heading during turns while HDG mode is active and for heading sync mode while an
 * autopilot NAV mode is active.
 */
declare class GarminHeadingSyncManager {
    private readonly bus;
    private static readonly AP_NAV_MODES;
    private static readonly DEFAULT_TURN_HDG_ADJUST_BANK_THRESHOLD;
    private static readonly DEFAULT_HDG_SYNC_H_EVENT;
    private readonly publisher;
    private keyEventManager?;
    private readonly supportTurnHeadingAdjust;
    private readonly supportHeadingSyncMode;
    private readonly turnHeadingAdjustBankThreshold;
    private readonly headingSyncHEvent;
    private readonly apFmaData;
    private readonly isApHdgModeActive;
    private readonly isApNavModeActive;
    private readonly ahrsIndex;
    private readonly isAttitudeDataValid;
    private readonly isHeadingDataValid;
    private readonly bank;
    private readonly heading;
    private lastSetHeadingValue;
    private isTurnHeadingAdjustActive;
    private isHeadingSyncModeActive;
    private isAlive;
    private isInit;
    private isPaused;
    private readonly keyEventManagerReadyPromise;
    private keyEventManagerReadyPromiseReject?;
    private keyEventSub?;
    private hEventSub?;
    private ahrsIndexSub?;
    private updateSub?;
    /**
     * Creates a new instance of GarminHeadingSyncManager. The new manager is created uninitialized and paused.
     * @param bus The event bus.
     * @param ahrsIndex The index of the AHRS used by the autopilot.
     * @param options Options with which to configure the manager.
     */
    constructor(bus: EventBus, ahrsIndex: number | Subscribable<number>, options?: Readonly<GarminHeadingSyncManagerOptions>);
    /**
     * Waits for this manager's key event manager to be ready.
     * @returns A Promise which will be fulfilled when this manager's key event manager is ready, or rejected if this
     * manager is destroyed before then.
     */
    private awaitKeyEventManagerReady;
    /**
     * Initializes this manager. Once this manager is initialized, it will automatically adjust the autopilot's selected
     * heading in response to heading sync H events and whether turn heading adjustment or heading sync mode are active.
     * @throws Error if this manager has been destroyed.
     */
    init(): Promise<void>;
    /**
     * Resumes this manager. Once resumed, this manager will automatically adjust the autopilot's selected heading in
     * response to heading sync H events and whether turn heading adjustment or heading sync mode are active.
     * @throws Error if this manager has been destroyed.
     */
    resume(): void;
    /**
     * Pauses this manager. Once paused, this manager will no longer automatically adjust the autopilot's selected
     * heading.
     * @throws Error if this manager has been destroyed.
     */
    pause(): void;
    /**
     * Resets this manager. Deactivates both turn heading adjustment and heading sync mode if they were active.
     */
    reset(): void;
    /**
     * Responds to a key event intercept.
     * @param data Data describing the intercepted key event.
     */
    private onKeyIntercepted;
    /**
     * Responds to when an H event is triggered.
     * @param hEvent The triggered H event.
     */
    private onHEvent;
    /**
     * Sets the autopilot's selected heading, in degrees.
     * @param heading The selected heading to set, in degrees.
     */
    private setSelectedHeading;
    /**
     * Checks whether turn heading adjustment can be activated.
     * @returns Whether turn heading adjustment  can be activated.
     */
    private canActivateTurnHeadingAdjust;
    /**
     * Checks whether heading sync mode can be activated.
     * @returns Whether heading sync mode can be activated.
     */
    private canActivateHeadingSyncMode;
    /**
     * Sets whether turn heading adjustment is active. This method will not activate turn heading adjustment if current
     * conditions do not allow for its activation. If this manager does not support turn heading adjustment, then this
     * method does nothing.
     * @param active Whether to activate turn heading adjustment.
     */
    private setTurnHeadingAdjustActive;
    /**
     * Sets whether heading sync mode is active. This method will not activate heading sync mode if current conditions do
     * not allow for its activation. If this manager does not support heading sync mode, then this method does nothing.
     * @param active Whether to activate heading sync mode.
     */
    private setHeadingSyncModeActive;
    /**
     * Updates this manager.
     */
    private update;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * Configuration options for {@link GarminLowBankManager}.
 */
type GarminLowBankManagerOptions = {
    /**
     * The indicated altitude threshold, in feet, for automatic activation of low-bank mode. If defined and auto-toggle
     * is supported, then this manager will automatically activate low-bank mode when the airplane climbs from below to
     * above this altitude.
     */
    activateAltitude?: number;
    /**
     * The indicated altitude threshold, in feet, for automatic deactivation of low-bank mode. If defined and auto-toggle
     * is supported, then this manager will automatically deactivate low-bank mode when the airplane descends from above
     * to below this altitude.
     */
    deactivateAltitude?: number;
    /**
     * An iterable of ADC system indexes from which the manager can source indicated altitude data. Required for
     * auto-toggle behavior. The manager will source data from the first ADC system (in the order returned by the
     * iterable) whose state is equal to `AvionicsSystemState.On`.
     */
    supportedAdcIndexes?: Iterable<number>;
    /**
     * The bank angle, in degrees, above which auto-toggle is inhibited. If this value is less than or equal to zero,
     * then bank angle will not affect whether auto-toggle is inhibited. Defaults to `0`.
     */
    autoToggleBankLimit?: number;
    /**
     * An iterable of AHRS system indexes from which the manager can source bank angle data. Required for auto-toggle
     * behavior to be limited by aircraft bank. The manager will source data from the first AHRS system (in the order
     * returned by the iterable) whose state is equal to `AvionicsSystemState.On`.
     */
    supportedAhrsIndexes?: Iterable<number>;
    /**
     * Whether the manager should enforce the Low Bank Mode state requested by auto-toggle logic. If auto-toggle is
     * enforced, then Low Bank Mode will be forced to be active when the airplane is above the automatic activation
     * altitude and inactive when the airplane is below the automatic deactivation altitude.
     */
    enforceAutoToggle?: boolean;
};
/**
 * A manager which handles activation and deactivation of Low Bank Mode for Garmin autopilots. The manager ensures that
 * Low Bank Mode is active only when supported by the autopilot's active lateral mode. Optionally, it will also
 * automatically toggle Low Bank Mode in response to changes in indicated altitude.
 */
declare class GarminLowBankManager {
    private readonly bus;
    private static readonly LOW_BANK_SUPPORTED_MODES;
    private keyEventManager?;
    private readonly keyEventManagerPromise;
    private keyEventManagerPromiseReject?;
    private readonly activateAltitude?;
    private readonly deactivateAltitude?;
    private readonly autoToggleBankLimit;
    private readonly enforceAutoToggle?;
    private readonly apFmaData;
    private readonly isLowBankSupported;
    private readonly apMaxBankId;
    private readonly adcIndexes;
    private readonly adcStates;
    private adcIndex?;
    private readonly ahrsIndexes;
    private readonly ahrsStates;
    private ahrsIndex?;
    private readonly indicatedAlt;
    private readonly bank;
    private readonly isAutoToggleInhibitedByBank;
    private isActivateArmed;
    private isDeactivateArmed;
    private readonly isLowBankActiveDesired;
    private isAlive;
    private isInit;
    private isAutoTogglePaused;
    private keyEventSub?;
    private altitudeSub?;
    private enforceSub?;
    private canEnforceSub?;
    /**
     * Creates a new instance of GarminLowBankManager. The new manager is created as uninitialized and with auto-toggle
     * paused.
     * @param bus The event bus.
     * @param options Options with which to configure the manager.
     * @throws Error if `options.activateAltitude` is less than `options.deactivateAltitude`.
     */
    constructor(bus: EventBus, options?: Readonly<GarminLowBankManagerOptions>);
    /**
     * Creates a new instance of GarminLowBankManager. The new manager is created as uninitialized and with auto-toggle
     * paused.
     * @param bus The event bus.
     * @param activateAltitude The indicated altitude threshold, in feet, for automatic activation of low-bank mode. If
     * defined and auto-toggle is supported, this manager will automatically activate low-bank mode when the airplane
     * climbs from below to above this altitude.
     * @param deactivateAltitude The indicated altitude threshold, in feet, for automatic deactivation of low-bank mode.
     * If defined and auto-toggle is supported, this manager will automatically deactivate low-bank mode when the
     * airplane descends from above to below this altitude.
     * @param supportedAdcIndexes An iterable of ADC system indexes from which the manager can source indicated altitude
     * data. Required for auto-toggle behavior. The manager will source data from the first ADC system (in the order
     * returned by the iterable) whose state is equal to `AvionicsSystemState.On`.
     * @param autoToggleBankLimit The bank angle, in degrees, above which auto-toggle is inhibited. If this value is less
     * than or equal to zero, then bank angle will not affect whether auto-toggle is inhibited. Defaults to `0`.
     * @param supportedAhrsIndexes An iterable of AHRS system indexes from which the manager can source bank angle data.
     * Required for auto-toggle behavior to be limited by aircraft bank. The manager will source data from the first AHRS
     * system (in the order returned by the iterable) whose state is equal to `AvionicsSystemState.On`.
     * @throws Error if `activateAltitude` is less than `deactivateAltitude`.
     */
    constructor(bus: EventBus, activateAltitude?: number, deactivateAltitude?: number, supportedAdcIndexes?: Iterable<number>, autoToggleBankLimit?: number, supportedAhrsIndexes?: Iterable<number>);
    /**
     * Creates a Promise that is fulfilled when the key event manager has been retrieved.
     */
    private createKeyEventManagerPromise;
    /**
     * Initializes this manager. Once this manager is initialized, it will ensure that Low Bank Mode is active only when
     * it is supported by the autopilot's active lateral mode. Additionally, it will automatically toggle Low Bank Mode
     * in response to changes in indicated altitude if the function is supported and resumed.
     * @throws Error if this manager has been destroyed.
     */
    init(): Promise<void>;
    /**
     * Resumes this manager's auto-toggle behavior. Once resumed, this manager will automatically activate/deactivate
     * Low Bank Mode based on changes in indicated altitude. If this manager has not been initialized, auto-toggle
     * behavior will begin when initialization is complete.
     * @throws Error if this manager has been destroyed.
     */
    resumeAutoToggle(): void;
    /**
     * Pauses this manager's auto-toggle behavior. Once paused, this manager will no longer automatically
     * activate/deactivate Low Bank Mode until auto-toggle is resumed.
     * @throws Error if this manager has been destroyed.
     */
    pauseAutoToggle(): void;
    /**
     * Sets the active state of Low Bank Mode. This method does not activate Low Bank Mode when it is not supported by
     * the current lateral flight director mode. This method does nothing if this manager enforces auto-toggle and
     * auto-toggle is resumed.
     * @param active Whether to activate Low Bank Mode.
     */
    setLowBankActive(active: boolean): void;
    /**
     * Sets the active state of Low Bank Mode.
     * @param active Whether to activate Low Bank Mode.
     */
    private _setLowBankActive;
    /**
     * Responds to when Low Bank Mode support changes.
     * @param isLowBankSupported Whether Low Bank Mode is supported.
     */
    private onLowBankSupportedChanged;
    /**
     * Responds to when the indicated altitude changes and auto-toggle is not enforced.
     * @param altitude The indicated altitude, in feet.
     */
    private onAltitudeChanged;
    /**
     * Responds to when the indicated altitude changes and auto-toggle is enforced.
     * @param altitude The indicated altitude, in feet.
     */
    private onAltitudeChangedEnforce;
    /**
     * Responds to when the state of auto-toggle enforcement changes.
     * @param state The new state of auto-toggle enforcement, as `[id, desired]`, where `id` is the current autopilot
     * max bank ID and `desired` is whether Low Bank Mode should be active.
     */
    private onEnforceStateChanged;
    /**
     * Responds to when whether this manager can enforce auto-toggle changes.
     * @param canEnforce Whether this manager can enforce auto-toggle.
     */
    private onCanEnforceChanged;
    /**
     * Handles a key event intercept.
     * @param data Data describing the intercepted key event.
     */
    private onKeyIntercepted;
    /**
     * Destroys this manager.
     */
    destroy(): void;
    /**
     * Selects the index of the first system in an array whose state is equal to `AvionicsSystemState.On`.
     * @param indexes The indexes of the systems from which to select.
     * @param states The states of the systems from which to select.
     * @returns The index of the first system in the specified array whose state is equal to `AvionicsSystemState.On`.
     */
    private static selectSystemIndex;
}

/**
 * A item containing a speed constraint from a flight plan and associated metadata.
 */
type SpeedConstraintListItem = {
    /** This item's speed constraint. */
    speedConstraint: Readonly<SpeedConstraint>;
    /** The global index of the flight plan leg associated with this item's speed constraint. */
    globalLegIndex: number;
    /** The vertical flight phase of this item's speed constraint. */
    flightPhase: VerticalFlightPhase;
    /** Whether this item's speed constraint is part of a missed approach procedure. */
    isMissedApproach: boolean;
};
/**
 * A store which keeps track of the speed constraints in the active flight plan.
 */
declare class GarminSpeedConstraintStore {
    private bus;
    private flightPlanner;
    private readonly speedConstraints;
    private activePlanIndex;
    private planChanged;
    private readonly iterator;
    /**
     * Creates the store.
     * @param bus The Event Bus.
     * @param flightPlanner The Flight Planner.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner);
    /**
     * Sets the planChanged flag if the plan change is for the active plan index.
     * @param planIndex The plan index from the event.
     */
    private onPlanChanged;
    private onPlanIndexChanged;
    private onPlanCalculated;
    /**
     * Gets the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @returns The speed constraint in effect for the specified flight plan leg and vertical flight phase, or
     * `undefined` if there is no speed constraint in effect.
     */
    getCurrentSpeedConstraint(globalLegIndex: number, flightPhase: VerticalFlightPhase): Readonly<SpeedConstraintListItem> | undefined;
    /**
     * Gets the next speed constraint to take effect for a given flight plan leg and vertical flight phase.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @returns The next speed constraint to take effect for the specified flight plan leg and vertical flight phase,
     * or `undefined` if there is no speed constraint in effect.
     */
    getNextSpeedConstraint(globalLegIndex: number, flightPhase: VerticalFlightPhase): Readonly<SpeedConstraintListItem> | undefined;
    /**
     * Gets the index of the speed constraint in this store in effect for a given flight plan leg and vertical flight
     * phase.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @returns The index of the speed constraint in this store in effect for the specified flight plan leg and vertical
     * flight phase. If there is no speed constraint in effect, `-(i + 1)` is returned instead, where `i` is the index
     * at which the constraint would be located if it existed.
     */
    private getCurrentSpeedConstraintIndex;
}

/**
 * A calculator for providing the glidepath service level.
 */
declare class GlidepathServiceLevelCalculator {
    private readonly allowPlusVWithoutSbas;
    private readonly allowApproachBaroVNav;
    private readonly allowRnpAr;
    private readonly gpsSystemState;
    private readonly approachDetails;
    /**
     * Creates an instance of the GlidepathServiceLevelCalculator.
     * @param allowPlusVWithoutSbas Whether to allow +V approach service levels when no SBAS is present.
     * @param allowApproachBaroVNav Whether to allow approach service levels requiring baro VNAV.
     * @param allowRnpAr Whether to allow RNP (AR) approach service levels.
     * @param gpsSystemState The current GPS system state.
     * @param approachDetails The currently selected approach details.
     */
    constructor(allowPlusVWithoutSbas: boolean, allowApproachBaroVNav: boolean, allowRnpAr: boolean, gpsSystemState: Subscribable<GPSSystemState>, approachDetails: Subscribable<ApproachDetails>);
    /**
     * Gets the current glidepath service level from the calculator.
     * @returns The current glidepath service level.
     */
    getServiceLevel(): GlidepathServiceLevel;
    /**
     * Checks a service level to see if baro guidance is required.
     * @param serviceLevel The service level to check.
     * @returns True if baro guidance is required, false otherwise.
     */
    isBaroServiceLevel(serviceLevel: GlidepathServiceLevel): boolean;
    /**
     * Handles when the best RNAV service level type is RNP (AR).
     * @returns The calculated result glidepath service level.
     */
    private handleRnp;
    /**
     * Handles when the best RNAV service level type is LPV.
     * @returns The calculated result glidepath service level.
     */
    private handleLpv;
    /**
     * Handles when the best RNAV service level type is LP.
     * @returns The calculated result glidepath service level.
     */
    private handleLp;
    /**
     * Handles when the best RNAV service level type is LNAV/VNAV.
     * @returns The calculated result glidepath service level.
     */
    private handleLnavVnav;
    /**
     * Handles when the best RNAV service level type is LNAV.
     * @returns The calculated result glidepath service level.
     */
    private handleLnav;
    /**
     * Handles when the best RNAV service level type is Visual.
     * @returns The calculated result glidepath service level.
     */
    private handleVisual;
}

/**
 * A definition for a set of Garmin checklists.
 * @template S The metadata attached to the checklist set.
 * @template G The metadata attached to the checklist groups contained in the definition.
 * @template L The metadata attached to the checklist lists contained in the definition.
 * @template B The metadata attached to the checklist branches contained in the definition.
 */
type GarminChecklistSetDef<S = unknown, G = unknown, L = unknown, B = unknown> = ChecklistSetDef<GarminChecklistItemTypeDefMap, S, G, L, B>;
/**
 * Garmin checklist item text colors.
 */
declare enum GarminChecklistItemTextColor {
    White = "White",
    Silver = "Silver",
    Gray = "Gray",
    Navy = "Navy",
    Cyan = "Cyan",
    Lime = "Lime",
    Green = "Green",
    Yellow = "Yellow",
    Olive = "Olive",
    Red = "Red",
    Maroon = "Maroon",
    Magenta = "Magenta"
}
/**
 * A definition for a Garmin actionable checklist item.
 */
type GarminChecklistActionableItemDef = ChecklistActionableItemDef & {
    /** The indentation level of the item. */
    readonly indent: 1 | 2 | 3 | 4;
    /** The item's text color. */
    readonly textColor: GarminChecklistItemTextColor;
};
/**
 * A definition for a Garmin note checklist item.
 */
type GarminChecklistBranchItemDef = ChecklistBranchItemDef & {
    /** The unique ID of the item. */
    readonly uid?: string;
    /** Whether to omit the checkbox when rendering the item. */
    readonly omitCheckbox: boolean;
    /** The indentation level of the item. */
    readonly indent: 0 | 1 | 2 | 3 | 4;
    /** The item's text color. */
    readonly textColor: GarminChecklistItemTextColor;
};
/**
 *
 */
declare enum GarminChecklistLinkItemType {
    Normal = "Normal",
    BranchItem = "BranchItem"
}
/**
 * A definition for a normal Garmin link checklist item.
 */
type GarminChecklistNormalLinkItemDef = ChecklistLinkItemDef & {
    /** The link type of the item. */
    readonly linkType: GarminChecklistLinkItemType.Normal;
    /** The indentation level of the item. */
    readonly indent: 0 | 1 | 2 | 3 | 4;
    /** The item's text color. */
    readonly textColor: GarminChecklistItemTextColor;
    /** The item's text justification. */
    readonly justify: 'left' | 'center' | 'right';
};
/**
 * A definition for a Garmin link checklist item that targets a branch linked to a branch item.
 */
type GarminChecklistBranchItemLinkItemDef = ChecklistLinkItemDef & {
    /** The link type of the item. */
    readonly linkType: GarminChecklistLinkItemType.BranchItem;
    /** The unique ID of the item's parent branch item. */
    readonly branchItem: string;
    /** The index of the item's target branch in the parent branch item's branch array. */
    readonly linkIndex: number;
};
/**
 * A definition for a Garmin link checklist item.
 */
type GarminChecklistLinkItemDef = GarminChecklistNormalLinkItemDef | GarminChecklistBranchItemLinkItemDef;
/**
 * A definition for a Garmin note checklist item.
 */
type GarminChecklistNoteItemDef = ChecklistNoteItemDef & {
    /** The indentation level of the item. */
    readonly indent: 0 | 1 | 2 | 3 | 4;
    /** The item's text color. */
    readonly textColor: GarminChecklistItemTextColor;
    /** The item's text justification. */
    readonly justify: 'left' | 'center' | 'right';
};
/**
 * A definition for a Garmin title checklist item.
 */
type GarminChecklistTitleItemDef = ChecklistTitleItemDef & {
    /** The indentation level of the item. */
    readonly indent: 0 | 1 | 2 | 3 | 4;
    /** The item's text color. */
    readonly textColor: GarminChecklistItemTextColor;
};
/**
 * A definition for a Garmin spacer checklist item.
 */
type GarminChecklistSpacerItemDef = {
    /** The type of the item. */
    readonly type: ChecklistItemType.Spacer;
    /** The height of the item, as a multiple of the checklist's line height. */
    readonly height: number;
};
/**
 * A map from checklist item types to Garmin checklist item definitions.
 */
type GarminChecklistItemTypeDefMap = {
    /** A type definition for an actionable item. */
    [ChecklistItemType.Actionable]: GarminChecklistActionableItemDef;
    /** A type definition for a branch item. */
    [ChecklistItemType.Branch]: GarminChecklistBranchItemDef;
    /** A type definition for a branch item. */
    [ChecklistItemType.Link]: GarminChecklistLinkItemDef;
    /** A type definition for a note item. */
    [ChecklistItemType.Note]: GarminChecklistNoteItemDef;
    /** A type definition for a title item. */
    [ChecklistItemType.Title]: GarminChecklistTitleItemDef;
    /** A type definition for a spacer item. */
    [ChecklistItemType.Spacer]: GarminChecklistSpacerItemDef;
};
/**
 * A map from checklist item type to Garmin checklist items.
 */
type GarminChecklistItemTypeMap = ChecklistItemTypeMap<GarminChecklistItemTypeDefMap>;
/**
 * A utility type that returns a union type of Garmin checklist item definitions for a given set of checklist item types.
 * @template T The checklist item types to include in the returned union type. Defaults to `ChecklistItemType` (i.e.
 * the union of all checklist item types).
 */
type GarminChecklistItemDef<T extends ChecklistItemType = ChecklistItemType> = ChecklistItemDef<GarminChecklistItemTypeDefMap, T>;
/**
 * A utility type that returns a union type of Garmin checklist items for a given set of checklist item types.
 * @template T The checklist item types to include in the returned union type. Defaults to `ChecklistItemType` (i.e.
 * the union of all checklist item types).
 */
type GarminChecklistItem<T extends ChecklistItemType = ChecklistItemType> = ChecklistItem<GarminChecklistItemTypeDefMap, T>;

/**
 * A parser of Garmin checklist definitions from DOM elements.
 * @template I A map from checklist item types to checklist item definitions to which the definitions parsed by the
 * parser conform. Defaults to `GarminChecklistItemTypeDefMap`. Subclasses that parse item definitions that do not
 * conform to the default map should override this type parameter as appropriate.
 */
declare class GarminChecklistDOMParser<I extends GarminChecklistItemTypeDefMap = GarminChecklistItemTypeDefMap> extends ChecklistDOMParser<I> {
    /** @inheritDoc */
    protected parseItemDefArray(element: Element, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): ChecklistItemDef<I>[];
    /**
     * Parses automatically generated branch item link item definitions from a parent branch item definition.
     * @param parentItemElement The DOM element from which the parent branch item definition was parsed.
     * @param parentItem The parent branch item definition.
     * @param groupName The name of the checklist group for which the link items are to be parsed.
     * @param listName The name of the checklist list for which the link items are to be parsed.
     * @param branchName The name of the checklist branch for which the link items are to be parsed.
     * @param options The options to use when parsing.
     * @returns The automatically generated branch item link checklist item definitions parsed from the specified parent
     * branch item, or `undefined` none could be parsed.
     */
    protected parseAutoBranchItemLinkItemDefs(parentItemElement: Element, parentItem: I[ChecklistItemType.Branch], groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): GarminChecklistBranchItemLinkItemDef[] | undefined;
    /**
     * Resolves and validates a branch item link checklist item definition. First, the item definitions preceding the
     * item to resolve and validate will be checked to ensure that the latter is not separated from its parent branch
     * item by any items that are not another branch item link item. Then, the item's specified parent branch item UID
     * will be compared to the actual UID of the candidate parent branch item to ensure they match. If the item does not
     * specify a parent branch item UID, then it will be assigned the UID of the candidate parent. Next, the item's
     * link index will be compared to the parent branch item's linked branch array to ensure the index is not out of
     * bounds. Finally, the item's link target UID will be resolved from the parent branch item's linked branch array.
     * @param itemArray An array of item definitions that precede the item to resolve and validate.
     * @param item The item definition to resolve and validate.
     * @param groupName The name of the checklist group for which the item is to be resolved and validated.
     * @param listName The name of the checklist list for which the item is to be resolved and validated.
     * @param branchName The name of the checklist branch for which the item is to be resolved and validated.
     * @param options The options to use when parsing.
     * @returns The resolved and validated branch item link checklist item definition, or `undefined` if the definition
     * could not be resolved or validated.
     */
    protected resolveAndValidateBranchItemLinkItemDef(itemArray: readonly ChecklistItemDef<I>[], item: GarminChecklistBranchItemLinkItemDef, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): GarminChecklistBranchItemLinkItemDef | undefined;
    /** @inheritDoc */
    protected parseActionableItemDef(element: Element, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): I[ChecklistItemType.Actionable] | undefined;
    /** @inheritDoc */
    protected parseBranchItemDef(element: Element, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): I[ChecklistItemType.Branch] | undefined;
    /** @inheritDoc */
    protected parseLinkItemDef(element: Element, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): I[ChecklistItemType.Link] | undefined;
    /**
     * Parses a normal link checklist item definition from a DOM element.
     * @param element The element to parse.
     * @param groupName The name of the checklist group for which the item is to be parsed.
     * @param listName The name of the checklist list for which the item is to be parsed.
     * @param branchName The name of the checklist branch for which the item is to be parsed.
     * @param options The options to use when parsing.
     * @returns The normal link checklist item definition parsed from the specified element, or `undefined` if the
     * definition was discarded.
     */
    protected parseNormalLinkItemDef(element: Element, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): GarminChecklistNormalLinkItemDef | undefined;
    /**
     * Parses a branch item link checklist item definition from a DOM element.
     * @param element The element to parse.
     * @param groupName The name of the checklist group for which the item is to be parsed.
     * @param listName The name of the checklist list for which the item is to be parsed.
     * @param branchName The name of the checklist branch for which the item is to be parsed.
     * @param options The options to use when parsing.
     * @returns The branch item link checklist item definition parsed from the specified element, or `undefined` if the
     * definition was discarded.
     */
    protected parseBranchItemLinkItemDef(element: Element, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): GarminChecklistBranchItemLinkItemDef | undefined;
    /** @inheritDoc */
    protected parseNoteItemDef(element: Element, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): I[ChecklistItemType.Note] | undefined;
    /** @inheritDoc */
    protected parseTitleItemDef(element: Element, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): I[ChecklistItemType.Title] | undefined;
    /** @inheritDoc */
    protected parseSpacerItemDef(element: Element, groupName: string, listName: string, branchName: string | undefined, options: ChecklistDOMParseOptionsToUse<I>): I[ChecklistItemType.Spacer] | undefined;
    /**
     * Parses a Garmin checklist text color from an optional string.
     * @param string The string to parse.
     * @returns The Garmin checklist text color parsed from the specified string, or `undefined` if none could be parsed.
     */
    private static getTextColorFromString;
}

/** A data structure for passing back info on the display status. */
type CASAlertCounts = {
    /** The total number of messages that are displayed. */
    totalAlerts: number;
    /** The number of scrollable messages that are out of view above the selected window. */
    countAboveWindow: number;
    /** The number of scrollable messages that are out of view below the selected window. */
    countBelowWindow: number;
    /** The number of warnings present.*/
    numWarning: number;
    /** The number of cautions present. */
    numCaution: number;
    /** The number of advisories present.*/
    numAdvisory: number;
    /** The number of safeop messages present. */
    numSafeOp: number;
};
/** The props for a CAS element. */
interface CASProps extends ComponentProps {
    /** The event bus. */
    bus: EventBus;
    /** Alert subject. */
    annunciations: SubscribableArray<CasActiveMessage>;
    /** The number of annunciations to display at once. */
    numAnnunciationsShown: number | Subscribable<number>;
    /** An optional subject to pass back the alert counts. */
    alertCounts?: ObjectSubject<CASAlertCounts>;
}
/** A component for displaying CAS messages. */
declare class CASDisplay<T extends CASProps> extends DisplayComponent<T> {
    private readonly casDiv;
    private readonly messageCount;
    private readonly activeAnns;
    private readonly messageSlots;
    /** The index of the message that is currently displayed in the top (first) slot. */
    protected topAlertIndex: number;
    private readonly refreshNewMessageCssClassTimer;
    private readonly refreshNewMessageCssClassCallback;
    private messageCountSub?;
    private messageSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Responds to when the maximum displayed message count changes.
     */
    private onMessageCountChanged;
    /**
     * Render our the divs for our alerts.
     */
    private renderMessageSlots;
    /**
     * Responds to when the list of displayed CAS messages changes.
     * @param idx The index of the first message that changed.
     * @param type The type of change that occurred.
     * @param item The message or messages that changed.
     */
    private onMessagesChanged;
    /**
     * Handles when a displayed CAS message is added or removed.
     * @param idx The index of the message that changed.
     * @param type The type of change that occurred.
     * @param item The message that changed.
     */
    private handleMessageChanged;
    /**
     * Add an annunciation to the active list.
     * @param idx The index of the annunciations array for the annunciation.
     * @param item The annunciation configuration to add
     */
    protected addAnnunciation(idx: number, item: CasActiveMessage): void;
    /**
     * Remove an annunciation from the active list if present.
     * @param idx The index of the annunciations array for the annunciation.
     * @param item The item that's being removed.
     */
    protected removeAnnunciation(idx: number, item: CasActiveMessage): void;
    /**
     * Clear the annunciation display.
     */
    private clearAnnunciations;
    /**
     * Update our internal alert counts.  For efficiency we only update aggregate totals here,
     * it's up to other code to individually increment the per-alert-class totals when an alert
     * gets added or removed.
     */
    private updateAlertCounts;
    /**
     * Update the displayed divs with current annunciation status.
     */
    protected updateDisplayedAnnunciations(): void;
    /**
     * Adds the `new` CSS class to all of this display's message slots that are currently displaying an unacknowledged
     * message.
     */
    private refreshNewMessageCssClass;
    /**
     * Scroll the message window down.
     */
    scrollDown(): void;
    /**
     * Scroll the message window up.
     */
    scrollUp(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A scroll state of a {@link CasDisplay2}.
 */
type CasDisplay2ScrollState = {
    /** The number of displayed unscrollable message slots. */
    unscrollableSlotCount: number;
    /** The number of displayed scrollable message slots. */
    scrollableSlotCount: number;
    /** All scrollable messages, in display order. */
    scrollableMessages: readonly CasActiveMessage[];
    /**
     * The scrolling position of the scrollable message slots. A value of `0` indicates that the first scrollable
     * message is displayed in the first scrollable message slot, `1` indicates that the second scrollable message is
     * displayed in the first scrollable message slot, and so on.
     */
    scrollPos: number;
    /** The number of scrollable messages that are positioned before the first scrollable message slot. */
    messageBeforeCount: number;
    /** The number of scrollable messages that are positioned after the last scrollable message slot. */
    messageAfterCount: number;
    /**
     * The numbers of scrollable messages of each priority level that are positioned before the first scrollable message
     * slot.
     */
    messageBeforePriorityCounts: Readonly<Record<AnnunciationType, number>>;
    /**
     * The numbers of scrollable messages of each priority level that are positioned after the last scrollable message
     * slot.
     */
    messageAfterPriorityCounts: Readonly<Record<AnnunciationType, number>>;
};
/**
 * Component props for {@link CasDisplay2}.
 */
interface CasDisplay2Props extends ComponentProps {
    /** The messages to display. */
    messages: SubscribableArray<CasActiveMessage>;
    /** The maximum number of messages that can be displayed simultaneously. */
    maxMessageCount: number | Subscribable<number>;
    /** The maximum number of warning messages that are always displayed and cannot be scrolled. Defaults to `0`. */
    maxUnscrollableWarningCount?: number | Subscribable<number>;
    /** A mutable subscribable to which to write the scroll state of the display. */
    scrollState?: MutableSubscribable<any, Readonly<CasDisplay2ScrollState>>;
    /** Whether to disable automatic scrolling to new unacknowledged warning and caution messages. Defaults to `false`. */
    disableAutoScrollToNewMessage?: boolean;
    /** CSS class(es) to apply to the display's root element. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/**
 * A scrolling CAS display.
 */
declare class CasDisplay2 extends DisplayComponent<CasDisplay2Props> {
    private static readonly RESERVED_CLASSES;
    private readonly rootRef;
    private readonly maxMessageCount;
    private readonly maxUnscrollableWarningCount;
    private readonly messageSlots;
    private maxScrollPos;
    private scrollPos;
    private readonly oldMessages;
    private readonly refreshDebounce;
    private readonly refreshCallback;
    private readonly refreshNewMessageDebounce;
    private readonly refreshNewMessageCallback;
    private readonly refreshSubs;
    private cssClassSub?;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Scrolls this display's scrollable messages to a specific position.
     * @param pos The position to which to scroll. A value of `0` indicates that the first scrollable message is
     * displayed in the first scrollable message slot, `1` indicates that the second scrollable message is displayed in
     * the first scrollable message slot, and so on.
     */
    scrollTo(pos: number): void;
    /**
     * Scrolls this display's scrollable messages up.
     * @param delta The number of slots to scroll up.
     */
    scrollUp(delta?: number): void;
    /**
     * Scrolls this display's scrollable messages down.
     * @param delta The number of slots to scroll down.
     */
    scrollDown(delta?: number): void;
    /**
     * Schedules a refresh of this display.
     */
    private scheduleRefresh;
    /**
     * Refreshes this display. Once the refresh is complete, this display will display an up-to-date set of CAS messages
     * while respecting the current maximum message count, maximum unscrollable message count, and requested scroll
     * position.
     */
    private refresh;
    /**
     * Refreshes this display's message slots. If the number of rendered slots does not match the current maximum message
     * count, then slots will be added or removed as necessary until the two values are equal.
     */
    private refreshMessageSlots;
    private static readonly WARNING_FILTER;
    private static readonly NON_WARNING_FILTER;
    /**
     * Refreshes the messages displayed by this display.
     */
    private refreshDisplayedMessages;
    /**
     * Gets the index of the first new unacknowledged warning or caution message to which to automatically scroll, or
     * `-1` if there is no such message.
     * @param oldMessages A record of old unacknowledged messages.
     * @param scrollableMessages An array containing the current set of scrollable messages, in the order in which they
     * are to be displayed.
     * @returns The index of the first new unacknowledged warning or caution message to which to automatically scroll, or
     * `-1` if there is no such message.
     */
    private getAutoScrollIndex;
    /**
     * Checks whether a message is considered a new unacknowledged message.
     * @param map A map containing entries of old messages against which to the check the message.
     * @param message The message to check.
     * @returns Whether the specified message is considered a new unacknowledged message.
     */
    private isMessageNew;
    /**
     * Updates a record containing old unacknowledged messages.
     * @param record The record to update.
     * @param messages The messages from which to update the record.
     */
    private updateOldMessageRecord;
    /**
     * Updates a map containing old unacknowledged message suffixes, keyed by UUID. Once updated, the map will contain
     * entries for each unacknowledged message of a given priority in the provided message array listing the
     * unacknowledged suffixes of that message.
     * @param map The map to update.
     * @param priority The priority type of messages to included in the updated map.
     * @param messages The messages from which to update the map.
     */
    private updateOldMessageMap;
    /**
     * Sets the message displayed in a slot.
     * @param slot The slot to set.
     * @param message The message to display, or `null` if the slot should be cleared.
     */
    private setSlot;
    /**
     * Adds the `cas-display-2-msg-new` CSS class to all of this display's message slots that are currently displaying an
     * unacknowledged message.
     */
    private refreshNewMessageCssClass;
    /** @inheritDoc */
    render(): VNode;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * Utility Methods for the FMS.
 */
declare class FmsUtils {
    /** The index of the primary flight plan. */
    static readonly PRIMARY_PLAN_INDEX = 0;
    /** The index of the off-route direct-to flight plan. */
    static readonly DTO_RANDOM_PLAN_INDEX = 1;
    /** The index of the procedure preview flight plan. */
    static readonly PROC_PREVIEW_PLAN_INDEX = 2;
    /** The number of flight plan legs between a direct-to target leg and its associated direct-to leg. */
    static readonly DTO_LEG_OFFSET = 3;
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    /**
     * Subscribes to one of the event bus topics published by an FMS with a given ID.
     * @param id The ID of the FMS.
     * @param bus The event bus to which to subscribe.
     * @param baseTopic The base name of the topic to which to subscribe.
     * @returns A consumer for the specified event bus topic.
     */
    static onFmsEvent<ID extends string, K extends keyof BaseFmsEvents>(id: ID, bus: EventBus, baseTopic: K): Consumer<BaseFmsEvents[K]>;
    /**
     * Subscribes to one of the event bus topics published by an FMS with a given ID.
     * @param id The ID of the FMS.
     * @param subscriber The event subscriber to use to subscribe.
     * @param baseTopic The base name of the topic to which to subscribe.
     * @returns A consumer for the specified event bus topic.
     */
    static onFmsEvent<ID extends string, K extends keyof BaseFmsEvents>(id: ID, subscriber: EventSubscriber<FmsEventsForId<ID>>, baseTopic: K): Consumer<BaseFmsEvents[K]>;
    /**
     * Gets the departure segment from a flight plan.
     * @param plan A flight plan.
     * @returns The departure segment in the specified flight plan, or `undefined` if one does not exist.
     */
    static getDepartureSegment(plan: FlightPlan): FlightPlanSegment | undefined;
    /**
     * Gets the first enroute segment from a flight plan.
     * @param plan A flight plan.
     * @returns The first enroute segment in the specified flight plan, or `undefined` if one does not exist.
     */
    static getFirstEnrouteSegment(plan: FlightPlan): FlightPlanSegment | undefined;
    /**
     * Gets the last enroute segment from a flight plan.
     * @param plan A flight plan.
     * @returns The last enroute segment in the specified flight plan, or `undefined` if one does not exist.
     */
    static getLastEnrouteSegment(plan: FlightPlan): FlightPlanSegment | undefined;
    /**
     * Gets the arrival segment from a flight plan.
     * @param plan A flight plan.
     * @returns The arrival segment in the specified flight plan, or `undefined` if one does not exist.
     */
    static getArrivalSegment(plan: FlightPlan): FlightPlanSegment | undefined;
    /**
     * Gets the approach segment from a flight plan.
     * @param plan A flight plan.
     * @returns The approach segment in the specified flight plan, or `undefined` if one does not exist.
     */
    static getApproachSegment(plan: FlightPlan): FlightPlanSegment | undefined;
    /**
     * Gets the destination segment from a flight plan.
     * @param plan A flight plan.
     * @returns The destination segment in the specified flight plan, or `undefined` if one does not exist.
     */
    static getDestinationSegment(plan: FlightPlan): FlightPlanSegment | undefined;
    /**
     * Builds a flight plan leg to a runway fix.
     * @param airport The runway's parent airport or its ICAO.
     * @param runway The runway associated with the runway fix.
     * @param isInitialFix Whether to create the flight plan leg as an initial fix (IF) leg instead of a track-to-fix
     * (TF) leg.
     * @returns A flight plan leg to the specified runway fix.
     */
    static buildRunwayLeg(airport: AirportFacility | IcaoValue, runway: OneWayRunway, isInitialFix: boolean): FlightPlanLeg;
    /**
     * Utility method to return a visual approach for a runway.
     * @param airport is the airport facility for the visual approach.
     * @param runway is the runway to build the visual approach for.
     * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
     * @param initialLegDistance is the distance from the final leg to place the iaf leg in NM.
     * @param name is the optional name for the approach.
     * @param finalLegIdent is the optional name for the faf leg.
     * @param initialLegIdent is the optional name for the iaf leg.
     * @returns an approach procedure.
     */
    static buildVisualApproach(airport: AirportFacility, runway: OneWayRunway, finalLegDistance: number, initialLegDistance: number, name?: string, finalLegIdent?: string, initialLegIdent?: string): ApproachProcedure;
    /**
     * Builds an empty approach procedure object for a visual approach. The empty object contains all descriptive data
     * for the approach but lacks flight plan leg information for the approach.
     * @param runway The runway to which the approach belongs.
     * @returns An empty approach procedure object for the specified approach.
     */
    static buildEmptyVisualApproach(runway: OneWayRunway): ApproachProcedure;
    /**
     * Creates a VFR approach object based on a published approach.
     * @param airport The airport facility containing the published approach on which the VFR approach is based.
     * @param approachIndex The index of the published approach on which the VFR approach is based.
     * @returns A new VFR approach object based on the specified published approach, or `undefined` if a VFR approach
     * could not be generated.
     */
    static buildVfrApproach(airport: AirportFacility, approachIndex: number): GarminVfrApproachProcedure | undefined;
    /**
     * Gets the best RNAV minimum type available for a given approach.
     * @param query The approach to check, or its RNAV type flags.
     * @returns The best RNAV minimum type available for the specified approach.
     */
    static getBestRnavType: typeof ApproachUtils.getBestRnavType;
    private static readonly APPROACH_TYPE_QUALITY;
    /**
     * Gets the best approach type available at an airport.
     * @param airport An airport facility.
     * @param includeVisual Whether to include visual approaches. Defaults to `false`.
     * @param includeRnpAr Whether to include RNP AR approaches. Defaults to `false`.
     * @returns The best approach type available at the specified airport.
     */
    static getBestApproachType(airport: AirportFacility, includeVisual?: boolean, includeRnpAr?: boolean): ExtendedApproachType;
    /**
     * Utility method to check whether an approach is authorized for GPS guidance.
     * @param approach The approach procedure
     * @returns True if GPS guidance is authorized, false otherwise.
     */
    static isGpsApproach(approach: ApproachProcedure): boolean;
    /**
     * Utility method to check for an approach with a a tunable localizer.
     * @param approach The approach procedure
     * @returns True if a localizer needs to be tuned, otherwise false.
     */
    static isLocalizerApproach(approach: ApproachProcedure): boolean;
    /**
     * Gets an approach procedure from a flight plan. If the flight plan has an visual approach loaded, an empty
     * procedure object, containing descriptive data for the approach but lacking flight plan leg information, will be
     * returned.
     * @param plan A flight plan.
     * @param destination The destination airport of the flight plan.
     * @returns The approach procedure from the flight plan, or undefined if the plan has no approach.
     */
    static getApproachFromPlan(plan: FlightPlan, destination: AirportFacility): GarminApproachProcedure | undefined;
    /**
     * Checks whether a flight plan has an approach loaded.
     * @param plan A flight plan.
     * @returns Whether the flight plan has an approach loaded.
     */
    static isApproachLoaded(plan: FlightPlan): boolean;
    /**
     * Checks whether a flight plan has an approach loaded.
     * @param plan A flight plan.
     * @returns Whether the flight plan has an approach loaded.
     */
    static isPublishedApproachLoaded(plan: FlightPlan): boolean;
    /**
     * Checks whether a flight plan has an approach loaded.
     * @param plan A flight plan.
     * @returns Whether the flight plan has an approach loaded.
     */
    static isVisualApproachLoaded(plan: FlightPlan): boolean;
    /**
     * Checks whether a flight plan has an approach loaded.
     * @param plan A flight plan.
     * @returns Whether the flight plan has an approach loaded.
     */
    static isVfrApproachLoaded(plan: FlightPlan): boolean;
    /**
     * Gets the final approach fix leg of a flight plan.
     * @param plan A flight plan.
     * @returns The final approach fix leg of a flight plan, or `undefined` if one could not be found.
     */
    static getApproachFafLeg(plan: FlightPlan): LegDefinition | undefined;
    /**
     * Checks whether a plan has a vectors-to-final approach loaded.
     * @param plan A flight plan.
     * @returns Whether the flight plan has a vectors-to-final approach loaded.
     */
    static isVtfApproachLoaded(plan: FlightPlan): boolean;
    /**
     * Gets the vectors-to-final faf leg of a flight plan.
     * @param plan A flight plan.
     * @returns The vectors-to-final faf leg of the flight plan, or `undefined` if one could not be found.
     */
    static getApproachVtfLeg(plan: FlightPlan): LegDefinition | undefined;
    /**
     * Gets the name of a departure procedure as a string.
     * @param airport The airport to which the departure belongs.
     * @param departure A departure procedure definition.
     * @param transitionIndex The index of the departure enroute transition.
     * @param runway The runway of the departure, if any.
     * @returns The name of the departure procedure.
     */
    static getDepartureNameAsString(airport: AirportFacility, departure: DepartureProcedure, transitionIndex: number, runway: OneWayRunway | undefined): string;
    /**
     * Gets the name of a arrival procedure as a string.
     * @param airport The airport to which the departure belongs.
     * @param arrival An arrival procedure definition.
     * @param transitionIndex The index of the arrival enroute transition.
     * @param runway The runway of the arrival, if any.
     * @returns The name of the arrival procedure.
     */
    static getArrivalNameAsString(airport: AirportFacility, arrival: ArrivalProcedure, transitionIndex: number, runway: OneWayRunway | undefined): string;
    /**
     * Gets the transition name and creates a default transition when the procedure has no transitions.
     * @param procedure is the departure procedure.
     * @param transitionIndex is the index of the enroute transition in the procedure.
     * @param rwyTransitionIndex is the index of the runway transition in the procedure.
     * @returns The transition name string.
     */
    static getDepartureEnrouteTransitionName(procedure: DepartureProcedure, transitionIndex: number, rwyTransitionIndex: number): string;
    /**
     * Gets the transition name and creates a default transition when the procedure has no transitions.
     * @param procedure is the arrival procedure.
     * @param transitionIndex is the index of the enroute transition in the procedure.
     * @param rwyTransitionIndex is the index of the runway transition in the procedure.
     * @returns The transition name string.
     */
    static getArrivalEnrouteTransitionName(procedure: ArrivalProcedure, transitionIndex: number, rwyTransitionIndex: number): string;
    /**
     * Checks whether an approach procedure is an RNP (AR) approach.
     * @param proc The approach procedure to check.
     * @returns Whether the approach procedure is an RNP (AR) approach.
     */
    static isApproachRnpAr: typeof ApproachUtils.isRnpAr;
    /**
     * Utility method to analyze an approach for its name components and
     * pack them into a custom type.
     * @param proc The approach procedure.
     * @returns The name as an ApproachNameParts
     */
    static getApproachNameAsParts(proc: GarminApproachProcedure): ApproachNameParts;
    /**
     * Utility method that takes an approach and returns its name as a flat
     * string suitable for use in embedded text content.
     * @param approach The approach as an ApproaceProcedure
     * @returns The formatted name as a string.
     */
    static getApproachNameAsString(approach: GarminApproachProcedure): string;
    /**
     * Checks whether an approach has a primary NAV frequency based on its type. Only approaches of the following types
     * have primary NAV frequencies: ILS, LOC (BC), LDA, SDF, VOR(DME).
     * @param approach The approach to check.
     * @returns Whether the specified approach has a primary NAV frequency based on its type.
     */
    static approachHasNavFrequency(approach: ApproachProcedure): boolean;
    /**
     * Gets an array of approach list items from an airport.
     * @param airport An airport.
     * @param includeVisual Whether to include visual approaches. Defaults to `true`.
     * @returns An array of approach list items for the specified airport.
     */
    static getApproaches(airport?: AirportFacility, includeVisual?: boolean): ApproachListItem[];
    /**
     * Gets an array of approach list items from an airport.
     * @param airport An airport.
     * @returns An array of approach list items for the specified airport.
     */
    static getVfrApproaches(airport?: AirportFacility): VfrApproachListItem[];
    /**
     * Gets the visual approaches for the facility.
     * @param facility is the facility.
     * @returns The Approach Procedures.
     */
    static getVisualApproaches(facility: AirportFacility): ApproachProcedure[];
    /**
     * Creates an ApproachListItem from an ApproachProcedure and the approach index.
     * @param approach The approach procedure.
     * @param index The approach index.
     * @returns The created ApproachListItem.
     */
    static createApproachListItem(approach: ApproachProcedure, index: number): ApproachListItem;
    /**
     * Gets the transitions for the approach, adding suffixes, vectors transtion, and default approach if needed.
     * @param approachItem The approach procedure to get the transitions for.
     * @returns The transitions for the approach.
     */
    static getApproachTransitions(approachItem?: ApproachListItem): TransitionListItem[];
    /**
     * Creates an TransitionListItem from an ApproachProcedure and the transition index.
     * @param approach The approach procedure.
     * @param transitionIndex The approach transition index.
     * @returns The created TransitionListItem.
     */
    static createApproachTransitionListItem(approach: ApproachProcedure, transitionIndex: number): TransitionListItem;
    /**
     * Creates an TransitionListItem from an ApproachProcedure and the transition index.
     * @param approach The approach procedure.
     * @param transitionIndex The approach transition index.
     * @returns The created TransitionListItem.
     */
    static getApproachTransitionName(approach: ApproachProcedure, transitionIndex: number): string;
    /**
     * Gets the global leg index from a segment and segment leg index, whether or not the leg exists.
     * @param lateralPlan The Lateral Flight Plan.
     * @param segmentIndex The Segment Index.
     * @param segmentLegIndex The Segment Leg Index.
     * @returns The global leg index.
     */
    static getGlobalLegIndex(lateralPlan: FlightPlan, segmentIndex: number, segmentLegIndex: number): number;
    /**
     * Gets the indexes for a leg.
     * @param lateralPlan The Lateral Flight Plan.
     * @param leg The leg definition.
     * @returns The leg indexes, or undefined if not found.
     */
    static getLegIndexes(lateralPlan: FlightPlan, leg: LegDefinition): LegIndexes | undefined;
    /**
     * Gets the nominal leg from which a specified flight plan leg originates. The nominal from leg excludes any legs
     * which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLeg(plan: FlightPlan, segmentIndex: number, segmentLegIndex: number): LegDefinition | undefined;
    /**
     * Gets the global leg index of the nominal leg from which a specified flight plan leg originates. The nominal from
     * leg excludes any legs which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLegIndex(plan: FlightPlan, segmentIndex: number, segmentLegIndex: number): number;
    /**
     * Gets the leg from which a specified flight plan leg originates for the purpose of displaying the flight plan
     * from-to arrow.
     * @param plan A flight plan.
     * @param globalLegIndex The global index of the leg for which to get the from leg.
     * @returns The leg from which the specified flight plan leg originates for the purpose of displaying the from -to
     * arrow.
     */
    static getFromLegForArrowDisplay(plan: FlightPlan, globalLegIndex: number): LegDefinition | undefined;
    /**
     * Gets the leg from which a specified flight plan leg originates for the purpose of displaying the flight plan
     * from-to arrow.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The leg from which the specified flight plan leg originates for the purpose of displaying the from -to
     * arrow.
     */
    static getFromLegForArrowDisplay(plan: FlightPlan, segmentIndex: number, segmentLegIndex: number): LegDefinition | undefined;
    /**
     * Gets the nominal desired track for a flight plan leg, as `[dtk, magVar]` where `dtk` is the true desired track and
     * `magVar` is the magnetic variation used to convert between true and magnetic desired tracks, both in degrees. If a
     * nominal desired track could not be obtained, then the value of `dtk` will be equal to `NaN`.
     * @param leg The leg for which to get the nominal desired track.
     * @param out The array to which to write the results.
     * @returns The nominal desired track for the specified flight plan leg, as `[dtk, magVar]` where `dtk` is the true
     * desired track and `magVar` is the magnetic variation used to convert between true and magnetic desired tracks,
     * both in degrees.
     */
    static getNominalLegDtk(leg: LegDefinition, out: Float64Array): Float64Array;
    /**
     * Gets the nominal desired track from a flight plan leg's last flight path vector, as `[dtk, magVar]` where `dtk` is
     * the true desired track and `magVar` is the magnetic variation used to convert between true and magnetic desired
     * tracks, both in degrees. If the last flight path vector is a great-circle vector, then the nominal desired track
     * is equal to the vector's initial course. Otherwise, the nominal desired track is equal to the vector's final
     * course. If no flight path vectors exist, then the output array is returned unchanged.
     * @param legCalc The calculations for the flight plan leg for which to get the desired track.
     * @param out The array to which to write the results.
     * @returns The nominal desired track from the specified flight plan leg's last flight path vector, as
     * `[dtk, magVar]` where `dtk` is the true desired track and `magVar` is the magnetic variation used to convert
     * between true and magnetic desired tracks, both in degrees.
     */
    private static getNominalLegDtkForEndCourse;
    /**
     * Reconciles a flight plan's Direct-To data with its internal leg structure. Scans the legs of the flight plan for
     * Direct-To legs and sets the segment index and segment leg index of the plan's Direct-To data to point to the leg
     * immediately preceding the first Direct-To leg found, or to -1 for both if the plan contains no Direct-To legs.
     * @param plan A flight plan.
     */
    static reconcileDirectToData(plan: FlightPlan): void;
    /**
     * Gets the string for the leg fix type for use in a sequence list.
     * @param leg The leg definition.
     * @param allowHdg If false, will not return 'hdg'. Defaults to true.
     * @returns The left padded suffix string or empty string.
     */
    static getSequenceLegFixTypeSuffix(leg: LegDefinition, allowHdg?: boolean): string;
    /**
     * Checks for a course reversal in the procedure.
     * @param legs The legs in the procedure.
     * @param ppos The current aircraft present position.
     * @returns true if there is an optional course reversal.
     */
    static checkForCourseReversal(legs: LegDefinition[], ppos: GeoPoint): boolean;
    /**
     * Gets and returns the ICAO of first airport fix from the flight plan legs.
     * @param plan The flight plan to use.
     * @returns The ICAO of first airport fix from the flight plan legs.
     */
    static getFirstAirportFromPlan(plan: FlightPlan): IcaoValue | undefined;
    /**
     * Gets and returns the ICAO of last airport fix from the flight plan legs.
     * @param plan The flight plan to use.
     * @returns The ICAO of last airport fix from the flight plan legs.
     */
    static getLastAirportFromPlan(plan: FlightPlan): IcaoValue | undefined;
    /**
     * Gets and returns the ICAO of first or last airport fix from the flight plan legs.
     * @param plan The flight plan to use.
     * @param reverse Whether to get the first or last airport.
     * @returns The ICAO of last airport fix from the flight plan legs.
     */
    static getAirportFromPlan(plan: FlightPlan, reverse: boolean): IcaoValue | undefined;
    /**
     * Determines if a flight plan leg's altitude constraint is considered to be edited. If the leg does not have a
     * designated altitude constraint, `false` will be returned.
     * @param leg A flight plan leg.
     * @param isAdvancedVNav Whether advanced VNAV is supported.
     * @returns Whether the specified flight plan leg's altitude constraint is considered to be edited.
     */
    static isLegAltitudeEdited(leg: LegDefinition, isAdvancedVNav: boolean): boolean;
    /**
     * Checks whether a flight plan leg's altitude constraint should be editable.
     * @param plan The flight plan containing the leg to evaluate.
     * @param leg The flight plan leg to evaluate.
     * @param isAdvancedVNav Whether this is for advanced vnav mode or not.
     * @returns whether a leg's altitude constraint should be editable.
     */
    static isAltitudeEditable(plan: FlightPlan, leg: LegDefinition, isAdvancedVNav: boolean): boolean;
    /**
     * Checks whether a leg's altitude constraint should be visible.
     * @param plan The flight plan containing the leg to evaluate.
     * @param leg The flight plan leg to evaluate.
     * @param isAdvancedVNav Whether this is for advanced vnav mode or not.
     * @param isEditable Whether the constraint is editable, leave undefined if we don't know yet.
     * @returns whether a leg's altitude constraint should be visible.
     */
    static isAltitudeVisible(plan: FlightPlan, leg: LegDefinition, isAdvancedVNav: boolean, isEditable?: boolean): boolean;
    /**
     * Returns the speed restriction type to use based on the published speed and what segment it's in.
     * @param publishedSpeedRestriction The published speed.
     * @param segmentType The segment type.
     * @returns The speed restriction type to use.
     */
    static getPublishedSpeedDescBasedOnSegment(publishedSpeedRestriction: number, segmentType: FlightPlanSegmentType): SpeedRestrictionType;
    /**
     * Determines whether an altitude should be displayed as a flight level.
     * @param altitudeMeters The altitude in meters.
     * @returns Whether an altitude should be displayed as a flight level.
     */
    static displayAltitudeAsFlightLevel(altitudeMeters: number): boolean;
    /**
     * Creates a new empty, default flight phase object.
     * @returns A new empty, default flight phase object.
     */
    static createEmptyFlightPhase(): FmsFlightPhase;
    /**
     * Checks whether two FMS flight phase objects are equal.
     * @param a The first FMS flight phase object to compare.
     * @param b The second FMS flight phase object to compare.
     * @returns Whether the two FMS flight phase objects are equal.
     */
    static flightPhaseEquals(a: Readonly<FmsFlightPhase>, b: Readonly<FmsFlightPhase>): boolean;
    /**
     * Creates a new empty, default approach details object.
     * @returns A new empty, default approach details object.
     */
    static createEmptyApproachDetails(): ApproachDetails;
    /**
     * Checks whether two FMS approach details objects are equal.
     * @param a The first FMS approach details object to compare.
     * @param b The second FMS approach details object to compare.
     * @returns Whether the two FMS approach details objects are equal.
     */
    static approachDetailsEquals(a: Readonly<ApproachDetails>, b: Readonly<ApproachDetails>): boolean;
}
/** Transition List Items for the Select Procedure Page */
interface TransitionListItem {
    /** Transition Name */
    name: string;
    /** Source Transition Index from Facility Approach */
    transitionIndex: number;
    /**
     * The starting leg index from Facility Approach Transition for this offset transition
     * @deprecated No longer used by anything. Used to be used for a workaround that is no longer needed.
     */
    startIndex?: number;
}
/**
 * A type representing the three parts of an approach name.
 */
type ApproachNameParts = {
    /** The approach type. */
    type: string;
    /** The approach subtype (eg, GPS) */
    subtype?: string;
    /** The approach suffix */
    suffix?: string;
    /** The runway identifier. */
    runway?: string;
    /** Additonal flags (eg, RNAV type) */
    flags?: string;
};
/**
 * An approach procedure paired with its index in its parent airport facility.
 */
type ApproachListItem = {
    /** The approach procedure. */
    approach: ApproachProcedure;
    /** The index of the approach in its parent airport facility. */
    index: number;
    /** Whether the approach is a visual approach. */
    isVisualApproach: boolean;
};
/**
 * A VFR approach procedure paired with the index of the published approach on which it is based.
 */
type VfrApproachListItem = {
    /** The VFR approach procedure. */
    approach: GarminVfrApproachProcedure;
    /** The index of the published approach on which the VFR approach is based. */
    index: number;
};
/** Structure containing useful leg related indices. */
interface LegIndexes {
    /** The index of the segment. */
    segmentIndex: number;
    /** The index of the leg in the segment. */
    segmentLegIndex: number;
    /** The index of the leg in the flight plan. */
    globalLegIndex: number;
}

/** Properties for a VNode representing an approach name. */
interface ApproachNameDisplayProps extends ComponentProps {
    /** A subscribable which provides an approach procedure. */
    approach?: GarminApproachProcedure | null | undefined | Subscribable<GarminApproachProcedure | null | undefined>;
    /**
     * A subscribable which provides the approach name parts.
     * If used, the approach prop will be ignored.
     */
    approachNameParts?: ApproachNameParts | null | undefined | Subscribable<ApproachNameParts | null | undefined>;
    /**
     * A subscribable which provides the approach's parent airport. If no subscribable is provided or its value is null,
     * the airport ident will not be displayed as part of the approach name.
     */
    airport?: AirportFacility | null | undefined | Subscribable<AirportFacility | null | undefined>;
    /**
     * A subscribable which provides the approach's parent airport ident. If no subscribable is provided or its value is null,
     * the airport ident will not be displayed as part of the approach name.
     * If passed in, the airport prop will be ignored.
     */
    airportIdent?: string | null | undefined | Subscribable<string | null | undefined>;
    /** Text to display at the beginning of the display. */
    prefix?: string | null | undefined | Subscribable<string | null | undefined>;
    /** The text to display when the approach is null. Defaults to the empty string. */
    nullText?: string;
    /** Whether to use the zero with the slash through it in place of any 0's in the name. */
    useZeroWithSlash?: boolean;
    /** CSS class(es) to apply to the root of the component. */
    class?: string;
}
/** A VNode representing a preformated rendering of an approach's name. */
declare class ApproachNameDisplay extends DisplayComponent<ApproachNameDisplayProps> {
    private readonly nameRef;
    private readonly prefixRef;
    private readonly airportRef;
    private readonly subTypeRef;
    private readonly suffixRef;
    private readonly runwayRef;
    private readonly flagsRef;
    private readonly nullRef;
    private readonly approach;
    private readonly approachNamePartsProp;
    private readonly airport;
    private readonly airportIdent;
    private readonly prefix;
    private readonly prefixText;
    private readonly airportText;
    private readonly approachNameParts;
    private readonly typeText;
    private readonly subTypeText;
    private readonly suffixConnectorText;
    private readonly suffixText;
    private readonly runwayText;
    private readonly flagsText;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for BearingDisplay.
 */
interface BearingDisplayProps extends Omit<AbstractNumberUnitDisplayProps<NavAngleUnitFamily>, 'value' | 'displayUnit'> {
    /** The {@link NumberUnitInterface} value to display, or a subscribable which provides it. */
    value: NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit> | Subscribable<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
    /**
     * The unit type in which to display the value, or a subscribable which provides it. If the unit is `null`, then the
     * native type of the value is used instead.
     */
    displayUnit: NavAngleUnit | null | Subscribable<NavAngleUnit | null>;
    /** A function which formats numbers. */
    formatter: (number: number) => string;
    /**
     * A function which formats units. The formatted unit text should be written to the 2-tuple passed to the `out`
     * parameter, as `[bigText, smallText]`. `bigText` and `smallText` will be rendered into separate `<span>` elements
     * representing the big and small components of the rendered unit text, respectively. If not defined, then units
     * will be formatted such that `bigText` is always the degree symbol () and `smallText` is empty for magnetic
     * bearing or `'T'` for true bearing.
     */
    unitFormatter?: (out: [string, string], unit: NavAngleUnit, number: number) => void;
    /** Whether to display `'360'` in place of `'0'`. Defaults to `true`. */
    use360?: boolean;
    /** Whether to hide the unit text when the displayed value is equal to `NaN`. Defaults to `false`. */
    hideDegreeSymbolWhenNan?: boolean;
    /** CSS class(es) to add to the root of the bearing display component. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/**
 * Displays a bearing value.
 */
declare class BearingDisplay extends AbstractNumberUnitDisplay<NavAngleUnitFamily, BearingDisplayProps> {
    /**
     * A function which formats units to default text for BearingDisplay.
     * @param out The 2-tuple to which to write the formatted text, as `[bigText, smallText]`.
     * @param unit The unit to format.
     */
    static readonly DEFAULT_UNIT_FORMATTER: (out: [string, string], unit: NavAngleUnit) => void;
    private static readonly unitTextCache;
    private readonly unitFormatter;
    private readonly unitTextBigDisplay;
    private readonly unitTextSmallDisplay;
    private readonly numberText;
    private readonly unitTextBig;
    private readonly unitTextSmall;
    /** @inheritdoc */
    protected onValueChanged(value: NumberUnitInterface<NavAngleUnitFamily>): void;
    /** @inheritdoc */
    protected onDisplayUnitChanged(displayUnit: Unit<NavAngleUnitFamily> | null): void;
    /**
     * Updates this component's displayed number text.
     * @param numberValue The numeric value to display.
     */
    private updateNumberText;
    /**
     * Updates this component's displayed unit text.
     * @param numberValue The numeric value to display.
     * @param displayUnit The unit type in which to display the value.
     */
    private updateUnitText;
    /**
     * Updates whether this component's unit text spans are visible.
     * @param numberValue The numeric value displayed by this component.
     */
    private updateUnitTextVisibility;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Component props for FailureBox.
 */
interface FailureBoxProps extends ComponentProps {
    /** Whether to show the box. */
    show: Subscribable<boolean>;
    /** CSS class(es) to apply to the box's root element. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/**
 * A failure box.
 */
declare class FailureBox extends DisplayComponent<FailureBoxProps> {
    private static readonly RESERVED_CLASSES;
    private readonly display;
    private cssClassSubs?;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Display formats for {@link LatLonDisplay}.
 */
declare enum LatLonDisplayFormat {
    /** HDDD MM.MM' */
    HDDD_MMmm = "HDDD\u00B0 MM.MM'",
    /** HDDD MM.MMM' */
    HDDD_MMmmm = "HDDD\u00B0 MM.MMM'",
    /** HDDD MM' SS.S */
    HDDD_MM_SSs = "HDDD\u00B0 MM' SS.S"
}
/**
 * Component props for LatLonDisplay.
 */
interface LatLonDisplayProps extends ComponentProps {
    /** The location for which to display coordinates. */
    value: LatLonInterface | null | Subscribable<LatLonInterface | null>;
    /** The format to use to display the coordinates. */
    format: LatLonDisplayFormat | Subscribable<LatLonDisplayFormat>;
    /** Whether to split the prefix into a separate `span` element within the `div.g-latlon-coord`. Defaults to `false`. */
    splitPrefix?: boolean;
    /** Whether to format prefix text as an underscore when the coordinate value is equal to `NaN`. Defaults to `false`. */
    blankPrefixWhenNaN?: boolean;
    /** CSS class(es) to add to the component's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * A component which displays Garmin-style lat/lon coordinates.
 */
declare class LatLonDisplay extends DisplayComponent<LatLonDisplayProps> {
    private static readonly LAT_FORMATTERS;
    private static readonly BLANK_PREFIX_LAT_FORMATTERS;
    private static readonly LON_FORMATTERS;
    private static readonly BLANK_PREFIX_LON_FORMATTERS;
    private readonly value;
    private readonly format;
    private readonly valueState;
    private readonly latText;
    private readonly latPrefixText;
    private readonly latNumberText;
    private readonly lonText;
    private readonly lonPrefixText;
    private readonly lonNumberText;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
    /**
     * Creates a record of latitude formatters keyed by display format.
     * @param blankPrefixWhenNaN Whether the formatters should format prefix text as an underscore when latitude is equal
     * to `NaN`.
     * @returns A record of latitude formatters keyed by display format.
     */
    private static createLatFormatters;
    /**
     * Creates a record of longitude formatters keyed by display format.
     * @param blankPrefixWhenNaN Whether the formatters should format prefix text as an underscore when longitude is
     * equal to `NaN`.
     * @returns A record of longitude formatters keyed by display format.
     */
    private static createLonFormatters;
}

/**
 * Component props for displaing a magvar.
 */
interface MagVarDisplayProps extends ComponentProps {
    /**
     * The magnetic variation to display, or a subscribable which provides it. By convention, positive values indicate
     * deviation to the east of true north.
     */
    magvar: number | Subscribable<number>;
    /** CSS class(es) to apply to the root of the component. */
    class?: string | SubscribableSet<string>;
}
/**
 * Text display of a magnetic variation as degrees east or west.
 */
declare class MagVarDisplay extends DisplayComponent<MagVarDisplayProps> {
    private static readonly FORMATTER;
    private readonly text;
    private magvarSub?;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapRangeValueDisplay describing raw range values.
 */
type MapRangeValueDisplayRawRangeProps = {
    /** The displayed range. */
    range: NumberUnitInterface<UnitFamily.Distance> | Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
};
/**
 * Component props for MapRangeValueDisplay describing indexed range values.
 */
type MapRangeValueDisplayIndexedRangeProps = {
    /** The index of the displayed range. */
    rangeIndex: number | Subscribable<number>;
    /** The map range array. */
    rangeArray: Subscribable<readonly NumberUnitInterface<UnitFamily.Distance>[]>;
};
/**
 * Component props for MapRangeValueDisplay describing the displayed range.
 */
type MapRangeValueDisplayRangeProps = MapRangeValueDisplayIndexedRangeProps | MapRangeValueDisplayRawRangeProps;
/**
 * Component props for MapRangeValueDisplay.
 */
type MapRangeValueDisplayProps = MapRangeValueDisplayRangeProps & ComponentProps & {
    /** The displayed unit type. */
    displayUnit: Subscribable<Unit<UnitFamily.Distance> | null>;
    /** CSS class(es) to apply to the display's root element. */
    class?: string | SubscribableSet<string>;
};
/**
 * A component which displays a map range value.
 */
declare class MapRangeValueDisplay extends DisplayComponent<MapRangeValueDisplayProps> {
    private static readonly DEFAULT_RANGE;
    private readonly numberUnitRef;
    private readonly range;
    private readonly displayUnit;
    private readonly displayUnitState;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Updates this component's display unit.
     */
    private updateDisplayUnit;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for NumberUnitDisplay.
 */
interface NumberUnitDisplayProps<F extends string> extends AbstractNumberUnitDisplayProps<F> {
    /** A function which formats numbers. */
    formatter: (number: number) => string;
    /**
     * A function which formats units. The formatted unit text should be written to the 2-tuple passed to the `out`
     * parameter, as `[bigText, smallText]`. `bigText` and `smallText` will be rendered into separate `<span>` elements
     * representing the big and small components of the rendered unit text, respectively. If not defined, then units
     * will be formatted based on the text generated by the {@link UnitFormatter} class.
     */
    unitFormatter?: (out: [string, string], unit: Unit<F>, number: number) => void;
    /** Whether to hide the unit text when the displayed value is equal to `NaN`. Defaults to `false`. */
    hideUnitWhenNaN?: boolean;
    /** CSS class(es) to add to the root of the icon component. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/**
 * A component which displays a number with units.
 */
declare class NumberUnitDisplay<F extends string> extends AbstractNumberUnitDisplay<F, NumberUnitDisplayProps<F>> {
    private static readonly DEFAULT_UNIT_TEXT_MAP;
    /**
     * A function which formats units to default text for NumberUnitDisplay.
     * @param out The 2-tuple to which to write the formatted text, as `[bigText, smallText]`.
     * @param unit The unit to format.
     */
    static readonly DEFAULT_UNIT_FORMATTER: (out: [string, string], unit: Unit<any>) => void;
    private static readonly unitTextCache;
    private readonly unitFormatter;
    private readonly unitTextBigDisplay;
    private readonly unitTextSmallDisplay;
    private readonly numberText;
    private readonly unitTextBig;
    private readonly unitTextSmall;
    /** @inheritdoc */
    protected onValueChanged(value: NumberUnitInterface<F>): void;
    /** @inheritdoc */
    protected onDisplayUnitChanged(displayUnit: Unit<F> | null): void;
    /**
     * Updates this component's displayed number and unit text.
     * @param value The value to display.
     * @param displayUnit The unit type in which to display the value, or `null` if the value should be displayed in its
     * native unit type.
     */
    private updateDisplay;
    /**
     * Updates whether this component's unit text spans are visible.
     * @param numberValue The numeric value displayed by this component.
     * @param unitTextBig The text to display in the big text span.
     * @param unitTextSmall The text to display in the small text span.
     */
    private updateUnitTextVisibility;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Creates the default mapping from unit to displayed text.
     * @returns The default mapping from unit to displayed text.
     */
    private static createDefaultUnitTextMap;
}

/**
 * Time display formats.
 */
declare enum TimeDisplayFormat {
    /** UTC time. */
    UTC = 0,
    /** Local time in 24-hour format. */
    Local24 = 1,
    /** Local time in 12-hour format. */
    Local12 = 2
}
/**
 * Component props for TimeDisplay.
 */
interface TimeDisplayProps extends ComponentProps {
    /** The time to display, as a UNIX timestamp in milliseconds. */
    time: number | Subscribable<number>;
    /** The display format. */
    format: TimeDisplayFormat | Subscribable<TimeDisplayFormat>;
    /** The local time offset, in milliseconds. */
    localOffset: number | Subscribable<number>;
    /** Whether to the pad the hour text with leading zeroes (up to two digits). Defaults to `true`. */
    padHour?: boolean | Subscribable<boolean>;
    /**
     * A function which formats suffixes to append to the displayed time. If not defined, then the suffix will be
     * will be formatted as `'UTC'` if the display format is {@link TimeDisplayFormat.UTC}, `'LCL'` if the display format
     * is {@link TimeDisplayFormat.Local24}, and either `'AM'` or `'PM'` if the display format is
     * {@link TimeDisplayFormat.Local12}.
     */
    suffixFormatter?: (format: TimeDisplayFormat, isAm: boolean) => string;
    /** Whether to hide the suffix when the displayed time is equal to `NaN`. Defaults to `false`. */
    hideSuffixWhenNaN?: boolean;
    /** CSS class(es) to apply to the root of the component. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/**
 * Displays time in HH:MM:SS format.
 */
declare class TimeDisplay extends DisplayComponent<TimeDisplayProps> {
    private static readonly SECOND_PRECISION_MAP;
    private static readonly HIDE_UNIT_TEXT_PIPE;
    /**
     * A function which formats suffixes for TimeDisplay.
     * @param format The current format used to display the time.
     * @param isAm Whether or not the current time is AM.
     * @returns The suffix to append to the displayed time.
     */
    static readonly DEFAULT_SUFFIX_FORMATTER: (format: TimeDisplayFormat, isAm: boolean) => string;
    private readonly timeSeconds;
    private readonly format;
    private readonly localOffset;
    private readonly padHour;
    private readonly suffixFormatter;
    private readonly suffixDisplay;
    private readonly date;
    private readonly hourText;
    private readonly minText;
    private readonly secText;
    private readonly suffixText;
    private readonly updateHandler;
    private timeSub?;
    private formatSub?;
    private localOffsetSub?;
    private padHourSub?;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Updates the displayed time.
     */
    protected updateDisplayedTime(): void;
    /**
     * Gets the suffix to append to the time display.
     * @param format The format of the time display.
     * @param isAm Whether or not the current time is AM.
     * @returns The time display suffix.
     */
    protected getSuffix(format: TimeDisplayFormat, isAm: boolean): string;
    /** @inheritDoc */
    render(): VNode;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * Component props for ButtonStatusBar.
 */
interface ToggleStatusBarProps extends ComponentProps {
    /** A subscribable which provides the state of the status bar (`false` = off, `true` = on). */
    state: Subscribable<boolean>;
    /** CSS class(es) to apply to the status bar's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * A status bar which depicts an on/off state.
 *
 * The root element of the status bar contains the `toggle-status-bar` CSS class by default. The root element also
 * conditionally contains the `toggle-status-bar-on` class when the status bar's bound state is on.
 */
declare class ToggleStatusBar extends DisplayComponent<ToggleStatusBarProps> {
    private readonly cssClassSet;
    private stateSub?;
    private cssClassSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * An item that can be displayed in a dynamic list.
 */
interface DynamicListData {
    /** Whether this list item is visible in the list. */
    isVisible?: Subscribable<boolean>;
}

/**
 * A list that handles dynamically adding and removing list items from an HTML element.
 */
declare class DynamicList<DataType extends DynamicListData> {
    private readonly data;
    private readonly itemsContainer;
    private readonly renderItem;
    private readonly sortItems?;
    private readonly listItemCount;
    private readonly _visibleItemCount;
    /** The number of visible items in this list.  */
    readonly visibleItemCount: Subscribable<number>;
    private readonly renderedNodes;
    private readonly visibilitySubscriptions;
    private readonly elements;
    private readonly sortIndexes;
    private readonly sortedIndexes;
    private readonly indexToSortedIndex;
    private readonly dataSub;
    /**
     * Creates a new instance of DynamicList.
     * @param data An array of data items to display in this list.
     * @param itemsContainer The Element to which this list's items will be rendered as children.
     * @param renderItem A function that used to render this list's items. The function is called for every list item
     * that is added to this list. If the root node returned by the function is a {@link DisplayComponent}, then its
     * `destroy()` method will be called when the item is removed from this list.
     * @param sortItems A function to sort data items before rendering them. The function should return a negative
     * number if the first item should be rendered before the second, a positive number if the first item should be
     * rendered after the second, or zero if the two items' relative order does not matter. If not defined, items will
     * be rendered in the order in which they appear in the data item array.
     */
    constructor(data: SubscribableArray<DataType>, itemsContainer: Element, renderItem: (data: DataType, index: number) => VNode, sortItems?: ((a: DataType, b: DataType) => number) | undefined);
    /**
     * Renders all of this list's items to the item container element.
     */
    private renderList;
    /**
     * Gets the sorted index of a data item index.
     * @param index A data item index.
     * @returns The index to which the specified data item index is sorted, or `-1` if the data index is out of bounds.
     */
    sortedIndexOfIndex(index: number): number;
    /**
     * Gets the sorted index of a data item.
     * @param data A data item.
     * @returns The index to which the specified data item is sorted, or `-1` if the item is not in this list.
     */
    sortedIndexOfData(data: DataType): number;
    /**
     * Gets the sorted index of a data item index after hidden items have been excluded.
     * @param index A data item index.
     * @returns The index to which the specified data item index is sorted after hidden items have been excluded, or `-1`
     * if the data index is out of bounds or the data item whose index was given is itself hidden.
     */
    sortedVisibleIndexOfIndex(index: number): number;
    /**
     * Gets the sorted index of a data item after hidden items have been excluded.
     * @param data A data item.
     * @returns The index to which the specified data item is sorted after hidden items have been excluded, or `-1` if
     * the item is not in this list or is itself hidden.
     */
    sortedVisibleIndexOfData(data: DataType): number;
    /**
     * Gets the data item index of a sorted index.
     * @param sortedIndex A sorted index.
     * @returns The index of the data item that is sorted to the specified index, or `-1` if the sorted index is out of bounds.
     */
    indexOfSortedIndex(sortedIndex: number): number;
    /**
     * Gets the data item index of a sorted index after hidden items have been excluded.
     * @param sortedVisibleIndex A sorted index after hidden items have been excluded.
     * @returns The index of the data item that is sorted to the specified index after hidden items have been excluded,
     * or `-1` if the sorted index is out of bounds.
     */
    indexOfSortedVisibleIndex(sortedVisibleIndex: number): number;
    /**
     * Gets the rendered instance of a data item in this list.
     * @param index The index of the data item for which to get the rendered instance.
     * @returns The rendered instance of the specified data item, or `undefined` if {@linkcode index} is out of bounds.
     */
    getRenderedItem(index: number): NodeInstance | undefined;
    /**
     * Iterates over each rendered component and executes a callback function.
     * @param fn The callback function to execute for each component. The function should take two arguments: the first
     * argument is the iterated component, and the second argument is the index of the component _in the iteration_.
     * @param visibleOnly Whether to only iterate over components whose associated data items have their visibility flags
     * set to `true`. Defaults to `false`.
     * @param sortedOrder Whether to iterate over components in sorted order instead of the order in which their
     * associated data items appear in the data array. Defaults to `false`.
     */
    forEachComponent<T extends DisplayComponent<any>>(fn: (component: T | undefined, index: number) => void, visibleOnly?: boolean, sortedOrder?: boolean): void;
    /**
     * Responds to when this list's data item array changes.
     * @param index The index of the change.
     * @param type The type of change.
     * @param data The item that was changed.
     */
    private onDataChanged;
    /**
     * Responds to when data items are added to this list's data item array.
     * @param index The index at which the data items were added.
     * @param data The data items that were added.
     */
    private onDataAdded;
    /**
     * Adds a data item to the list and performs the required rendering and ordering operations.
     * @param dataItem The data item to add to the list.
     * @param indexToAdd The index to add the item at.
     */
    private addDataItem;
    /**
     * Adds a list rendered DOM node to the collection.
     * @param node Item to render and add.
     * @param elementAtIndexToInsert The existing element, if any, located at the index to which to render the node.
     * @returns The created DOM element.
     */
    private renderToDom;
    /**
     * Responds to when data items are removed from this list's data item array.
     * @param index The index at which the data items were removed.
     * @param data The data items that were removed.
     */
    private onDataRemoved;
    /**
     * Removes a data item from the list.
     * @param data The data item to remove.
     * @param index The index of the data that was removed.
     */
    private removeDataItem;
    /**
     * Removes a rendered DOM node corresponding to a data item from this list's item container.
     * @param data The data item to remove.
     * @param index The index of the data item to remove.
     */
    private removeDomNode;
    /**
     * Responds to when this list's data item array is cleared.
     */
    private onDataCleared;
    /**
     * Adjust the visible item count when a data item's visiblity changes.
     * @param isVisible The data item's new visibility.
     */
    private readonly dataItemVisibilityChanged;
    /**
     * Increments this list's visible item count by 1.
     */
    private incrementVisibleCount;
    /**
     * Decrements this list's visible item count by 1.
     */
    private decrementVisibleCount;
    /**
     * Updates the array which maps data indexes to sorted indexes to match the sorting order provided by the
     * sorted index array.
     */
    private reconcileSortedIndexArrays;
    /**
     * Updates the order of the rendered items in this list.
     */
    updateOrder(): void;
    /**
     * Destroys this list.
     */
    destroy(): void;
}

/**
 * Component props for ScrollList.
 */
interface ScrollListProps extends ComponentProps {
    /** The axis along which the list scrolls. Defaults to `y`. */
    scrollAxis?: 'x' | 'y';
    /**
     * The length of each list item, in pixels, along the list's scroll axis.
     */
    listItemLengthPx: number | Subscribable<number>;
    /** The amount of space between each list item in pixels. Defaults to zero pixels. */
    listItemSpacingPx?: number | Subscribable<number>;
    /**
     * The maximum distance the list can overscroll past the beginning and end, in pixels. Defaults to the length of one
     * list item.
     */
    maxOverscrollPx?: number | Subscribable<number>;
    /**
     * The length of the list, in pixels, along its scroll axis. If not defined, then the default value depends on
     * whether the number of items per page is defined. If the number of items per page is defined, then the length
     * defaults to the sum of the list item length and spacing multiplied by the number of items per page. If the number
     * of items per page is not defined, then the length defaults to 100 pixels.
     */
    lengthPx?: number | Subscribable<number>;
    /** The number of visible items per page. If not defined, the list will not snap to list items when scrolling. */
    itemsPerPage?: number | Subscribable<number>;
    /**
     * The maximum number of items that can be rendered simultaneously. Ignored if `itemsPerPage` is not defined. The
     * value will be clamped to be greater than or equal to `itemsPerPage * 3`. Defaults to infinity.
     */
    maxRenderedItemCount?: number | Subscribable<number>;
    /** The total number of items in the list. */
    itemCount: number | Subscribable<number>;
    /** CSS class(es) to apply to the list's root element. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/**
 * A scrollable list.
 */
declare class ScrollList<P extends ScrollListProps = ScrollListProps> extends DisplayComponent<P> {
    protected static readonly RESERVED_CLASSES: string[];
    protected childrenNode?: VNode;
    protected readonly rootRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly translatableRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly itemsContainerRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly listItemLengthPxProp: Subscribable<number>;
    protected readonly listItemSpacingPxProp: Subscribable<number>;
    protected readonly itemsPerPageProp: Subscribable<number> | undefined;
    protected readonly listItemLengthPx: Subject<number>;
    protected readonly listItemSpacingPx: Subject<number>;
    protected readonly itemCount: Subscribable<number>;
    /** The axis along which this list scrolls. */
    readonly scrollAxis: "x" | "y";
    protected readonly _itemsPerPage: Subject<number> | undefined;
    /**
     * The number of visible list items per page displayed by this list, or `undefined` if the number of items per page
     * is not prescribed.
     */
    readonly itemsPerPage: Subscribable<number> | undefined;
    protected readonly snapToItem: boolean;
    protected readonly _listItemLengthWithMarginPx: MappedSubject<[number, number], number>;
    /** The length, in pixels, of one item in this list plus its margin along this list's scroll axis. */
    readonly listItemLengthWithMarginPx: Subscribable<number>;
    protected readonly _totalLengthPx: MappedSubject<[number, number, number], number>;
    /** The total length, in pixels, of all items in this list plus their margins along this list's scroll axis. */
    readonly totalLengthPx: Subscribable<number>;
    protected readonly _lengthPx: Subscribable<number> | MappedSubscribable<number>;
    /** The visible length of this list, in pixels, along its scroll axis. */
    readonly lengthPx: Subscribable<number>;
    /** The length of one page, in pixels, along this list's scroll axis. */
    protected readonly pageLength: MappedSubscribable<number>;
    protected readonly _maxScrollPos: MappedSubject<[number, number], number>;
    /** This list's maximum allowed scroll position, in pixels. Does not include overscroll. */
    readonly maxScrollPos: Subscribable<number>;
    /** How many pixels we will allow overscrolling before stopping. */
    protected readonly maxOverscrollPx: Subscribable<number>;
    protected readonly _scrollPos: Subject<number>;
    /**
     * This list's current scroll position, in pixels. The scroll position is zero when the list is scrolled to the
     * beginning (without overscroll) and increases as the list is scrolled toward the end.
     */
    readonly scrollPos: Subscribable<number>;
    /**
     * This list's current scroll position, normalized such that 0 represents when the list is scrolled to the beginning
     * (without overscroll) and 1 represents when the list is scrolled to the end (without overscroll).
     */
    readonly scrollPosFraction: Subscribable<number>;
    /**
     * The fraction of this list's visible length compared to the total length of all items in this list plus their
     * margins along this list's scroll axis.
     */
    readonly scrollBarLengthFraction: Subscribable<number>;
    protected readonly _animationTargetScrollPos: Subject<number | undefined>;
    /**
     * The scroll position targeted by this list's current scrolling animation, in pixels, or `undefined` if scrolling is
     * not currently animated or the animation has no defined target scroll position.
     */
    readonly animationTargetScrollPos: Subscribable<number | undefined>;
    /**
     * This list's current target scroll position, in pixels. The target scroll position is equal to the current
     * animation target if it is defined; otherwise it is equal to the current scroll position.
     */
    readonly targetScrollPos: MappedSubject<[number | undefined, number], number>;
    protected readonly _firstVisibleIndex: MappedSubject<[number, number], number>;
    readonly firstVisibleIndex: Subscribable<number>;
    protected readonly maxRenderedItemCount: MappedSubject<[number, number], number> | undefined;
    protected readonly renderWindowStartIndex: Subject<number>;
    protected readonly renderWindowStartPos: MappedSubject<[number, number], number>;
    /** This list's current scroll position adjusted for the render window. */
    protected readonly trueScrollPos: MappedSubject<[number, number], number>;
    protected readonly _renderWindow: Vec2Subject;
    /**
     * The window of rendered list items, as `[startIndex, endIndex]`, where `startIndex` is the index of the first
     * rendered item, inclusive, and `endIndex` is the index of the last rendered item, exclusive.
     */
    readonly renderWindow: Subscribable<Readonly<Omit<Float64Array, "set" | "sort" | "copyWithin">>>;
    protected readonly animateFunc: () => void;
    protected isAnimating: boolean;
    protected velocity: number;
    protected lastTimeSeconds: number;
    protected deltaTimeSeconds: number;
    protected timeInOverscrollSeconds: number;
    /** How long to wait while overscrolled before snapping back. */
    protected maxTimeInOverscrollSeconds: number;
    /** Once at or below this velocity, we pick that target Y to snap to. */
    protected snappingTransitionSpeed: number;
    protected goToAnimationTargetPos: boolean;
    protected interval?: number;
    protected readonly listItemParamSubs: Subscription[];
    protected cssClassSub?: Subscription | Subscription[];
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Returns a reference to the element where the list items should be added.
     * @returns A reference to the element where the list items should be added.
     */
    getContainerRef(): HTMLDivElement;
    /**
     * Scrolls backward by one full page length.
     */
    pageBack(): void;
    /**
     * Scrolls forward by one full page length.
     */
    pageForward(): void;
    /**
     * Scrolls until the item at a specified index is in view.
     * @param index The index of the item to which to scroll.
     * @param position The position to place the target item at the end of the scroll. Position `0` is the top/left-most
     * visible slot, position `1` is the next slot, and so on. Values greater than or equal to the number of visible
     * items per page will be clamped. Negative values will be interpreted as counting backwards from the
     * bottom/right-most visible slot starting with `-1`. Ignored if this list does not support snapping to list items.
     * @param animate Whether to animate the scroll.
     */
    scrollToIndex(index: number, position: number, animate: boolean): void;
    /**
     * Scrolls the minimum possible distance until the item at a specified index is in view with a given margin from the
     * edges of the visible list.
     * @param index The index of the item to which to scroll.
     * @param margin The margin from the edges of the visible list to respect when scrolling to the target item. In other
     * words, the scrolling operation will attempt to place the target item at least as far from the edges of the visible
     * list as the specified margin. If this list supports snapping to items, then the margin should be expressed as an
     * item count. If this list does not support snapping to items, then the margin should be expressed as pixels. The
     * margin will be clamped between zero and the largest possible value such that an item can be placed within the
     * visible list while respecting the margin value on both sides.
     * @param animate Whether to animate the scroll.
     */
    scrollToIndexWithMargin(index: number, margin: number, animate: boolean): void;
    /**
     * Executes a scroll to a specifed position.
     * @param pos The position to which to scroll.
     * @param animate Whether to animate the scroll.
     */
    protected executeScrollTo(pos: number, animate: boolean): void;
    /**
     * Reset the animation vars and start the animation, if not already started.
     */
    protected startAnimating(): void;
    /** Stop the animation. */
    protected stopAnimating(): void;
    /**
     * Called once per animation frame while we are animating.
     */
    protected animate(): void;
    /**
     * Applies the velocity to the scroll position, which gives it the "flick" effect.
     * Also slows the velocity down overtime.
     * @param deltaTimeSeconds Seconds since last animation frame.
     */
    protected animateVelocity(deltaTimeSeconds: number): void;
    /**
     * Animates scrolling back when overscrolled.
     */
    protected animateSnapback(): void;
    /**
     * If we have a target Y position to stop scrolling at, animate towards a smooth stop right at that point.
     * @param deltaTimeSeconds  Seconds since last animation frame.
     */
    protected animateSnapping(deltaTimeSeconds: number): void;
    /**
     * Picks the scroll position, in pixels, of the snap-to target that is nearest to a given scroll position.
     * @param pos The scroll position, in pixels, for which to find the nearest snap-to target.
     * @returns The scroll position, in pixels, of the snap-to target that is nearest to the specified scroll
     * position.
     */
    protected pickNearestSnapToPos(pos: number): number;
    /**
     * Responds to when one of this list's item parameters changes when the list supports snapping to items.
     * @param pipeTo The mutable subscribable to which to pipe the new parameter value.
     * @param value The new parameter value.
     */
    protected onListItemParamChanged(pipeTo: MutableSubscribable<number>, value: number): void;
    /**
     * Updates this list's item render window.
     */
    protected updateRenderWindow(): void;
    /**
     * Changes this list's item render window.
     * @param scrollPos The scroll position on which to center the new render window, in pixels.
     * @param renderCount The number of items to render in the new window.
     * @param itemLength The length of each item to render, including margin, in pixels.
     * @param windowLength The length of the render window, in pixels.
     */
    protected changeRenderWindow(scrollPos: number, renderCount: number, itemLength: number, windowLength: number): void;
    /**
     * Updates this list's item container's x-transform based on the current true scroll position.
     * @param scrollPos The current true scroll position, in pixels.
     */
    protected updateTransformX(scrollPos: number): void;
    /**
     * Updates this list's item container's y-transform based on the current true scroll position.
     * @param scrollPos The current true scroll position, in pixels.
     */
    protected updateTransformY(scrollPos: number): void;
    /**
     * Checks if the list is scrolled past the maximum limit, and if so, snaps the list back to the limit.
     */
    protected ensureScrollIsInBounds(): void;
    /**
     * Returns a number used to dampen the mouse movement when overscrolled.
     * @param direction What direction os the mouse moving in.
     * @returns a number used to dampen the mouse movement when overscrolled.
     */
    protected getDampening(direction: number): number;
    /**
     * Gets the distance by which this list is currently overscrolled, in pixels along the scroll axis.
     * @returns The distance by which this list is currently overscrolled, in pixels along the scroll axis.
     */
    protected getOverscrollPx(): number;
    /**
     * Returns whether this list is currently overscrolled.
     * @returns Whether this list is currently overscrolled.
     */
    protected isOverscrolled(): boolean;
    /** @inheritDoc */
    render(): VNode;
    /**
     * Gets an array of this list's reserved CSS classes.
     * @returns An array of this list's reserved CSS classes.
     */
    protected getReservedCssClasses(): readonly string[];
    /** @inheritDoc */
    destroy(): void;
}

/**
 * Component props for TouchList.
 */
interface TouchListProps extends ScrollListProps {
    /**
     * The event bus. Required for the list to respond appropriately to the mouse leaving the virtual cockpit instrument
     * screen while the user is dragging the list.
     */
    bus?: EventBus;
}
/**
 * A touchscreen list which can be scrolled by clicking and dragging the mouse.
 */
declare class TouchList extends ScrollList<TouchListProps> {
    protected static readonly RESERVED_CLASSES: string[];
    protected readonly isMouseDown: Subject<boolean>;
    protected readonly instrumentMouseLeaveSub: _microsoft_msfs_sdk.Subscription | undefined;
    protected lastMousePosition: number | undefined;
    protected readonly onMouseDownCaptureFunc: (e: MouseEvent) => void;
    protected readonly onMouseDownFunc: (e: MouseEvent) => void;
    protected readonly onMouseUpFunc: () => void;
    protected readonly onMouseMoveFunc: (e: MouseEvent) => void;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Scrolls until the item at a specified index is in view. The operation will be aborted if the list is currently
     * being dragged by the user.
     * @param index The index of the item to which to scroll.
     * @param position The position to place the target item at the end of the scroll. Position `0` is the top/left-most
     * visible slot, position `1` is the next slot, and so on. Values greater than or equal to the number of visible
     * items per page will be clamped. Negative values will be interpreted as counting backwards from the
     * bottom/right-most visible slot starting with `-1`. Ignored if this list does not support snapping to list items.
     * @param animate Whether to animate the scroll.
     */
    scrollToIndex(index: number, position: number, animate: boolean): void;
    /**
     * Scrolls the minimum possible distance until the item at a specified index is in view with a given margin from the
     * edges of the visible list. The operation will be aborted if the list is currently being dragged by the user.
     * @param index The index of the item to which to scroll.
     * @param margin The margin from the edges of the visible list to respect when scrolling to the target item. In other
     * words, the scrolling operation will attempt to place the target item at least as far from the edges of the visible
     * list as the specified margin. If this list supports snapping to items, then the margin should be expressed as an
     * item count. If this list does not support snapping to items, then the margin should be expressed as pixels. The
     * margin will be clamped between zero and the largest possible value such that an item can be placed within the
     * visible list while respecting the margin value on both sides.
     * @param animate Whether to animate the scroll.
     */
    scrollToIndexWithMargin(index: number, margin: number, animate: boolean): void;
    /** @inheritdoc */
    protected changeRenderWindow(scrollPos: number, renderCount: number, itemLength: number, windowLength: number): void;
    /**
     * User has clicked on the list, so now we want to listen for
     * the mouse moving so we can scroll the list with the mouse.
     * @param e The mouse event.
     */
    protected onMouseDownCapture(e: MouseEvent): void;
    /**
     * User has clicked on the list, so now we want to listen for
     * the mouse moving so we can scroll the list with the mouse.
     * @param e The mouse event.
     */
    protected onMouseDown(e: MouseEvent): void;
    /**
     * Responds to `mouseup` events on this list after the user has started dragging.
     */
    protected onMouseUp(): void;
    /**
     * Responds to `mousemove` events on this list while the user is dragging.
     * @param e The mouse event.
     */
    protected onMouseMove(e: MouseEvent): void;
    /** @inheritDoc */
    protected getReservedCssClasses(): readonly string[];
    /** @inheritDoc */
    destroy(): void;
}

/**
 * A cache of images for waypoint icons.
 */
interface WaypointIconImageCache {
    /**
     * Retrieves an image for a waypoint.
     * @param waypoint The waypoint for which to retrieve the image.
     * @returns The image for the specified waypoint, or `undefined` if one could not be found.
     */
    getForWaypoint(waypoint: Waypoint): HTMLImageElement | undefined;
}

/**
 * Setting modes for map orientation.
 */
declare enum MapOrientationSettingMode {
    NorthUp = "NorthUp",
    TrackUp = "TrackUp",
    HeadingUp = "HeadingUp",
    DtkUp = "DtkUp"
}
/**
 * Setting modes for map terrain display.
 */
declare enum MapTerrainSettingMode {
    None = "None",
    Absolute = "Absolute",
    Relative = "Relative"
}
/**
 * Setting modes for map declutter.
 */
declare enum MapDeclutterSettingMode {
    All = "All",
    Level3 = "Level3",
    Level2 = "Level2",
    Level1 = "Level1"
}
declare enum MapTrafficAlertLevelSettingMode {
    All = "All",
    Advisories = "Advisories",
    TA_RA = "TA/RA",
    RA = "RA"
}
/**
 * Type descriptions for map user settings.
 */
type MapUserSettingTypes = {
    /** The map range index setting. */
    mapRangeIndex: number;
    /** The orientation setting. */
    mapOrientation: MapOrientationSettingMode;
    /** Whether north-up above is active. */
    mapAutoNorthUpActive: boolean;
    /** The range index above which north-up above applies. */
    mapAutoNorthUpRangeIndex: number;
    /** Whether north-up on ground is active. */
    mapGroundNorthUpActive: boolean;
    /** Declutter setting. */
    mapDeclutter: MapDeclutterSettingMode;
    /** The terrain display setting. */
    mapTerrainMode: MapTerrainSettingMode;
    /** The terrain maximum range setting. */
    mapTerrainRangeIndex: number;
    /** The terrain scale show setting. */
    mapTerrainScaleShow: boolean;
    /** Large airport symbol show setting. */
    mapAirportLargeShow: boolean;
    /** Large airport maximum range setting. */
    mapAirportLargeRangeIndex: number;
    /** Medium airport symbol show setting. */
    mapAirportMediumShow: boolean;
    /** Medium airport maximum range setting. */
    mapAirportMediumRangeIndex: number;
    /** Small airport symbol show setting. */
    mapAirportSmallShow: boolean;
    /** Small airport maximum range setting. */
    mapAirportSmallRangeIndex: number;
    /** VOR symbol show setting. */
    mapVorShow: boolean;
    /** VOR maximum range setting. */
    mapVorRangeIndex: number;
    /** NDB symbol show setting. */
    mapNdbShow: boolean;
    /** NDB maximum range setting. */
    mapNdbRangeIndex: number;
    /** Intersection symbol show setting. */
    mapIntersectionShow: boolean;
    /** Intersection maximum range setting. */
    mapIntersectionRangeIndex: number;
    /** User waypoint symbol show setting. */
    mapUserWaypointShow: boolean;
    /** User waypoint maximum range setting. */
    mapUserWaypointRangeIndex: number;
    /** Class B airspace show setting. */
    mapAirspaceClassBShow: boolean;
    /** Class B airspace maximum range setting. */
    mapAirspaceClassBRangeIndex: number;
    /** Class C airspace show setting. */
    mapAirspaceClassCShow: boolean;
    /** Class C airspace maximum range setting. */
    mapAirspaceClassCRangeIndex: number;
    /** Class D airspace show setting. */
    mapAirspaceClassDShow: boolean;
    /** Class D airspace maximum range setting. */
    mapAirspaceClassDRangeIndex: number;
    /** Restricted airspace show setting. */
    mapAirspaceRestrictedShow: boolean;
    /** Restricted airspace maximum range setting. */
    mapAirspaceRestrictedRangeIndex: number;
    /** MOA airspace show setting. */
    mapAirspaceMoaShow: boolean;
    /** MOA airspace maximum range setting. */
    mapAirspaceMoaRangeIndex: number;
    /** Other airspace show setting. */
    mapAirspaceOtherShow: boolean;
    /** Other airspace maximum range setting. */
    mapAirspaceOtherRangeIndex: number;
    /** Whether to show traffic. */
    mapTrafficShow: boolean;
    /** Traffic maximum range setting. */
    mapTrafficRangeIndex: number;
    /** Whether to show traffic labels. */
    mapTrafficLabelShow: boolean;
    /** Traffic label maximum range setting. */
    mapTrafficLabelRangeIndex: number;
    /** Traffic alert level mode setting. */
    mapTrafficAlertLevelMode: MapTrafficAlertLevelSettingMode;
    /** Whether to show NEXRAD weather or not. */
    mapNexradShow: boolean;
    /** NEXRAD maximum range setting. */
    mapNexradRangeIndex: number;
    /** Whether to show the track vector. */
    mapTrackVectorShow: boolean;
    /** The track vector lookahead time, in seconds. */
    mapTrackVectorLookahead: number;
    /** Whether to show the altitude intercept arc. */
    mapAltitudeArcShow: boolean;
    /** Whether to show the wind vector. */
    mapWindVectorShow: boolean;
};
/**
 * A utility class for working with map user settings.
 */
declare class MapUserSettingsUtils {
    /** An array of all map user setting names. */
    static readonly SETTING_NAMES: readonly (keyof MapUserSettingTypes)[];
}

/**
 * Setting modes for nav angle units.
 */
declare enum UnitsNavAngleSettingMode {
    Magnetic = "magnetic",
    True = "true"
}
/**
 * Setting modes for distance/speed units.
 */
declare enum UnitsDistanceSettingMode {
    Metric = "metric",
    Nautical = "nautical",
    Statute = "statute"
}
/**
 * Setting modes for altitude units.
 */
declare enum UnitsAltitudeSettingMode {
    Feet = "feet",
    Meters = "meters",
    MetersMps = "metersMps"
}
/**
 * Setting modes for temperature units.
 */
declare enum UnitsTemperatureSettingMode {
    Celsius = "celsius",
    Fahrenheit = "fahrenheit"
}
/**
 * Setting modes for weight units.
 */
declare enum UnitsWeightSettingMode {
    Kilograms = "kilograms",
    Pounds = "pounds"
}
/**
 * Setting modes for fuel units.
 */
declare enum UnitsFuelSettingMode {
    Gallons = "gallons",
    ImpGal = "imp gals",
    Kilograms = "kilograms",
    Liters = "liters",
    Pounds = "pounds"
}
/**
 * Garmin display units user settings.
 */
type UnitsUserSettingTypes = {
    /** The nav angle units setting. */
    unitsNavAngle: UnitsNavAngleSettingMode;
    /** The distance/speed units setting. */
    unitsDistance: UnitsDistanceSettingMode;
    /** The altitude units setting. */
    unitsAltitude: UnitsAltitudeSettingMode;
    /** The temperature units setting. */
    unitsTemperature: UnitsTemperatureSettingMode;
    /** The weight units setting. */
    unitsWeight: UnitsWeightSettingMode;
    /** The fuel units setting. */
    unitsFuel: UnitsFuelSettingMode;
};
/**
 * Instrument-local versions of Garmin display units user settings.
 */
type LocalUnitsUserSettingTypes = {
    [P in keyof UnitsUserSettingTypes as `${P}_local`]: UnitsUserSettingTypes[P];
};
/**
 * A manager for Garmin display units user settings.
 */
interface UnitsUserSettingManager<T extends UnitsUserSettingTypes & UserSettingRecord = UnitsUserSettingTypes> extends UserSettingManager<T> {
    /** The nav angle units to use for the current nav angle units setting. */
    readonly navAngleUnits: Subscribable<NavAngleUnit>;
    /** The large distance units to use (nautical mile, kilometer, etc.) for the current distance units setting. */
    readonly distanceUnitsLarge: Subscribable<Unit<UnitFamily.Distance>>;
    /** The small distance units to use (foot, meter, etc.) for the current distance units setting. */
    readonly distanceUnitsSmall: Subscribable<Unit<UnitFamily.Distance>>;
    /** The speed units to use for the current distance units setting. */
    readonly speedUnits: Subscribable<Unit<UnitFamily.Speed>>;
    /** The altitude units to use for the current altitude units setting. */
    readonly altitudeUnits: Subscribable<Unit<UnitFamily.Distance>>;
    /** The vertical speed units to use for the current altitude units setting. */
    readonly verticalSpeedUnits: Subscribable<Unit<UnitFamily.Speed>>;
    /** The temperature units to use for the current temperature units setting. */
    readonly temperatureUnits: Subscribable<Unit<UnitFamily.Temperature>>;
    /** The temperature delta units to use for the current temperature units setting. */
    readonly temperatureDeltaUnits: Subscribable<Unit<UnitFamily.TemperatureDelta>>;
    /** The weight units to use for the current weight units setting. */
    readonly weightUnits: Subscribable<Unit<UnitFamily.Weight>>;
    /** The fuel units to use for the current fuel units setting. */
    readonly fuelUnits: Subscribable<Unit<UnitFamily.Weight>>;
    /** The fuel flow units to use for the current fuel units setting. */
    readonly fuelFlowUnits: Subscribable<Unit<UnitFamily.WeightFlux>>;
}
/**
 * A default implementation of {@link UnitsUserSettingManager} which sources setting values from another setting
 * manager.
 */
declare class DefaultUnitsUserSettingManager<T extends UnitsUserSettingTypes & UserSettingRecord = UnitsUserSettingTypes> implements UnitsUserSettingManager<T> {
    private readonly sourceSettingManager;
    private static readonly TRUE_BEARING;
    private static readonly MAGNETIC_BEARING;
    private readonly _navAngleUnits;
    /** @inheritDoc */
    readonly navAngleUnits: Subscribable<NavAngleUnit>;
    private readonly _distanceUnitsLarge;
    /** @inheritDoc */
    readonly distanceUnitsLarge: Subscribable<Unit<UnitFamily.Distance>>;
    private readonly _distanceUnitsSmall;
    /** @inheritDoc */
    readonly distanceUnitsSmall: Subscribable<Unit<UnitFamily.Distance>>;
    private readonly _speedUnits;
    /** @inheritDoc */
    readonly speedUnits: Subscribable<Unit<UnitFamily.Speed>>;
    private readonly _altitudeUnits;
    /** @inheritDoc */
    readonly altitudeUnits: Subscribable<Unit<UnitFamily.Distance>>;
    private readonly _verticalSpeedUnits;
    /** @inheritDoc */
    readonly verticalSpeedUnits: Subscribable<Unit<UnitFamily.Speed>>;
    private readonly _temperatureUnits;
    /** @inheritDoc */
    readonly temperatureUnits: Subscribable<Unit<UnitFamily.Temperature>>;
    private readonly _temperatureDeltaUnits;
    /** @inheritDoc */
    readonly temperatureDeltaUnits: Subscribable<Unit<UnitFamily.TemperatureDelta>>;
    private readonly _weightUnits;
    /** @inheritDoc */
    readonly weightUnits: Subscribable<Unit<UnitFamily.Weight>>;
    private readonly _fuelUnits;
    /** @inheritDoc */
    readonly fuelUnits: Subscribable<Unit<UnitFamily.Weight>>;
    private readonly _fuelFlowUnits;
    /** @inheritDoc */
    readonly fuelFlowUnits: Subscribable<Unit<UnitFamily.WeightFlux>>;
    /**
     * Creates a new instance of DefaultUnitsUserSettingManager.
     * @param sourceSettingManager The manager from which to source setting values.
     */
    constructor(sourceSettingManager: UserSettingManager<T>);
    /** @inheritDoc */
    tryGetSetting<K extends string>(name: K): K extends keyof T ? UserSetting<NonNullable<T[K]>> : undefined;
    /** @inheritDoc */
    getSetting<K extends keyof T & string>(name: K): UserSetting<NonNullable<T[K]>>;
    /** @inheritDoc */
    whenSettingChanged<K extends keyof T & string>(name: K): Consumer<NonNullable<T[K]>>;
    /** @inheritDoc */
    getAllSettings(): UserSetting<UserSettingValue>[];
    /** @inheritDoc */
    mapTo<M extends UserSettingRecord>(map: UserSettingMap<M, T>): UserSettingManager<M & T>;
}
/**
 * Utility class for retrieving display units user setting managers.
 */
declare class UnitsUserSettings {
    private static INSTANCE;
    private static LOCAL_INSTANCE;
    /**
     * Retrieves a manager for display units user settings.
     * @param bus The event bus.
     * @returns A manager for display units user settings.
     */
    static getManager(bus: EventBus): UnitsUserSettingManager;
    /**
     * Retrieves a manager for instrument-local display units user settings.
     * @param bus The event bus.
     * @returns A manager for instrument-local display units user settings.
     */
    static getLocalManager(bus: EventBus): UnitsUserSettingManager;
    /**
     * Gets the default values for a full set of standard display units user settings.
     * @returns The default values for a full set of standard display units user settings.
     */
    private static getDefaultValues;
}

/**
 * Setting modes for weather map orientation.
 */
declare enum WeatherMapOrientationSettingMode {
    NorthUp = "NorthUp",
    TrackUp = "TrackUp",
    HeadingUp = "HeadingUp",
    DtkUp = "DtkUp",
    SyncToNavMap = "SyncToNavMap"
}
/**
 * Weather map user settings.
 */
type WeatherMapUserSettingTypes = {
    /** The weather map range index setting.  */
    weatherMapRangeIndex: number;
    /** The weather map orientation setting. */
    weatherMapOrientation: WeatherMapOrientationSettingMode;
};
/**
 * Connext weather map user settings.
 */
type ConnextMapUserSettingTypes = {
    /** Whether the Connext weather map radar overlay is enabled. */
    connextMapRadarOverlayShow: boolean;
    /** Connext radar overlay maximum range setting. */
    connextMapRadarOverlayRangeIndex: number;
};
/**
 * A utility class for working with weather map user settings.
 */
declare class WeatherMapUserSettingsUtils {
    /** An array of all generic weather map user setting names. */
    static readonly SETTING_NAMES: readonly (keyof WeatherMapUserSettingTypes)[];
    /** An array of all Connext weather map user setting names. */
    static readonly CONNEXT_SETTING_NAMES: readonly (keyof ConnextMapUserSettingTypes)[];
}

/**
 * A provider of wind data.
 */
interface WindDataProvider {
    /** The current wind direction, in degrees true. */
    readonly windDirection: Subscribable<number>;
    /**
     * The current wind direction relative to airplane heading, in degrees. A value of zero degrees indicates a direct
     * headwind, with positive angles proceeding clockwise.
     */
    readonly windDirectionRelative: Subscribable<number>;
    /** The current wind speed, in knots. */
    readonly windSpeed: Subscribable<number>;
    /** The current headwind component, in knots. Positive values indicate headwind, negative values indicate tailwind. */
    readonly headwind: Subscribable<number>;
    /**
     * The current crosswind component, in knots. Positive values indicate wind from the right, negative values indicate
     * wind from the left.
     */
    readonly crosswind: Subscribable<number>;
    /** The magnetic variation, in degrees, at the airplane's location. */
    readonly magVar: Subscribable<number>;
    /** Whether GPS position is in dead reckoning mode. */
    readonly isGpsDeadReckoning: Subscribable<boolean>;
    /** Whether this provider's wind data is in a failed state. */
    readonly isDataFailed: Subscribable<boolean>;
}
/**
 * A default implementation of {@link WindDataProvider}.
 */
declare class DefaultWindDataProvider implements WindDataProvider {
    private readonly bus;
    private readonly smoothingTau;
    private readonly accumulateTime;
    private static readonly DEFAULT_SMOOTHING_TAU;
    private static readonly DEFAULT_ACCUMULATE_TIME;
    /** The minimum true airspeed, in knots, required to provide valid wind data. */
    private static readonly MIN_TAS;
    private readonly _windDirection;
    /** @inheritdoc */
    readonly windDirection: Subscribable<number>;
    private readonly _windDirectionRelative;
    /** @inheritdoc */
    readonly windDirectionRelative: Subscribable<number>;
    private readonly _windSpeed;
    /** @inheritdoc */
    readonly windSpeed: Subscribable<number>;
    private readonly _headwind;
    /** @inheritdoc */
    readonly headwind: Subscribable<number>;
    private readonly _crosswind;
    /** @inheritdoc */
    readonly crosswind: Subscribable<number>;
    private readonly _magVar;
    /** @inheritdoc */
    readonly magVar: Subscribable<number>;
    private readonly _isGpsDeadReckoning;
    /** @inheritdoc */
    readonly isGpsDeadReckoning: Subscribable<boolean>;
    private readonly _isDataFailed;
    /** @inheritdoc */
    readonly isDataFailed: Subscribable<boolean>;
    private readonly windDirectionSource;
    private readonly windSpeedSource;
    private readonly isOnGround;
    private readonly tas;
    private readonly headingTrue;
    private readonly adcIndex;
    private readonly adcSystemState;
    private readonly isAdcDataValid;
    private readonly ahrsIndex;
    private readonly isHeadingDataValid;
    private readonly fmsPosIndex;
    private readonly fmsPosMode;
    private readonly directionSmoother;
    private readonly speedSmoother;
    private lastUpdateTime;
    private lastDeadTime;
    private isInit;
    private isAlive;
    private isPaused;
    private readonly pauseable;
    private adcIndexSub?;
    private ahrsIndexSub?;
    private fmsPosIndexSub?;
    private clockSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param adcIndex The index of the ADC that is the source of this provider's data.
     * @param ahrsIndex The index of the AHRS that is the source of this provider's data.
     * @param fmsPosIndex The index of the FMS geo-positioning system that is the source of this provider's data.
     * @param smoothingTau The smoothing time constant, in milliseconds, used to apply smoothing to wind speed and
     * direction. Defaults to {@link DefaultWindDataProvider.DEFAULT_SMOOTHING_TAU}.
     * @param accumulateTime The time required for this provider to accumulate enough source data to generate valid wind
     * data.
     */
    constructor(bus: EventBus, adcIndex: number | Subscribable<number>, ahrsIndex: number | Subscribable<number>, fmsPosIndex: number | Subscribable<number>, smoothingTau?: number, accumulateTime?: number);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Updates this data provider.
     * @param simTime The current simulation time, as a UNIX timestamp in milliseconds.
     */
    private update;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

declare enum TrafficOperatingModeSetting {
    Standby = "Standby",
    Operating = "Operating",
    Auto = "Auto",
    TAOnly = "TAOnly",
    Test = "Test"
}
declare enum TrafficAltitudeModeSetting {
    Below = "Below",
    Normal = "Normal",
    Above = "Above",
    Unrestricted = "Unrestricted"
}
declare enum TrafficMotionVectorModeSetting {
    Off = "Off",
    Absolute = "Absolute",
    Relative = "Relative"
}
/**
 * Traffic user settings.
 */
type TrafficUserSettingTypes = {
    /** The traffic system operating mode setting. */
    trafficOperatingMode: TrafficOperatingModeSetting;
    /** The ADS-B operating mode setting. */
    trafficAdsbEnabled: boolean;
    /** The traffic system altitude mode setting. */
    trafficAltitudeMode: TrafficAltitudeModeSetting;
    /** The traffic system relative altitude label setting.  */
    trafficAltitudeRelative: boolean;
    /** The traffic system motion vector mode setting. */
    trafficMotionVectorMode: TrafficMotionVectorModeSetting;
    /** The traffic system motion vector lookahead setting. */
    trafficMotionVectorLookahead: number;
};
/**
 * Utility class for retrieving traffic user setting managers.
 */
declare class TrafficUserSettings {
    private static INSTANCE;
    /**
     * Gets an instance of the traffic user settings manager.
     * @param bus The event bus.
     * @returns An instance of the traffic user settings manager.
     */
    static getManager(bus: EventBus): UserSettingManager<TrafficUserSettingTypes>;
}

/**
 * Types of Garmin traffic systems.
 */
declare enum TrafficSystemType {
    Tis = "TIS",
    Tas = "TAS",
    TcasII = "TCAS-II"
}

/**
 * A Garmin traffic system.
 */
interface TrafficSystem extends Tcas {
    /** The type of this traffic system. */
    readonly type: TrafficSystemType;
    /** The ADS-B system used by this traffic system, or `null` if this system does not support ADS-B. */
    readonly adsb: Adsb | null;
    /**
     * Checks whether this traffic system is powered.
     * @returns Whether this traffic system is powered.
     */
    isPowered(): boolean;
    /**
     * Sets whether this traffic system is powered.
     * @param isPowered Whether the system is powered.
     */
    setPowered(isPowered: boolean): void;
}

/**
 * A collection of common keys used by the GarminMap API.
 */
declare class GarminMapKeys {
    static readonly Units: "units";
    static readonly Range: "range";
    static readonly RangeRTR: "rangeRTR";
    static readonly UseRangeSetting: "useRangeSettingModerator";
    static readonly Orientation: "orientation";
    static readonly OrientationRTR: "orientationRTR";
    static readonly DesiredOrientation: "desiredOrientation";
    static readonly OrientationSettings: "orientationSettings";
    static readonly RotationModeControl: "rotationModeControlModerator";
    static readonly OrientationControl: "orientationControlModerator";
    static readonly DesiredOrientationControl: "desiredOrientationControl";
    static readonly Declutter: "declutter";
    static readonly Terrain: "terrain";
    static readonly Nexrad: "nexrad";
    static readonly RangeRing: "rangeRing";
    static readonly RangeCompass: "rangeCompass";
    static readonly Crosshair: "crosshair";
    static readonly WaypointDisplayBuilder: "waypointDisplayBuilder";
    static readonly WaypointsVisibility: "waypointsVis";
    static readonly RunwayVisibility: "runwayVisibility";
    static readonly RunwayLabelVisibility: "runwayLabelVisibility";
    static readonly WaypointHighlight: "waypointHighlight";
    static readonly WaypointHighlightLine: "waypointHighlightLine";
    static readonly WaypointHighlightRTR: "waypointHighlightRTR";
    static readonly FlightPlan: "garminFlightPlan";
    static readonly FlightPlanWaypoints: "flightPlanWaypoints";
    static readonly FlightPlanFocus: "flightPlanFocus";
    static readonly AirspaceVisibility: "airspaceVis";
    static readonly Traffic: "garminTraffic";
    static readonly TrafficRange: "trafficRange";
    static readonly Panning: "panning";
    static readonly PanningRTR: "panningRTR";
    static readonly Pointer: "pointer";
    static readonly PointerRTR: "pointerRTR";
    static readonly PointerInfo: "pointerInfo";
    static readonly TrackVector: "trackVector";
    static readonly WindVector: "windVector";
    static readonly MiniCompass: "miniCompass";
    static readonly WaypointSelection: "waypointSelection";
    static readonly WaypointRTR: "waypointRTR";
    static readonly Nearest: "nearest";
    static readonly ProcedurePreview: "procedurePreview";
    static readonly DataIntegrityRTR: "dataIntegrityRTR";
    static readonly DeadReckoning: "deadReckoning";
    static readonly TopLeftIndicators: "topLeftIndicators";
    static readonly TopRightIndicators: "topRightIndicators";
    static readonly BottomLeftIndicators: "bottomLeftIndicators";
    static readonly BottomCenterIndicators: "bottomCenterIndicators";
    static readonly BottomRightIndicators: "bottomRightIndicators";
    static readonly CenterIndicators: "centerIndicators";
}

/**
 * Airspace show types for Garmin maps.
 */
declare enum AirspaceShowType {
    ClassB = "ClassB",
    ClassC = "ClassC",
    ClassD = "ClassD",
    Restricted = "Restricted",
    MOA = "MOA",
    Other = "Other"
}
/**
 * A map of Garmin map airspace show types to their associated boundary filters.
 */
type GarminAirspaceShowTypes = Record<AirspaceShowType, number>;
/**
 * A utility class containing a map of Garmin map airspace show types to their associated boundary filters.
 */
declare class GarminAirspaceShowTypeMap {
    /** A map of Garmin map airspace show types to their associated boundary filters. */
    static readonly MAP: GarminAirspaceShowTypes;
}

declare enum MapDeclutterMode {
    All = 0,
    Level3 = 1,
    Level2 = 2,
    Level1 = 3
}
/**
 * A module describing the declutter mode.
 */
declare class MapDeclutterModule {
    readonly mode: Subject<MapDeclutterMode>;
}

/**
 * User settings controlling the visibility of map airspaces.
 */
type MapAirspaceVisUserSettings = Pick<MapUserSettingTypes, 'mapAirspaceClassBRangeIndex' | 'mapAirspaceClassBShow' | 'mapAirspaceClassCRangeIndex' | 'mapAirspaceClassCShow' | 'mapAirspaceClassDRangeIndex' | 'mapAirspaceClassDShow' | 'mapAirspaceMoaRangeIndex' | 'mapAirspaceMoaShow' | 'mapAirspaceRestrictedRangeIndex' | 'mapAirspaceRestrictedShow' | 'mapAirspaceOtherRangeIndex' | 'mapAirspaceOtherShow'>;
/**
 * Modules required for MapAirspaceVisController.
 */
interface MapAirspaceVisControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Airspace module. */
    [MapSystemKeys.Airspace]: MapAirspaceModule<GarminAirspaceShowTypes>;
    /** Declutter module. */
    [GarminMapKeys.Declutter]?: MapDeclutterModule;
}
/**
 * Controls the visibility of map airspace boundaries.
 */
declare class MapAirspaceVisController extends MapSystemController<MapAirspaceVisControllerModules> {
    private readonly airspaceModule;
    private readonly controllers;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param settingManager A setting manager containing the user settings controlling airspace visibility.
     */
    constructor(context: MapSystemContext<MapAirspaceVisControllerModules, any, any, any>, settingManager: UserSettingManager<Partial<MapAirspaceVisUserSettings>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Orientation types for a map.
 */
declare enum MapOrientation {
    NorthUp = 0,
    TrackUp = 1,
    HeadingUp = 2,
    DtkUp = 3
}
/**
 * A module describing the map orientation.
 */
declare class MapOrientationModule {
    /** The actual orientation of the map. */
    readonly orientation: Subject<MapOrientation>;
    /** The desired orientation of the map. */
    readonly desiredOrientation: Subject<MapOrientation>;
    /** The map orientation commanded by the user. */
    readonly commandedOrientation: Subject<MapOrientation>;
    /** Whether north up-above is active. */
    readonly northUpAboveActive: Subject<boolean>;
    /** The range index above which north up-above applies. */
    readonly northUpAboveRangeIndex: Subject<number>;
    /** Whether north up on ground is active. */
    readonly northUpOnGroundActive: Subject<boolean>;
}

/**
 * Modules required for MapDataIntegrityRTRController.
 */
interface MapDataIntegrityRTRControllerModules {
    /** Data integrity module. */
    [MapSystemKeys.DataIntegrity]: MapDataIntegrityModule;
    /** Orientation module. */
    [GarminMapKeys.Orientation]?: MapOrientationModule;
    /** Orientation module. */
    [MapSystemKeys.OwnAirplaneIcon]?: MapOwnAirplaneIconModule;
}
/**
 * Context properties required for MapDataIntegrityRTRController.
 */
interface MapDataIntegrityRTRControllerContext {
    /** Resource moderator for control of the map's projection target. */
    [MapSystemKeys.TargetControl]?: ResourceModerator;
    /** Resource moderator for control of the map's orientation mode. */
    [GarminMapKeys.OrientationControl]?: ResourceModerator;
}
/**
 * Controls the map's projected target, orientation mode, and player airplane icon based on heading and GPS signal validity.
 */
declare class MapDataIntegrityRTRController extends MapSystemController<MapDataIntegrityRTRControllerModules, any, any, MapDataIntegrityRTRControllerContext> {
    private readonly airplaneIconSrc?;
    private readonly airplaneIconAnchor?;
    private readonly normalIconSrc?;
    private readonly normalIconAnchor?;
    private readonly noHeadingIconSrc?;
    private readonly noHeadingIconAnchor?;
    private readonly dataIntegrityModule;
    private readonly orientationModule;
    private readonly ownAirplaneIconModule;
    private readonly targetControl;
    private readonly targetControlConsumer;
    private readonly orientationControl;
    private readonly orientationControlConsumer;
    private readonly canChangeAirplaneIcon;
    private orientationOverride?;
    private orientationOverridePipe?;
    private headingSignalSub?;
    private gpsSignalSub?;
    private normalIconSrcPipe?;
    private normalIconAnchorPipe?;
    private noHeadingIconSrcPipe?;
    private noHeadingIconAnchorPipe?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param airplaneIconSrc A mutable subscribable which controls the player airplane icon's image source URI.
     * Required for this controller to change the player airplane icon.
     * @param airplaneIconAnchor A mutable subscribable which controls the anchor point of the player airplane icon.
     * Required for this controller to change the player airplane icon.
     * @param normalIconSrc A subscribable which provides the URI of the normal player airplane icon's image source.
     * Required for this controller to change the player airplane icon.
     * @param normalIconAnchor A subscribable which provides the anchor point of the normal player airplane icon, as
     * `[x, y]`, where each component is relative to the width or height of the icon. Required for this controller to
     * change the player airplane icon.
     * @param noHeadingIconSrc A subscribable which provides the URI of the no-heading player airplane icon's image
     * source. Required for this controller to change the player airplane icon.
     * @param noHeadingIconAnchor A subscribable which provides the anchor point of the no-heading player airplane icon,
     * as `[x, y]`, where each component is relative to the width or height of the icon. Required for this controller to
     * change the player airplane icon.
     */
    constructor(context: MapSystemContext<MapDataIntegrityRTRControllerModules, any, any, MapDataIntegrityRTRControllerContext>, airplaneIconSrc?: MutableSubscribable<string, string> | undefined, airplaneIconAnchor?: MutableSubscribable<Readonly<Omit<Float64Array, "set" | "sort" | "copyWithin">>, Readonly<Omit<Float64Array, "set" | "sort" | "copyWithin">>> | undefined, normalIconSrc?: Subscribable<string> | undefined, normalIconAnchor?: Subscribable<Readonly<Omit<Float64Array, "set" | "sort" | "copyWithin">>> | undefined, noHeadingIconSrc?: Subscribable<string> | undefined, noHeadingIconAnchor?: Subscribable<Readonly<Omit<Float64Array, "set" | "sort" | "copyWithin">>> | undefined);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Changes the player airplane icon to the normal variety.
     */
    private setNormalAirplaneIcon;
    /**
     * Changes the player airplane icon to the no-heading variety.
     */
    private setNoHeadingAirplaneIcon;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapDesiredOrientationController.
 */
interface MapDesiredOrientationControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Orientation module. */
    [GarminMapKeys.Orientation]: MapOrientationModule;
    /** Own airplane props module. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
}
/**
 * Context properties required by MapDesiredOrientationController.
 */
interface MapDesiredOrientationControllerContext {
    /** Resource moderator for control of the map's desired orientation mode. */
    [GarminMapKeys.DesiredOrientationControl]: ResourceModerator;
}
/**
 * Controls the desired orientation of a map based on commanded orientation and auto-north up behavior.
 */
declare class MapDesiredOrientationController extends MapSystemController<MapDesiredOrientationControllerModules, any, any, MapDesiredOrientationControllerContext> {
    private readonly rangeModule;
    private readonly orientationModule;
    private readonly ownAirplanePropsModule;
    private readonly desiredOrientationControl;
    private readonly desiredOrientationControlConsumer;
    private orientation?;
    private orientationPipe?;
    private isPointerActiveSub?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A flight plan focus.
 */
type FlightPlanFocus = readonly LegDefinition[] | LatLonInterface | null;

/**
 * A provider of flight plan data for MapFlightPlanLayer.
 */
interface MapFlightPlanDataProvider {
    /** A subscribable which provides the flight plan to be displayed. */
    readonly plan: Subscribable<FlightPlan | null>;
    /** An event which notifies when the displayed plan has been modified. */
    readonly planModified: SubEventInterface<MapFlightPlanDataProvider, void>;
    /** An event which notifies when the displayed plan has been calculated.  */
    readonly planCalculated: SubEventInterface<MapFlightPlanDataProvider, void>;
    /**
     * A subscribable which provides the index of the active lateral leg of the displayed flight plan, or -1 if no such
     * leg exists.
     */
    readonly activeLateralLegIndex: Subscribable<number>;
    /**
     * A subscribable which provides LNAV data.
     */
    readonly lnavData: Subscribable<LNavTrackingState | undefined>;
    /** A subscribable which provides the current VNAV state. */
    readonly vnavState: Subscribable<VNavState>;
    /** A subscribable which provides the currently active VNAV path mode. */
    readonly vnavPathMode: Subscribable<VNavPathMode>;
    /**
     * A subscribable which provides the index of the leg within which the VNAV top-of-descent point lies, or -1 if no
     * such leg exists.
     */
    readonly vnavTodLegIndex: Subscribable<number>;
    /**
     * A subscribable which provides the index of the leg within which the VNAV bottom-of-descent point lies, or -1 if
     * no such leg exists.
     */
    readonly vnavBodLegIndex: Subscribable<number>;
    /**
     * A subscribable which provides the distance along the flight path from the VNAV top-of-descent point to the end
     * of the TOD leg.
     */
    readonly vnavTodLegDistance: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /**
     * A subscribable which provides the distance along the flight path from the plane's current position to the next
     * top-of-descent.
     */
    readonly vnavDistanceToTod: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /**
     * A subscribable which provides the index of the leg within which the VNAV top-of-climb point lies, or -1 if no
     * such leg exists.
     */
    readonly vnavTocLegIndex: Subscribable<number>;
    /**
     * A subscribable which provides the index of the leg within which the VNAV bottom-of-climb point lies, or -1 if
     * no such leg exists.
     */
    readonly vnavBocLegIndex: Subscribable<number>;
    /**
     * A subscribable which provides the distance along the flight path from the VNAV top-of-climb point to the end
     * of the TOC leg.
     */
    readonly vnavTocLegDistance: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /**
     * A subscribable which provides the distance along the flight path from the plane's current position to the next
     * top-of-climb.
     */
    readonly vnavDistanceToToc: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** A subscribable which provides the current OBS course, or undefined if OBS is not active. */
    readonly obsCourse: Subscribable<number | undefined>;
}

/**
 * Configuration options for {@link MapFlightPlannerPlanDataProvider}.
 */
type MapFlightPlannerPlanDataProviderOptions = {
    /** The flight planner from which to retrieve displayed flight plans. */
    flightPlanner: FlightPlanner | Subscribable<FlightPlanner | null>;
    /** The index of the LNAV from which to source LNAV tracking data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
};
/**
 * A map flight plan layer data provider that provides a displayed flight plan from a flight planner.
 */
declare class MapFlightPlannerPlanDataProvider implements MapFlightPlanDataProvider {
    private readonly bus;
    private readonly planner;
    private readonly _plan;
    /** @inheritDoc */
    readonly plan: Subscribable<FlightPlan | null>;
    /** @inheritDoc */
    readonly planModified: SubEvent<this, void>;
    /** @inheritDoc */
    readonly planCalculated: SubEvent<this, void>;
    private readonly _activeLateralLegIndex;
    /** @inheritDoc */
    readonly activeLateralLegIndex: Subscribable<number>;
    private readonly _lnavData;
    /** @inheritDoc */
    readonly lnavData: Subscribable<LNavTrackingState | undefined>;
    private readonly _vnavState;
    /** @inheritDoc */
    readonly vnavState: Subscribable<VNavState>;
    private readonly _vnavPathMode;
    /** @inheritDoc */
    readonly vnavPathMode: Subscribable<VNavPathMode>;
    private readonly _vnavTodLegIndex;
    /** @inheritDoc */
    readonly vnavTodLegIndex: Subscribable<number>;
    private readonly _vnavBodLegIndex;
    /** @inheritDoc */
    readonly vnavBodLegIndex: Subscribable<number>;
    private readonly _vnavTodLegDistance;
    /** @inheritDoc */
    readonly vnavTodLegDistance: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    private readonly _vnavDistanceToTod;
    /** @inheritDoc */
    readonly vnavDistanceToTod: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    private readonly _vnavTocLegIndex;
    /** @inheritDoc */
    readonly vnavTocLegIndex: Subscribable<number>;
    private readonly _vnavBocLegIndex;
    /** @inheritDoc */
    readonly vnavBocLegIndex: Subscribable<number>;
    private readonly _vnavTocLegDistance;
    /** @inheritDoc */
    readonly vnavTocLegDistance: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    private readonly _vnavDistanceToToc;
    /** @inheritDoc */
    readonly vnavDistanceToToc: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    private readonly _obsCourse;
    /** @inheritDoc */
    readonly obsCourse: Subscribable<number | undefined>;
    private readonly lnavIndex;
    private readonly vnavIndex;
    private readonly lnavDataSource;
    private readonly obsActiveSource;
    private readonly obsCourseSource;
    private readonly lnavSourceSubs;
    private readonly vnavTodLegIndexSource;
    private readonly vnavBodLegIndexSource;
    private readonly vnavTodLegDistanceSource;
    private readonly vnavDistanceToTodSource;
    private readonly vnavTocLegIndexSource;
    private readonly vnavBocLegIndexSource;
    private readonly vnavTocLegDistanceSource;
    private readonly vnavDistanceToTocSource;
    private readonly vnavSourceSubs;
    private planIndex;
    private isObsActive;
    private obsCourseValue;
    private readonly fplSubs;
    private readonly activePlanSubs;
    private isAlive;
    private readonly subscriptions;
    /**
     * Creates a new instance of MapFlightPlannerPlanDataProvider.
     * @param bus The event bus.
     * @param options Options with which to configure the data provider.
     */
    constructor(bus: EventBus, options: Readonly<MapFlightPlannerPlanDataProviderOptions>);
    /**
     * Creates a new instance of MapFlightPlannerPlanDataProvider.
     * @param bus The event bus.
     * @param flightPlanner The flight planner from which to retrieve displayed flight plans.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner);
    /**
     * Responds to when this provider's flight planner changes.
     * @param planner The new flight planner.
     */
    private onFlightPlannerChanged;
    /**
     * Responds to when this provider's LNAV index changes.
     * @param lnavEvents An event subscriber for LNAV events.
     * @param index The new LNAV index.
     */
    private onLNavIndexChanged;
    /**
     * Responds to when this provider's VNAV index changes.
     * @param vnavEvents An event subscriber for VNAV events.
     * @param index The new VNAV index.
     */
    private onVNavIndexChanged;
    /**
     * Sets the index of the displayed plan.
     * @param index The index of the displayed plan.
     * @throws Error if this data provider has been destroyed.
     */
    setPlanIndex(index: number): void;
    /**
     * Updates the displayed plan.
     */
    private updatePlan;
    /**
     * Updates subjects related to the active plan.
     */
    private updateActivePlanRelatedSubs;
    /**
     * Updates the active leg index.
     */
    private updateActiveLegIndex;
    /**
     * Updates the OBS course.
     */
    private updateObsCourse;
    /**
     * Destroys this data provider.
     */
    destroy(): void;
}

/**
 * A map flight plan layer data provider that provides the active flight plan from a flight planner to be displayed.
 */
declare class MapActiveFlightPlanDataProvider implements MapFlightPlanDataProvider {
    private readonly bus;
    private readonly planner;
    private readonly provider;
    /** @inheritDoc */
    readonly plan: Subscribable<_microsoft_msfs_sdk.FlightPlan | null>;
    /** @inheritDoc */
    readonly planModified: _microsoft_msfs_sdk.SubEvent<MapFlightPlannerPlanDataProvider, void>;
    /** @inheritDoc */
    readonly planCalculated: _microsoft_msfs_sdk.SubEvent<MapFlightPlannerPlanDataProvider, void>;
    /** @inheritDoc */
    readonly activeLateralLegIndex: Subscribable<number>;
    /** @inheritDoc */
    readonly lnavData: Subscribable<_microsoft_msfs_sdk.LNavTrackingState | undefined>;
    /** @inheritDoc */
    readonly vnavState: Subscribable<_microsoft_msfs_sdk.VNavState>;
    /** @inheritDoc */
    readonly vnavPathMode: Subscribable<_microsoft_msfs_sdk.VNavPathMode>;
    /** @inheritDoc */
    readonly vnavTodLegIndex: Subscribable<number>;
    /** @inheritDoc */
    readonly vnavBodLegIndex: Subscribable<number>;
    /** @inheritDoc */
    readonly vnavTodLegDistance: Subscribable<_microsoft_msfs_sdk.NumberUnitInterface<_microsoft_msfs_sdk.UnitFamily.Distance, _microsoft_msfs_sdk.Unit<_microsoft_msfs_sdk.UnitFamily.Distance>>>;
    /** @inheritDoc */
    readonly vnavDistanceToTod: Subscribable<_microsoft_msfs_sdk.NumberUnitInterface<_microsoft_msfs_sdk.UnitFamily.Distance, _microsoft_msfs_sdk.Unit<_microsoft_msfs_sdk.UnitFamily.Distance>>>;
    /** @inheritDoc */
    readonly vnavTocLegIndex: Subscribable<number>;
    /** @inheritDoc */
    readonly vnavBocLegIndex: Subscribable<number>;
    /** @inheritDoc */
    readonly vnavTocLegDistance: Subscribable<_microsoft_msfs_sdk.NumberUnitInterface<_microsoft_msfs_sdk.UnitFamily.Distance, _microsoft_msfs_sdk.Unit<_microsoft_msfs_sdk.UnitFamily.Distance>>>;
    /** @inheritDoc */
    readonly vnavDistanceToToc: Subscribable<_microsoft_msfs_sdk.NumberUnitInterface<_microsoft_msfs_sdk.UnitFamily.Distance, _microsoft_msfs_sdk.Unit<_microsoft_msfs_sdk.UnitFamily.Distance>>>;
    /** @inheritDoc */
    readonly obsCourse: Subscribable<number | undefined>;
    private readonly plannerSub;
    private fplIndexSub?;
    /**
     * Creates a new instance of MapActiveFlightPlanDataProvider.
     * @param bus The event bus.
     * @param options Options with which to configure the data provider.
     */
    constructor(bus: EventBus, options: Readonly<MapFlightPlannerPlanDataProviderOptions>);
    /**
     * Creates a new instance of MapActiveFlightPlanDataProvider.
     * @param bus The event bus.
     * @param flightPlanner The flight planner from which to retrieve displayed flight plans.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner);
    /**
     * Responds to when this provider's flight planner changes.
     * @param planner The new flight planner.
     */
    private onFlightPlannerChanged;
    /**
     * Destroys this data provider.
     */
    destroy(): void;
}

/**
 * Renders the path for flight plans to canvas.
 */
interface MapFlightPathPlanRenderer {
    /**
     * Renders a flight plan to a canvas.
     * @param plan The flight plan to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param renderEntirePlan Whether to render the entire plan. If false, only the active leg and legs after the active
     * leg will be rendered.
     * @param activeLegIndex The global index of the active flight plan leg, or -1 if there is no active leg.
     * @param lnavData LNAV tracking data for the flight plan to render, or undefined if LNAV is not tracking the flight
     * plan.
     * @param obsCourse The active OBS course, or undefined if OBS is not active.
     */
    render(plan: FlightPlan, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, renderEntirePlan: boolean, activeLegIndex: number, lnavData?: LNavTrackingState, obsCourse?: number): void;
}

/**
 * The default base-route flight plan renderer for Garmin maps. Only renders non-transition flight path vectors within
 * flight plan legs.
 */
declare class DefaultBaseFlightPathPlanRenderer extends AbstractFlightPathPlanRenderer {
    private readonly lineRenderer;
    private readonly dtoCourseRenderer;
    private readonly vtfRenderer;
    /** @inheritdoc */
    protected renderLeg(leg: LegDefinition, plan: FlightPlan, activeLeg: LegDefinition | undefined, legIndex: number, activeLegIndex: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack): void;
    /**
     * Selects a line style to render for a vector.
     * @param vector The vector for which to select a style.
     * @param isIngress Whether the vector is part of the ingress transition.
     * @param isEgress Whether the vector is part of the egress transition.
     * @param leg The flight plan leg containing the vector to render.
     * @param projection The map projection to use when rendering.
     * @param out The line style object to which to write the selected style.
     * @returns The selected line style for the vector.
     */
    private selectLineStyle;
    /**
     * Checks if a flight path vector should be styled as a roll-heading vector.
     * @param vector A flight path vector.
     * @param leg The flight plan leg to which the vector belongs.
     * @returns Whether the flight path vector should be styled as a roll-heading vector.
     */
    private isRollHeadingVector;
    /**
     * Checks whether a vector should be rendered as a heading vector.
     * @param leg The flight plan leg containing the vector.
     * @returns Whether the vector should be rendered as a heading vector.
     */
    private isHeadingVector;
}
/**
 * The default full-route flight plan renderer for Garmin maps. Renders all flight path vectors within flight plan legs,
 * including transition vectors.
 */
declare class DefaultFullFlightPathPlanRenderer extends AbstractFlightPathPlanRenderer<[lnavData: LNavTrackingState | undefined, isMissedApproachActive: boolean]> {
    private readonly defaultRenderer;
    private readonly holdRenderer;
    private readonly procTurnRenderer;
    private readonly dtoCourseRenderer;
    private readonly vtfRenderer;
    /** @inheritdoc */
    protected renderLeg(leg: LegDefinition, plan: FlightPlan, activeLeg: LegDefinition | undefined, legIndex: number, activeLegIndex: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, lnavData: LNavTrackingState | undefined, isMissedApproachActive: boolean): void;
}
/**
 * The default flight plan renderer for Garmin maps.
 */
declare class DefaultFlightPathPlanRenderer implements MapFlightPathPlanRenderer {
    private readonly baseRouteRenderer;
    private readonly fullRouteRenderer;
    private readonly obsRenderer;
    /** @inheritdoc */
    render(plan: FlightPlan, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, renderEntirePlan: boolean, activeLegIndex: number, lnavData?: LNavTrackingState, obsCourse?: number): void;
    /**
     * Gets the global index of the first leg for which to render the base route.
     * @param plan The flight plan to render.
     * @param renderEntirePlan Whether to render the entire plan.
     * @param activeLegIndex The global index of the active flight plan leg, or -1 if there is no active leg.
     * @param isObsActive Whether OBS is active.
     * @returns The global index of the first leg for which to render the base route.
     */
    private getBaseRouteStartIndex;
    /**
     * Gets the global index of the first leg for which to render the full route.
     * @param plan The flight plan to render.
     * @param renderEntirePlan Whether to render the entire plan.
     * @param activeLegIndex The global index of the active flight plan leg, or -1 if there is no active leg.
     * @returns The global index of the first leg for which to render the full route.
     */
    private getFullRouteStartIndex;
    /**
     * Gets the global index of the leg from which the active leg of a flight plan originates.
     * @param plan A flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @returns The global index of the leg from which the active leg originates, or -1 if one could not be found.
     */
    private getActiveFromLegIndex;
}

/**
 * Render roles for MapWaypointRenderer.
 */
declare enum MapWaypointRenderRole {
    /** A highlighted waypoint. */
    Highlight = 1,
    /** A waypoint which is the active waypoint in a flight plan. */
    FlightPlanActive = 2,
    /** A waypoint in a flight plan which is not the active waypoint. */
    FlightPlanInactive = 4,
    /** A normally displayed waypoint. */
    Normal = 8,
    /** A waypoint in an airway. */
    Airway = 16,
    /** A VNAV waypoint. */
    VNav = 32,
    /** A waypoint in a procedure preview plan. */
    ProcedurePreview = 64,
    /** A waypoint in a procedure transition preview plan. */
    ProcedureTransitionPreview = 128
}
/**
 * A renderer which draws waypoints to a Garmin-style map.
 */
declare class MapWaypointRenderer extends MapWaypointRenderer$1<Waypoint> {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     */
    constructor(textManager: MapCullableTextLabelManager);
}

/**
 * Manages flight plan waypoint records.
 */
interface MapFlightPlanWaypointRecordManager {
    /**
     * Checks whether this manager is busy with a waypoint refresh.
     * @returns Whether this manager is busy with a waypoint refresh.
     */
    isBusy(): boolean;
    /**
     * Refreshes this manager's waypoint records, keeping them up to date with a specified flight plan.
     * @param flightPlan A flight plan.
     * @param activeLegIndex The global index of the active flight plan leg, or -1 if there is no active leg.
     * @param repick Whether to repick waypoints.
     * @param startIndex The global index of the first flight plan leg from which to pick waypoints, inclusive. Defaults
     * to 0. Ignored if `repick` is false.
     * @param endIndex The global index of the last flight plan leg from which to pick waypoints, inclusive. Defaults to
     * `flightPlan.length - 1`. Ignored if `repick` is false.
     */
    refreshWaypoints(flightPlan: FlightPlan | null, activeLegIndex: number, repick: boolean, startIndex?: number, endIndex?: number): Promise<void>;
}

/**
 * Manages flight plan waypoint records.
 */
declare class MapDefaultFlightPlanWaypointRecordManager implements MapFlightPlanWaypointRecordManager {
    private readonly facLoader;
    private readonly facWaypointCache;
    private readonly waypointRenderer;
    private readonly inactiveRenderRole;
    private readonly activeRenderRole;
    private readonly legWaypointRecords;
    private _isBusy;
    /**
     * Creates a new instance of MapDefaultFlightPlanWaypointRecordManager.
     * @param facLoader This manager's facility loader.
     * @param facWaypointCache This manager's facility waypoint cache.
     * @param waypointRenderer This manager's waypoint renderer.
     * @param inactiveRenderRole The role(s) under which waypoints should be registered when they are part of an inactive
     * leg.
     * @param activeRenderRole The role(s) under which waypoints should be registered when they are part of an active
     * leg.
     */
    constructor(facLoader: FacilityLoader, facWaypointCache: FacilityWaypointCache, waypointRenderer: MapWaypointRenderer, inactiveRenderRole: MapWaypointRenderRole, activeRenderRole: MapWaypointRenderRole);
    /** @inheritDoc */
    isBusy(): boolean;
    /** @inheritDoc */
    refreshWaypoints(flightPlan: FlightPlan | null, activeLegIndex: number, repick: boolean, startIndex?: number, endIndex?: number): Promise<void>;
    /**
     * Creates a FlightPlanLegWaypointsRecord for a specified flight plan leg.
     * @param leg A flight plan leg.
     * @returns A FlightPlanLegWaypointsRecord for the specified flight plan leg.
     */
    private createLegWaypointsRecord;
}

/**
 * Renders the path for procedure previews to canvas.
 */
interface MapFlightPathProcRenderer {
    /**
     * Renders a procedure preview flight plan to a canvas.
     * @param plan The flight plan to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param isTransition Whether the rendered plan is a transition preview. Defaults to `false`.
     */
    render(plan: FlightPlan, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, isTransition?: boolean): void;
}

/**
 * Bitflags for flight path rendering styles.
 */
declare enum MapFlightPathStyleFlags {
    Prior = 1,
    Upcoming = 2,
    Active = 4,
    Next = 8,
    MissedApproach = 16,
    ActiveSegment = 32,
    RollHeading = 64,
    Heading = 128
}
/**
 * A utility class defining common Garmin styles for rendering flight paths.
 */
declare class MapFlightPathStyles {
    /** The stroke width, in pixels, for flight plan legs positioned after the active leg in the same segment as the active leg. */
    static readonly STROKE_WIDTH = 4;
    /** The stroke color for flight plan legs positioned after the active leg in the same segment as the active leg. */
    static readonly STROKE_COLOR = "white";
    /** The stroke width, in pixels, for the active flight plan leg. */
    static readonly ACTIVE_STROKE_WIDTH = 4;
    /** The stroke color for the active flight plan leg. */
    static readonly ACTIVE_STROKE_COLOR = "magenta";
    /** The stroke width, in pixels, for flight plan legs positioned before the active leg. */
    static readonly PRIOR_STROKE_WIDTH = 2;
    /** The stroke color for flight plan legs positioned before the active leg. */
    static readonly PRIOR_STROKE_COLOR = "#cccccc";
    /** The stroke width, in pixels, for flight plan legs in the missed approach segment while the missed approach is not active. */
    static readonly MISSED_APPROACH_STROKE_WIDTH = 1;
    /** The stroke color for flight plan legs in the missed approach segment while the missed approach is not active. */
    static readonly MISSED_APPROACH_STROKE_COLOR = "white";
    /** The base stroke width, in pixels, for flight plan legs. */
    static readonly BASE_STROKE_WIDTH = 2;
    /** The base stroke color for flight plan legs. */
    static readonly BASE_STROKE_COLOR = "rgba(204, 204, 204, 0.5)";
    /** The stroke width, in pixels, for procedure transition preview legs. */
    static readonly TRANSITION_STROKE_WIDTH = 2;
    /** The stroke color for procedure transition preview legs. */
    static readonly TRANSITION_STROKE_COLOR = "#666666";
    /** The stroke width, in pixels, for roll-heading vectors rendered as dashes. */
    static readonly ROLL_HEADING_DASH_STROKE_WIDTH = 2;
    /** The dash array for roll-heading vectors rendered as dashes. */
    static readonly ROLL_HEADING_DASH_ARRAY: number[];
    /** The width of the background for magenta arrows. */
    static readonly MAGENTA_ARROW_BG_WIDTH = 6;
    /** The background color for magenta arrows. */
    static readonly MAGENTA_ARROW_BG_COLOR = "rgba(40, 40, 40, 0.5)";
}

/**
 * A map range and target solution to fit a flight plan focus.
 */
type MapFlightPlanFocusRangeTarget = MapFieldOfView;
/**
 * Calculates map projection parameters to fit flight plan foci.
 */
declare class MapFlightPlanFocusCalculator {
    private readonly mapProjection;
    private readonly fovCalculator;
    private readonly pointHeap;
    /**
     * Constructor.
     * @param mapProjection This calculator's map projection.
     */
    constructor(mapProjection: MapProjection);
    /**
     * Calculates a maximum range and target center for a given flight plan focus such that the terminators of all legs
     * in the focus are visible in this calculator's map projection. If there is only one leg terminator in the specified
     * focus, the calculated range will be equal to 0. If a range and target could not be calculated, NaN will be written
     * to the results.
     * @param focus The array of legs on which to focus.
     * @param margins The margins around the projected map boundaries to respect. Expressed as [left, top, right, bottom].
     * @param ppos The current position of the airplane.
     * @param out The object to which to write the results.
     * @returns The calculated range and target for the specified focus.
     */
    calculateRangeTarget(focus: FlightPlanFocus, margins: Float64Array, ppos: LatLonInterface, out: MapFlightPlanFocusRangeTarget): MapFlightPlanFocusRangeTarget;
}

/**
 * A record of waypoints associated with a flight plan leg. Each record is responsible for keeping its waypoints up to
 * date with any relevant changes to its associated leg and registering its waypoints with a waypoint renderer.
 */
interface FlightPlanLegWaypointsRecord {
    /** The flight plan leg associated with this record. */
    readonly leg: LegDefinition;
    /**
     * Refreshes this record's waypoints, keeping them up to date with this record's associated flight plan leg.
     * @param isActive Whether this record's leg is the active leg.
     */
    refresh(isActive: boolean): Promise<void>;
    /**
     * Destroys this record. Deregisters all this record's waypoints with this record's waypoint renderer.
     */
    destroy(): void;
}
/**
 * An abstract implementation of FlightPlanLegWaypointsRecord.
 */
declare abstract class AbstractFlightPlanLegWaypointsRecord implements FlightPlanLegWaypointsRecord {
    readonly leg: LegDefinition;
    protected readonly waypointRenderer: MapWaypointRenderer;
    protected readonly facLoader: FacilityLoader;
    protected readonly inactiveRenderRole: MapWaypointRenderRole;
    protected readonly activeRenderRole: MapWaypointRenderRole;
    private static uidSource;
    protected uid: string;
    protected isActive: boolean;
    /**
     * Constructor.
     * @param leg The flight plan leg associated with this record.
     * @param waypointRenderer The renderer used to render this record's waypoints.
     * @param facLoader The facility loader used by this waypoint.
     * @param inactiveRenderRole The role(s) under which the waypoint should be registered when it is part of an inactive
     * leg.
     * @param activeRenderRole The role(s) under which the waypoint should be registered when it is part of an active
     * leg.
     */
    constructor(leg: LegDefinition, waypointRenderer: MapWaypointRenderer, facLoader: FacilityLoader, inactiveRenderRole: MapWaypointRenderRole, activeRenderRole: MapWaypointRenderRole);
    /** @inheritdoc */
    abstract refresh(isActive: boolean): Promise<void>;
    /** @inheritdoc */
    abstract destroy(): void;
    /**
     * Registers a waypoint with this record's waypoint renderer.
     * @param waypoint A waypoint.
     * @param role The role(s) under which the waypoint should be registered.
     */
    protected registerWaypoint(waypoint: Waypoint, role: MapWaypointRenderRole): void;
    /**
     * Removes a registration for a waypoint from this record's waypoint renderer.
     * @param waypoint A waypoint.
     * @param role The role(s) from which the waypoint should be deregistered.
     */
    protected deregisterWaypoint(waypoint: Waypoint, role: MapWaypointRenderRole): void;
}
/**
 * A record with a single waypoint based on its flight plan leg's fixIcao property.
 */
declare class FixIcaoWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
    protected readonly facWaypointCache: FacilityWaypointCache;
    protected _waypoint: FacilityWaypoint | null;
    /**
     * Constructor.
     * @param leg The flight plan leg associated with this record.
     * @param waypointRenderer The renderer used to render this record's waypoints.
     * @param facLoader The facility loader used by this waypoint.
     * @param facWaypointCache The facility waypoint cache used by this record.
     * @param inactiveRenderRole The role(s) under which the waypoint should be registered when it is part of an inactive
     * leg.
     * @param activeRenderRole The role(s) under which the waypoint should be registered when it is part of an active
     * leg.
     */
    constructor(leg: LegDefinition, waypointRenderer: MapWaypointRenderer, facLoader: FacilityLoader, facWaypointCache: FacilityWaypointCache, inactiveRenderRole: MapWaypointRenderRole, activeRenderRole: MapWaypointRenderRole);
    /**
     * This record's waypoint.
     */
    get waypoint(): FacilityWaypoint | null;
    /** @inheritdoc */
    refresh(isActive: boolean): Promise<void>;
    /**
     * Gets a facility waypoint from an ICAO string.
     * @param icao A facility ICAO string.
     * @returns a facility waypoint, or null if one could not be created.
     */
    private getFacilityWaypoint;
    /** @inheritdoc */
    destroy(): void;
}
/**
 * A record with a single flight path waypoint representing its flight plan leg's terminator fix.
 */
declare class FlightPathTerminatorWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
    private static id;
    protected readonly id: number;
    protected _waypoint: FlightPathWaypoint | null;
    protected _waypointLocation?: GeoPointSubject;
    /**
     * This record's flight path waypoint.
     */
    get waypoint(): FlightPathWaypoint | null;
    /** @inheritdoc */
    refresh(isActive: boolean): Promise<void>;
    /** @inheritdoc */
    destroy(): void;
    /**
     * Deregisters this record's waypoint, if it exists, from the waypoint renderer.
     */
    private cleanUpWaypoint;
}
/**
 * A record for procedure turn (PI) legs. Maintains two waypoints, both located at the PI leg's origin fix. The first
 * waypoint is a standard FacilityWaypoint which is never rendered in an active flight plan waypoint role. The second
 * is a ProcedureTurnWaypoint with an ident string equal to the PI leg's given name and which can be rendered in an
 * active flight plan waypoint role.
 */
declare class ProcedureTurnLegWaypointsRecord extends AbstractFlightPlanLegWaypointsRecord {
    private fixIcaoRecord;
    private ptWaypoint;
    /**
     * Constructor.
     * @param leg The flight plan leg associated with this record.
     * @param waypointRenderer The renderer used to render this record's waypoints.
     * @param facLoader The facility loader used by this waypoint.
     * @param facWaypointCache The facility waypoint cache used by this record.
     * @param inactiveRenderRole The role(s) under which the waypoint should be registered when it is part of an inactive
     * leg.
     * @param activeRenderRole The role(s) under which the waypoint should be registered when it is part of an active
     * leg.
     */
    constructor(leg: LegDefinition, waypointRenderer: MapWaypointRenderer, facLoader: FacilityLoader, facWaypointCache: FacilityWaypointCache, inactiveRenderRole: MapWaypointRenderRole, activeRenderRole: MapWaypointRenderRole);
    /** @inheritdoc */
    refresh(isActive: boolean): Promise<void>;
    /** @inheritdoc */
    destroy(): void;
}
/**
 * A waypoint marking a procedure turn leg.
 */
declare class ProcedureTurnLegWaypoint extends CustomWaypoint {
    readonly ident: string;
    static readonly UID_PREFIX = "PI";
    /**
     * Constructor.
     * @param waypoint The facility waypoint marking this waypoint's location.
     * @param ident The ident string of this waypoint.
     */
    constructor(waypoint: FacilityWaypoint, ident: string);
}

/**
 * A {@link MapFlightPlanDataProvider} which provides data for a standalone flight plan not owned by a flight planner.
 */
declare class MapStandaloneFlightPlanPlanDataProvider implements MapFlightPlanDataProvider {
    readonly plan: Subscribable<FlightPlan | null>;
    /** @inheritdoc */
    readonly planModified: SubEvent<this, void>;
    /** @inheritdoc */
    readonly planCalculated: SubEvent<this, void>;
    private readonly _activeLateralLegIndex;
    /** @inheritdoc */
    readonly activeLateralLegIndex: Subscribable<number>;
    /** @inheritdoc */
    readonly lnavData: Subscribable<LNavTrackingState | undefined>;
    /** @inheritdoc */
    readonly vnavState: Subscribable<VNavState>;
    /** @inheritdoc */
    readonly vnavPathMode: Subscribable<VNavPathMode>;
    /** @inheritdoc */
    readonly vnavTodLegIndex: Subscribable<number>;
    /** @inheritdoc */
    readonly vnavBodLegIndex: Subscribable<number>;
    /** @inheritdoc */
    readonly vnavTodLegDistance: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** @inheritdoc */
    readonly vnavDistanceToTod: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** @inheritdoc */
    readonly vnavTocLegIndex: Subscribable<number>;
    /** @inheritdoc */
    readonly vnavBocLegIndex: Subscribable<number>;
    /** @inheritdoc */
    readonly vnavTocLegDistance: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** @inheritdoc */
    readonly vnavDistanceToToc: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** @inheritdoc */
    readonly obsCourse: Subscribable<number | undefined>;
    private oldPlan;
    private readonly planSub;
    /**
     * Constructor.
     * @param plan A subscribable which provides the flight plan for this data provider.
     */
    constructor(plan: Subscribable<FlightPlan | null>);
    /**
     * Destroys this data provider.
     */
    destroy(): void;
}

/**
 * The full-route renderer for procedure preview flight plan paths. Renders all flight path vectors within flight plan
 * legs, including transition vectors, with support for different styles for procedure and transition previews.
 */
declare class ProcMapFullFlightPathPlanRenderer extends AbstractFlightPathPlanRenderer<[isTransition: boolean]> {
    private readonly lineRenderer;
    private readonly defaultRenderer;
    private readonly defaultTransitionRenderer;
    private readonly holdRenderer;
    private readonly procTurnRenderer;
    private readonly vtfRenderer;
    /** @inheritdoc */
    protected renderLeg(leg: LegDefinition, plan: FlightPlan, activeLeg: LegDefinition | undefined, legIndex: number, activeLegIndex: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, isTransition: boolean): void;
    /**
     * Selects a line style for a vector in a transition preview leg.
     * @param vector The vector for which to select a style.
     * @param isIngress Whether the vector is part of the ingress transition.
     * @param isEgress Whether the vector is part of the egress transition.
     * @param leg The flight plan leg containing the vector to render.
     * @param projection The map projection to use when rendering.
     * @param out The line style object to which to write the selected style.
     * @returns The selected line style for the vector.
     */
    private selectTransitionLineStyle;
    /**
     * Checks if a flight path vector in a transition preview leg should be styled as a roll-heading vector.
     * @param vector A flight path vector in a transition preview leg.
     * @param leg The flight plan leg to which the vector belongs.
     * @returns Whether the flight path vector should be styled as a roll-heading vector.
     */
    private isRollHeadingVector;
}
/**
 * The default procedure preview renderer for Garmin maps.
 */
declare class ProcMapFlightPathPlanRenderer implements MapFlightPathProcRenderer {
    private readonly baseRouteRenderer;
    private readonly fullRouteRenderer;
    /** @inheritdoc */
    render(plan: FlightPlan, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, isTransition?: boolean): void;
}

/**
 * Manages transition preview waypoint records.
 */
declare class ProcMapTransitionWaypointRecordManager {
    private readonly facLoader;
    private readonly facWaypointCache;
    private readonly waypointRenderer;
    private readonly renderRole;
    private readonly legWaypointRecords;
    private _isBusy;
    /**
     * Constructor.
     * @param facLoader This manager's facility loader.
     * @param facWaypointCache This manager's facility waypoint cache.
     * @param waypointRenderer This manager's waypoint renderer.
     * @param renderRole The role(s) under which waypoints should be registered.
     */
    constructor(facLoader: FacilityLoader, facWaypointCache: FacilityWaypointCache, waypointRenderer: MapWaypointRenderer, renderRole: MapWaypointRenderRole);
    /**
     * Checks whether this manager is busy with a waypoint refresh.
     * @returns Whether this manager is busy with a waypoint refresh.
     */
    isBusy(): boolean;
    /**
     * Refreshes this manager's waypoint records, keeping them up to date with a specified flight plan.
     * @param flightPlan A flight plan.
     * @param repick Whether to repick waypoints.
     * @param pickPosition The position within each transition from which to pick waypoints. Ignored if `repick` is
     * false. Defaults to `first`.
     */
    refreshWaypoints(flightPlan: FlightPlan | null, repick: boolean, pickPosition?: 'first' | 'last'): Promise<void>;
    /**
     * Picks the first waypoint in each transition to display.
     * @param flightPlan The transition preview flight plan.
     * @param legsToDisplay A set of legs from which to display waypoints.
     */
    private pickFirst;
    /**
     * Picks the last waypoint in each transition to display.
     * @param flightPlan The transition preview flight plan.
     * @param legsToDisplay A set of legs from which to display waypoints.
     */
    private pickLast;
    /**
     * Creates a FlightPlanLegWaypointsRecord for a specified flight plan leg.
     * @param leg A flight plan leg.
     * @returns A FlightPlanLegWaypointsRecord for the specified flight plan leg.
     */
    private createLegWaypointsRecord;
}

/**
 *
 */
declare class MapFlightPlanFocusModule {
    /**
     * Whether focus is active.
     */
    readonly isActive: Subject<boolean>;
    /**
     * Whether the flight plan has focus.
     */
    readonly planHasFocus: Subject<boolean>;
    /**
     * The flight plan focus.
     */
    readonly focus: Subject<FlightPlanFocus>;
    /**
     * A flight plan data provider for the plan which has focus, or `null`. A data provider is required to update
     * a flight plan leg focus after its component legs have been calculated for the first time.
     */
    readonly dataProvider: Subject<MapFlightPlanDataProvider | null>;
}

/**
 * A module which defines display units.
 */
declare class MapUnitsModule {
    private readonly unitsSettingManager?;
    /** Distance units mode. */
    readonly distanceMode: Subscribable<UnitsDistanceSettingMode>;
    /** Altitude units mode. */
    readonly altitudeMode: Subscribable<UnitsAltitudeSettingMode>;
    /** Nav angle units mode. */
    readonly navAngleMode: Subscribable<UnitsNavAngleSettingMode>;
    /** Nav angle units. */
    readonly navAngle: Subscribable<NavAngleUnit>;
    /** Large distance units. */
    readonly distanceLarge: Subscribable<Unit<UnitFamily.Distance>>;
    /** Small distance units. */
    readonly distanceSmall: Subscribable<Unit<UnitFamily.Distance>>;
    /**
     * Constructor.
     * @param unitsSettingManager A display units user setting manager.
     */
    constructor(unitsSettingManager?: UnitsUserSettingManager<UnitsUserSettingTypes> | undefined);
}

/**
 * Modules required for MapRangeController.
 */
interface MapRangeControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Display units module. */
    [GarminMapKeys.Units]?: MapUnitsModule;
}
/**
 * User settings required by MapRangeController.
 */
type MapRangeControllerSettings = {
    /** The range setting. */
    mapRangeIndex?: number;
};
/**
 * Controls map range.
 */
declare class MapRangeController extends MapSystemController<MapRangeControllerModules> {
    private readonly nauticalRangeArray?;
    private readonly metricRangeArray?;
    private readonly useSetting?;
    private readonly rangeModule;
    private readonly distanceUnitsMode;
    private readonly rangeSetting?;
    private distanceModeSub?;
    private settingSub?;
    private useSettingSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param nauticalRangeArray The map range array this controller sets for nautical distance mode. If not defined,
     * this controller will not change the range array when entering nautical distance mode.
     * @param metricRangeArray The map range array this controller sets for metric distance mode. If not defined, this
     * controller will not change the range array when entering metric distance mode.
     * @param settingManager A setting manager containing the map range index setting. If not defined, map range will
     * be set directly through the map model.
     * @param useSetting A subscribable which provides whether to control map range via the user setting. If not defined,
     * map range will always be controlled via the user setting. Ignored if `settingManager` is undefined.
     */
    constructor(context: MapSystemContext<MapRangeControllerModules, any, any, any>, nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance, _microsoft_msfs_sdk.Unit<UnitFamily.Distance>>[] | undefined, metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance, _microsoft_msfs_sdk.Unit<UnitFamily.Distance>>[] | undefined, settingManager?: UserSettingManager<MapRangeControllerSettings>, useSetting?: Subscribable<boolean> | undefined);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Sets the map range index. If the index is out of bounds, it will be clamped before being set.
     * @param index The index to set.
     * @param bypassUserSetting Whether to bypass the map range index user setting, if one is defined for
     * this controller, and set the range index directly on the map range module. Defaults to `false`.
     * @returns The index that was set.
     */
    setRangeIndex(index: number, bypassUserSetting?: boolean): number;
    /**
     * Changes the map range index by a given amount. If the change results in an index that is out of bounds, it will
     * be clamped before being set.
     * @param delta The change to apply to the index.
     * @param bypassUserSetting Whether to bypass the map range index user setting, if one is defined for
     * this controller, and change the range index directly on the map range module. Defaults to `false`.
     * @returns The final index that was set.
     */
    changeRangeIndex(delta: number, bypassUserSetting?: boolean): number;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapFlightPlanFocusRTRController.
 */
interface MapFlightPlanFocusRTRControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Own airplane props module. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
    /** Flight plan focus module. */
    [GarminMapKeys.FlightPlanFocus]: MapFlightPlanFocusModule;
    /** Orientation module. */
    [GarminMapKeys.Orientation]?: MapOrientationModule;
}
/**
 * Required controllers for MapFlightPlanFocusRTRController.
 */
interface MapFlightPlanFocusRTRControllerControllers {
    /** Range controller. */
    [GarminMapKeys.Range]: MapRangeController;
}
/**
 * Required context properties for MapFlightPlanFocusRTRController.
 */
interface MapFlightPlanFocusRTRControllerContext {
    /** Resource moderator for control of the map's projection target. */
    [MapSystemKeys.TargetControl]?: ResourceModerator;
    /** Resource moderator for control of the map's desired orientation mode. */
    [GarminMapKeys.DesiredOrientationControl]?: ResourceModerator;
    /** Resource moderator for the use range setting subject. */
    [GarminMapKeys.UseRangeSetting]?: ResourceModerator<Subject<boolean>>;
}
/**
 * Controls the pointer of a map.
 */
declare class MapFlightPlanFocusRTRController extends MapSystemController<MapFlightPlanFocusRTRControllerModules, any, MapFlightPlanFocusRTRControllerControllers, MapFlightPlanFocusRTRControllerContext> {
    private readonly nominalFocusMargins;
    private readonly defaultFocusRangeIndex;
    private readonly focusDebounceDelay;
    private static readonly DEFAULT_FOCUS_DEBOUNCE_DELAY;
    private readonly rangeModule;
    private readonly ownAirplanePropsModule;
    private readonly focusModule;
    private readonly orientationModule;
    protected readonly mapTargetParam: {
        target: GeoPoint;
    };
    private readonly hasTargetControl;
    private readonly hasRangeSettingControl;
    private readonly canActivateFocus;
    private readonly targetControl;
    private readonly targetControlConsumer;
    private readonly desiredOrientationControl;
    private readonly desiredOrientationControlConsumer;
    private readonly useRangeSetting;
    private readonly useRangeSettingConsumer;
    private readonly focusMargins;
    private readonly isPlanFocusValid;
    private readonly isFocusActive;
    private readonly focusCalculator;
    private readonly focusRangeTarget;
    private readonly focusDebounceTimer;
    private isFocusActiveSub?;
    private focusSub?;
    private isFocusActivePipe?;
    private dataProviderSub?;
    private planCalculatedSub?;
    private rangeArraySub?;
    private readonly focusMarginsSub;
    private isRangeTargetUpdatePending;
    private readonly pendRangeTargetUpdate;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param nominalFocusMargins A subscribable which provides the nominal focus margins, as
     * `[left, top, right, bottom]` in pixels. The nominal margins define the offset of the boundaries of the focus
     * region relative to the map's projected window, *excluding* the dead zone. Positive values represent offsets
     * toward the center of the window. When the flight plan is focused, the focused elements of the plan are guaranteed
     * to be contained within the focus region.
     * @param defaultFocusRangeIndex The default map range index to apply when the flight plan focus consists of only a
     * single point in space.
     * @param focusDebounceDelay The debounce delay, in milliseconds, to apply to focus target calculations when the
     * flight plan focus changes. Defaults to 500 milliseconds.
     */
    constructor(context: MapSystemContext<MapFlightPlanFocusRTRControllerModules, any, any, MapFlightPlanFocusRTRControllerContext>, nominalFocusMargins: Subscribable<ReadonlyFloat64Array>, defaultFocusRangeIndex: number, focusDebounceDelay?: number);
    /** @inheritdoc */
    onDeadZoneChanged(): void;
    /**
     * Updates the flight plan focus margins.
     */
    private updateFocusMargins;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Responds to changes in whether the current flight plan focus is valid.
     * @param isValid Whether the current flight plan focus is valid.
     */
    private onIsPlanFocusValidChanged;
    /**
     * Responds to changes in whether flight plan focus is active.
     * @param isActive Whether flight plan focus is active.
     */
    private onIsFocusActiveChanged;
    /**
     * Activates or deactivates flight plan focus listeners.
     * @param isActive Whether to activate flight plan focus listeners.
     */
    private setFlightPlanFocusListenersActive;
    /**
     * Responds to changes in the flight plan focus.
     */
    private onFlightPlanFocusChanged;
    /**
     * Responds to changes in the flight plan focus data provider.
     * @param dataProvider The new flight plan focus data provider.
     */
    private onDataProviderChanged;
    /**
     * A callback which is called when the flight plan is calculated.
     */
    private onFlightPlanCalculated;
    /**
     * Schedules an update of the map target and range from the current flight plan focus after a debounce delay.
     */
    private schedulePendRangeTargetUpdate;
    /**
     * Updates the map target and range from the current flight plan focus.
     */
    private updateRangeTargetFromFocus;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onBeforeUpdated(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A module describing the state of a Garmin autopilot.
 */
declare class MapGarminAutopilotPropsModule extends MapAutopilotPropsModule {
    /** Whether automatic adjustment of selected heading during a turn is active. */
    readonly isTurnHdgAdjustActive: Subject<boolean>;
    /** Whether HDG sync mode is active. */
    readonly isHdgSyncModeActive: Subject<boolean>;
    /** An event that is triggered when the selected heading is changed manually. */
    readonly manualHeadingSelect: SubEvent<void, void>;
}

/**
 * Modules required for MapGarminAutopilotPropsController.
 */
interface MapGarminAutopilotPropsControllerModules {
    /** Autopilot properties. */
    [MapSystemKeys.AutopilotProps]: MapGarminAutopilotPropsModule;
}
/**
 * A key for a property in {@link MapGarminAutopilotPropsModule}.
 */
type MapGarminAutopilotPropsKey = Extract<keyof MapGarminAutopilotPropsModule, string>;
/**
 * A definition of a binding between a property in {@link MapGarminAutopilotPropsModule} and an event bus topic.
 */
type MapGarminAutopilotPropsBinding = {
    /** The key of the property to bind. */
    key: MapGarminAutopilotPropsKey;
    /** The event bus topic to which to bind the property. */
    topic: string;
};
/**
 * Binds the properties in a {@link MapGarminAutopilotPropsModule} to event bus topics.
 */
declare class MapGarminAutopilotPropsController extends MapSystemController<MapGarminAutopilotPropsControllerModules> {
    private readonly properties;
    private readonly module;
    private readonly updateFreq?;
    private readonly subs;
    private updateFreqSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq The update frequency, in hertz. If not defined, the properties will be updated every frame.
     */
    constructor(context: MapSystemContext<MapGarminAutopilotPropsControllerModules>, properties: Iterable<MapGarminAutopilotPropsKey | MapGarminAutopilotPropsBinding>, updateFreq?: number | Subscribable<number>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     * @throws Error if the property is invalid.
     */
    private bindProperty;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Information on a vector associated with a nominal LNAV desired track.
 */
type LNavDataDtkVector = {
    /** The global index of the flight plan leg to which the vector belongs, or `-1` if there is no vector. */
    globalLegIndex: number;
    /** The index of the vector in its parent leg's `flightPath` array, or `-1` if there is no vector. */
    vectorIndex: number;
};
/**
 * Valid CDI scale labels for the LVar scale enum.
 */
declare enum CDIScaleLabel {
    Departure = 0,
    Terminal = 1,
    TerminalDeparture = 2,
    TerminalArrival = 3,
    Enroute = 4,
    Oceanic = 5,
    LNav = 6,
    LNavPlusV = 7,
    Visual = 8,
    LNavVNav = 9,
    LP = 10,
    LPPlusV = 11,
    LPV = 12,
    RNP = 13,
    Approach = 14,
    MissedApproach = 15,
    VfrEnroute = 16,
    VfrTerminal = 17,
    VfrApproach = 18
}
/**
 * Events related to Garmin LNAV data keyed by base topic names.
 */
interface BaseLNavDataEvents extends BaseLNavDataEvents$1 {
    /** The nominal desired track at the beginning of the flight plan leg following the currently tracked leg, in degrees true. */
    lnavdata_next_dtk_true: number;
    /** The nominal desired track at the beginning of the flight plan leg following the currently tracked leg, in degrees magnetic. */
    lnavdata_next_dtk_mag: number;
    /** The current CDI scale label. */
    lnavdata_cdi_scale_label: CDIScaleLabel;
    /** The nominal along-track distance remaining to the egress transition of the currently tracked flight plan leg, in nautical miles. */
    lnavdata_egress_distance: number;
    /** The nominal TO/FROM flag. */
    lnavdata_tofrom: VorToFrom;
    /** The ICAO of the active flight plan destination, or the empty ICAO if there is no destination. */
    lnavdata_destination_icao: IcaoValue;
    /** The ident of the active flight plan destination, or the empty string if there is no destination. */
    lnavdata_destination_ident: string;
    /** The ICAO of the active flight plan destination runway, or the empty ICAO if there is no destination runway. */
    lnavdata_destination_runway_icao: IcaoValue;
    /** Information on the nominal current desired track vector. */
    lnavdata_dtk_vector: Readonly<LNavDataDtkVector>;
    /** Information on the nominal next desired track vector. */
    lnavdata_next_dtk_vector: Readonly<LNavDataDtkVector>;
    /** Whether OBS mode can be activated on the current active flight plan leg. */
    obs_available: boolean;
}
/**
 * Events related to Garmin LNAV keyed by indexed topic names.
 */
type IndexedLNavDataEvents<Index extends number = number> = {
    [P in keyof BaseLNavDataEvents as `${P}_${Index}`]: BaseLNavDataEvents[P];
};
/**
 * Events related to Garmin LNAV.
 */
interface LNavDataEvents extends BaseLNavDataEvents, IndexedLNavDataEvents {
}

/**
 * ADS-B Conflict Situational Awareness (CSA) sensitivity parameters.
 */
declare class AdsbSensitivityParameters {
    private static readonly TA_LEVELS;
    /**
     * Selects a sensitivity level for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(altitude: NumberUnitInterface<UnitFamily.Distance>, cdiScalingLabel?: CDIScaleLabel, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): number;
    /**
     * Selects Traffic Advisory sensitivity settings for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity settings for the specified environment.
     */
    selectTA(altitude: NumberUnitInterface<UnitFamily.Distance>, cdiScalingLabel: CDIScaleLabel, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): TcasTcaParameters;
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level: number): TcasTcaParameters;
}

/**
 * A Garmin ADS-B system.
 */
declare class GarminAdsb extends Adsb {
    private readonly adsbEnabledSetting;
    /** @inheritdoc */
    init(): void;
}

/**
 * An intruder tracked by Garmin traffic systems.
 */
declare class GarminTcasIntruder extends AbstractTcasIntruder {
    private readonly simTime;
    private _taOnTime;
    /**
     * The sim time, as a UNIX timestamp in milliseconds, at which this intruder's alert level was most recently switched
     * to Traffic Advisory from another alert level.
     */
    get taOnTime(): number;
    private _taOffTime;
    /**
     * The sim time, as a UNIX timestamp in milliseconds, at which this intruder's alert level was most recently switched
     * from Traffic Advisory to another alert level.
     */
    get taOffTime(): number;
    private lastAlertLevel;
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     * @param simTime A subscribable which provides the current sim time, as a UNIX timestamp in milliseconds.
     */
    constructor(contact: TrafficContact, simTime: Subscribable<number>);
    /**
     * Responds to changes in this intruder's alert level.
     * @param alertLevel The new alert level.
     */
    private onAlertLevelChanged;
}

/**
 * Garmin TCAS-II.
 */
declare class GarminTcasII extends Tcas<GarminTcasIntruder, GarminTcasIISensitivity> implements TrafficSystem {
    readonly adsb: GarminAdsb | null;
    static readonly DEFAULT_MAX_INTRUDER_COUNT = 40;
    static readonly DEFAULT_REAL_TIME_UPDATE_FREQ = 2;
    static readonly DEFAULT_SIM_TIME_UPDATE_FREQ = 1;
    private static readonly TA_ON_HYSTERESIS;
    private static readonly TA_OFF_HYSTERESIS;
    readonly type = TrafficSystemType.TcasII;
    private cdiScalingLabel;
    private readonly _isPowered;
    private readonly operatingModeSetting;
    private readonly operatingModeState;
    private readonly raAltitudeInhibitFlag;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param adsb The ADS-B system associated with this TCAS, or `null` if this TCAS does not support ADS-B.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS. Defaults to
     * {@link GarminTcasII.DEFAULT_MAX_INTRUDER_COUNT}.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time. Defaults to
     * {@link GarminTcasII.DEFAULT_REAL_TIME_UPDATE_FREQ}.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time. Defaults to
     * {@link GarminTcasII.DEFAULT_SIM_TIME_UPDATE_FREQ}.
     */
    constructor(bus: EventBus, tfcInstrument: TrafficInstrument, adsb: GarminAdsb | null, maxIntruderCount?: number, realTimeUpdateFreq?: number, simTimeUpdateFreq?: number);
    /** @inheritdoc */
    protected createSensitivity(): GarminTcasIISensitivity;
    /** @inheritdoc */
    init(): void;
    /** @inheritdoc */
    isPowered(): boolean;
    /** @inheritdoc */
    setPowered(isPowered: boolean): void;
    /** @inheritdoc */
    protected createIntruderEntry(contact: TrafficContact): GarminTcasIntruder;
    /** @inheritdoc */
    protected updateSensitivity(): void;
    /** @inheritdoc */
    protected canIssueTrafficAdvisory(simTime: number, intruder: GarminTcasIntruder): boolean;
    /** @inheritdoc */
    protected canCancelTrafficAdvisory(simTime: number, intruder: GarminTcasIntruder): boolean;
}
/**
 * An implementation of {@link TcasSensitivity} which provides sensitivity parameters for the Garmin TCAS-II. When
 * ADS-B is operating, Traffic Advisory sensitivity is selected based on the ADS-B Conflict Situational Awareness (CSA)
 * algorithm. When ADS-B is not operating, Traffic Advisory sensitivity is selected based on the TCAS-II algorithm.
 * Resolution Advisory sensitivity is always determined by the TCAS-II algorithm.
 */
declare class GarminTcasIISensitivity implements TcasSensitivity {
    private readonly tcasIISensitivity;
    private readonly adsbSensitivity;
    private readonly tcasIIParams;
    private readonly adsbParams;
    private tcasIILevel;
    private adsbLevel;
    private activeParams;
    /** @inheritdoc */
    selectParameters(): TcasSensitivityParameters;
    /** @inheritdoc */
    selectRAAlim(): NumberUnitInterface<UnitFamily.Distance>;
    /**
     * Updates the sensitivity without ADS-B support.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    update(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Updates the sensitivity with ADS-B support.
     * @param adsbMode The ADS-B operating mode.
     * @param altitude The indicated altitude of the own airplane.
     * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    update(adsbMode: AdsbOperatingMode, altitude: NumberUnitInterface<UnitFamily.Distance>, cdiScalingLabel: CDIScaleLabel | undefined, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): void;
}

/**
 * A manager which reconciles the operating modes of the active transponder and the Garmin TCAS-II traffic system.
 * The manager ensures that any time the active transponder is set to a non-altitude reporting mode, TCAS-II is set to
 * standby mode, and anytime TCAS-II is set to a non-standby mode, the active transponder is set to altitude reporting
 * mode.
 */
declare class GarminXpdrTcasManager {
    private readonly bus;
    private readonly controlPublisher;
    private readonly activeXpdrIndex;
    private readonly xpdrMode;
    private readonly trafficOperatingModeSetting;
    private xpdrIndexSub?;
    private xpdrModeSub?;
    private trafficModeSub?;
    private isAlive;
    private isInit;
    private isPaused;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param activeXpdrIndex The index of the active transponder.
     */
    constructor(bus: EventBus, activeXpdrIndex: number | Subscribable<number>);
    /**
     * Initializes this manager. This will perform an immediate reconciliation of transponder and TCAS operating modes
     * (the transponder mode takes precedence), and from this point on the manager will keep the two modes in a valid
     * state until it is destroyed.
     * @param paused Whether to initialize this manager as paused.
     * @throws Error if this manager has been destroyed.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this manager. Once this manager is resumed, it will automatically reconcile TCAS operating and transponder
     * modes.
     * @throws Error if this manager has been destroyed.
     */
    resume(): void;
    /**
     * Pauses this manager. Once this manager is paused, it will no longer automatically reconcile TCAS operating and
     * transponder modes until resumed.
     * @throws Error if this manager has been destroyed.
     */
    pause(): void;
    /**
     * Resets this manager. Sets the TCAS operating mode to AUTO and the transponder mode to ALT reporting. Has no effect
     * if this manager is not initialized.
     * @throws Error if this manager has been destroyed.
     */
    reset(): void;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * A provider of TCAS-II resolution advisory vertical speed commands.
 */
interface TcasRaCommandDataProvider {
    /**
     * The minimum allowed vertical speed, in feet per minute, commanded by the current resolution advisory, or `null`
     * if there is no such value.
     */
    readonly raMinVs: Subscribable<number | null>;
    /**
     * The maximum allowed vertical speed, in feet per minute, commanded by the current resolution advisory, or `null`
     * if there is no such value.
     */
    readonly raMaxVs: Subscribable<number | null>;
    /**
     * The lower bound vertical speed, in feet per minute, of the current resolution advisory's fly-to command, or
     * `null` if there is no such value.
     */
    readonly raFlyToMinVs: Subscribable<number | null>;
    /**
     * The upper bound vertical speed, in feet per minute, of the current resolution advisory's fly-to command, or
     * `null` if there is no such value.
     */
    readonly raFlyToMaxVs: Subscribable<number | null>;
}
/**
 * A default implementation of {@link TcasRaCommandDataProvider}.
 */
declare class DefaultTcasRaCommandDataProvider implements TcasRaCommandDataProvider {
    private readonly bus;
    readonly tcas: Tcas;
    private readonly _raMinVs;
    /** @inheritdoc */
    readonly raMinVs: Subscribable<number | null>;
    private readonly _raMaxVs;
    /** @inheritdoc */
    readonly raMaxVs: Subscribable<number | null>;
    private readonly _raFlyToMinVs;
    /** @inheritdoc */
    readonly raFlyToMinVs: Subscribable<number | null>;
    private readonly _raFlyToMaxVs;
    /** @inheritdoc */
    readonly raFlyToMaxVs: Subscribable<number | null>;
    private isInit;
    private isAlive;
    private isPaused;
    private readonly tcasRaSubs;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tcas The TCAS which from which this data provider sources resolution advisory commands.
     */
    constructor(bus: EventBus, tcas: Tcas);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider has been destroyed.
     */
    init(paused?: boolean): void;
    /**
     * Update vertical speeds commanded by TCAS resolution advisories.
     */
    private updateRaSpeeds;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider has been destroyed.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider has been destroyed.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Garmin Traffic Advisory System (TAS).
 */
declare class TrafficAdvisorySystem extends Tcas<GarminTcasIntruder, TasSensitivity> implements TrafficSystem {
    readonly adsb: GarminAdsb | null;
    private readonly supportsRadarAltitude;
    static readonly DEFAULT_MAX_INTRUDER_COUNT = 30;
    static readonly DEFAULT_REAL_TIME_UPDATE_FREQ = 2;
    static readonly DEFAULT_SIM_TIME_UPDATE_FREQ = 1;
    private static readonly TA_ON_HYSTERESIS;
    private static readonly TA_OFF_HYSTERESIS;
    readonly type = TrafficSystemType.Tas;
    private readonly _isPowered;
    private readonly operatingModeSetting;
    private readonly operatingModeState;
    private cdiScalingLabel;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TAS.
     * @param adsb The ADS-B system associated with this TAS, or `null` if this TAS does not support ADS-B.
     * @param supportsRadarAltitude Whether this TAS supports radar altitude.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TAS. Defaults to
     * {@link TrafficAdvisorySystem.DEFAULT_MAX_INTRUDER_COUNT}.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time. Defaults to
     * {@link TrafficAdvisorySystem.DEFAULT_REAL_TIME_UPDATE_FREQ}.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time. Defaults to
     * {@link TrafficAdvisorySystem.DEFAULT_SIM_TIME_UPDATE_FREQ}.
     */
    constructor(bus: EventBus, tfcInstrument: TrafficInstrument, adsb: GarminAdsb | null, supportsRadarAltitude: boolean, maxIntruderCount?: number, realTimeUpdateFreq?: number, simTimeUpdateFreq?: number);
    /** @inheritdoc */
    protected createSensitivity(): TasSensitivity;
    /** @inheritdoc */
    init(): void;
    /** @inheritdoc */
    isPowered(): boolean;
    /** @inheritdoc */
    setPowered(isPowered: boolean): void;
    /** @inheritdoc */
    protected createIntruderEntry(contact: TrafficContact): GarminTcasIntruder;
    /** @inheritdoc */
    protected updateSensitivity(): void;
    /** @inheritdoc */
    protected canIssueTrafficAdvisory(simTime: number, intruder: GarminTcasIntruder): boolean;
    /** @inheritdoc */
    protected canCancelTrafficAdvisory(simTime: number, intruder: GarminTcasIntruder): boolean;
}
/**
 * Garmin TAS sensitivity settings.
 */
declare class TasSensitivityParameters {
    private static readonly PA;
    private static readonly TA_LEVELS;
    /**
     * Selects a sensitivity level for a specified environment.
     * @param groundSpeed The ground speed of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(groundSpeed: NumberUnitInterface<UnitFamily.Speed>, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): number;
    /**
     * Selects Proximity Advisory sensitivity settings for a specified environment.
     * @param groundSpeed The ground speed of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity settings for the specified environment.
     */
    selectPA(groundSpeed: NumberUnitInterface<UnitFamily.Speed>, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): TcasAdvisoryParameters;
    /**
     * Selects Traffic Advisory sensitivity settings for a specified environment.
     * @param groundSpeed The ground speed of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity settings for the specified environment.
     */
    selectTA(groundSpeed: NumberUnitInterface<UnitFamily.Speed>, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): TcasTcaParameters;
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    getPA(level: number): TcasAdvisoryParameters;
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level: number): TcasTcaParameters;
}
/**
 * An implementation of {@link TcasSensitivity} which provides sensitivity parameters for the Garmin Traffic Advisory
 * System (TAS). When ADS-B is operating, Traffic Advisory sensitivity is selected based on the ADS-B Conflict
 * Situational Awareness (CSA) algorithm. When ADS-B is not operating, Traffic Advisory sensitivity is selected based
 * on the TAS algorithm.
 */
declare class TasSensitivity implements TcasSensitivity {
    private readonly adsbTASensitivity;
    private readonly tasSensitivity;
    private readonly tasParams;
    private readonly adsbParams;
    private activeParams;
    /** @inheritdoc */
    selectParameters(): TcasSensitivityParameters;
    /** @inheritdoc */
    selectRAAlim(): NumberUnitInterface<UnitFamily.Distance>;
    /**
     * Updates the sensitivity without ADS-B support.
     * @param groundSpeed The ground speed of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    update(groundSpeed: NumberUnitInterface<UnitFamily.Speed>, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Updates the sensitivity with ADS-B support.
     * @param adsbMode The ADS-B operating mode.
     * @param altitude The indicated altitude of the own airplane.
     * @param groundSpeed The ground speed of the own airplane.
     * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    update(adsbMode: AdsbOperatingMode, altitude: NumberUnitInterface<UnitFamily.Distance>, groundSpeed: NumberUnitInterface<UnitFamily.Speed>, cdiScalingLabel?: CDIScaleLabel, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): void;
}

/**
 * Configuration options for {@link TrafficInfoService}.
 */
type TrafficInfoServiceOptions = {
    /** Whether the TIS supports radar altitude. Defaults to `false`. */
    supportRadarAltitude?: boolean;
    /**
     * The maximum number of intruders tracked at any one time by the TIS when ADS-B is not available. Defaults to
     * {@link TrafficInfoService.DEFAULT_MAX_INTRUDER_COUNT}.
     */
    maxIntruderCount?: number;
    /**
     * The maximum update frequency (Hz) in real time when ADS-B is not available. Defaults to
     * {@link TrafficInfoService.DEFAULT_REAL_TIME_UPDATE_FREQ}.
     */
    realTimeUpdateFreq?: number;
    /**
     * The maximum update frequency (Hz) in sim time when ADS-B is not available. Defaults to
     * {@link TrafficInfoService.DEFAULT_SIM_TIME_UPDATE_FREQ}.
     */
    simTimeUpdateFreq?: number;
    /**
     * The ADS-B system associated with the TIS, or `null` if the TIS does not support ADS-B.
     */
    adsb?: GarminAdsb | null;
    /**
     * The maximum number of intruders tracked at any one time by the TIS when ADS-B is available. Defaults to
     * {@link TrafficInfoService.DEFAULT_ADSB_MAX_INTRUDER_COUNT}.
     */
    adsbMaxIntruderCount?: number;
    /**
     * The maximum update frequency (Hz) in real time when ADS-B is available. Defaults to
     * {@link TrafficInfoService.DEFAULT_ADSB_REAL_TIME_UPDATE_FREQ}.
     */
    adsbRealTimeUpdateFreq?: number;
    /**
     * The maximum update frequency (Hz) in sim time when ADS-B is available. Defaults to
     * {@link TrafficInfoService.DEFAULT_ADSB_SIM_TIME_UPDATE_FREQ}.
     */
    adsbSimTimeUpdateFreq?: number;
    /**
     * Whether the ADS-B traffic alerting algorithm supports using GPS phase of flight information to select sensitivity
     * levels. Ignored if ADS-B is not supported. Defaults to `false`.
     */
    supportGpsFlightPhase?: boolean;
};
/**
 * Garmin Traffic Information Service.
 */
declare class TrafficInfoService extends Tcas<GarminTcasIntruder, TisSensitivity> implements TrafficSystem {
    static readonly DEFAULT_MAX_INTRUDER_COUNT = 8;
    static readonly DEFAULT_REAL_TIME_UPDATE_FREQ = 2;
    static readonly DEFAULT_SIM_TIME_UPDATE_FREQ = 0.2;
    static readonly DEFAULT_ADSB_MAX_INTRUDER_COUNT = 30;
    static readonly DEFAULT_ADSB_REAL_TIME_UPDATE_FREQ = 2;
    static readonly DEFAULT_ADSB_SIM_TIME_UPDATE_FREQ = 1;
    private static readonly MAX_INTRUDER_ALTITUDE_BELOW;
    private static readonly MAX_INTRUDER_ALTITUDE_ABOVE;
    private static readonly MAX_INTRUDER_DISTANCE;
    private static readonly TA_ON_HYSTERESIS;
    private static readonly TA_OFF_HYSTERESIS;
    /** @inheritdoc */
    readonly type: TrafficSystemType;
    /** @inheritdoc */
    readonly adsb: GarminAdsb | null;
    private readonly supportsRadarAltitude;
    private readonly _isPowered;
    private readonly operatingModeSetting;
    private readonly operatingModeState;
    private readonly supportsGpsFlightPhase;
    private cdiScalingLabel?;
    /**
     * Creates a new instance of TrafficInfoService.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for the TIS.
     * @param supportRadarAltitude Whether the TIS supports radar altitude.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by the TIS. Defaults to
     * {@link TrafficInfoService.DEFAULT_MAX_INTRUDER_COUNT}.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time. Defaults to
     * {@link TrafficInfoService.DEFAULT_REAL_TIME_UPDATE_FREQ}.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time. Defaults to
     * {@link TrafficInfoService.DEFAULT_SIM_TIME_UPDATE_FREQ}.
     */
    constructor(bus: EventBus, tfcInstrument: TrafficInstrument, supportRadarAltitude: boolean, maxIntruderCount?: number, realTimeUpdateFreq?: number, simTimeUpdateFreq?: number);
    /**
     * Creates a new instance of TrafficInfoService.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for the TIS.
     * @param options Options with which to configure the TIS.
     */
    constructor(bus: EventBus, tfcInstrument: TrafficInstrument, options?: Readonly<TrafficInfoServiceOptions>);
    /** @inheritdoc */
    protected createSensitivity(): TisSensitivity;
    /** @inheritdoc */
    init(): void;
    /** @inheritdoc */
    isPowered(): boolean;
    /** @inheritdoc */
    setPowered(isPowered: boolean): void;
    /** @inheritdoc */
    protected createIntruderEntry(contact: TrafficContact): GarminTcasIntruder;
    /** @inheritdoc */
    protected filterIntruder(intruder: GarminTcasIntruder): boolean;
    /** @inheritdoc */
    protected updateSensitivity(): void;
    /** @inheritdoc */
    protected canIssueTrafficAdvisory(simTime: number, intruder: GarminTcasIntruder): boolean;
    /** @inheritdoc */
    protected canCancelTrafficAdvisory(simTime: number, intruder: GarminTcasIntruder): boolean;
}
/**
 * Garmin TIS sensitivity settings.
 */
declare class TisSensitivityParameters {
    private static readonly PA;
    private static readonly TA_LEVELS;
    /**
     * Selects a sensitivity level for a specified environment.
     * @param groundSpeed The ground speed of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(groundSpeed: NumberUnitInterface<UnitFamily.Speed>, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): number;
    /**
     * Selects Proximity Advisory sensitivity settings for a specified environment.
     * @param groundSpeed The ground speed of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity settings for the specified environment.
     */
    selectPA(groundSpeed: NumberUnitInterface<UnitFamily.Speed>, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): TcasAdvisoryParameters;
    /**
     * Selects Traffic Advisory sensitivity settings for a specified environment.
     * @param groundSpeed The ground speed of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity settings for the specified environment.
     */
    selectTA(groundSpeed: NumberUnitInterface<UnitFamily.Speed>, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): TcasTcaParameters;
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    getPA(level: number): TcasAdvisoryParameters;
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level: number): TcasTcaParameters;
}
/**
 * An implementation of {@link TcasSensitivity} which provides sensitivity parameters for the Garmin Traffic
 * Information Service.
 */
declare class TisSensitivity implements TcasSensitivity {
    private readonly adsbTASensitivity;
    private readonly tisSensitivity;
    private readonly tisParams;
    private readonly adsbParams;
    private activeParams;
    /** @inheritdoc */
    selectParameters(): TcasSensitivityParameters;
    /** @inheritdoc */
    selectRAAlim(): NumberUnitInterface<UnitFamily.Distance>;
    /**
     * Updates the sensitivity without ADS-B support.
     * @param groundSpeed The ground speed of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    update(groundSpeed: NumberUnitInterface<UnitFamily.Speed>, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Updates the sensitivity with ADS-B support.
     * @param adsbMode The ADS-B operating mode.
     * @param altitude The indicated altitude of the own airplane.
     * @param groundSpeed The ground speed of the own airplane.
     * @param cdiScalingLabel The CDI scaling sensitivity of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    update(adsbMode: AdsbOperatingMode, altitude: NumberUnitInterface<UnitFamily.Distance>, groundSpeed: NumberUnitInterface<UnitFamily.Speed>, cdiScalingLabel?: CDIScaleLabel, radarAltitude?: NumberUnitInterface<UnitFamily.Distance>): void;
}

/**
 * A manager for automatically changing traffic system operating mode on takeoff and landing.
 */
declare class TrafficOperatingModeManager {
    private readonly bus;
    private readonly takeoffDelay;
    private readonly landingDelay;
    private readonly operatingMode;
    private static readonly DEFAULT_TAKEOFF_DELAY;
    private static readonly DEFAULT_LANDING_DELAY;
    private readonly trafficSettingManager;
    private readonly operatingModeSetting;
    private readonly isOnGround;
    private hasFirstOnGroundValue;
    private operatingArmed;
    private standbyArmed;
    private readonly operatingModeChangeTimer;
    private isAlive;
    private isInit;
    private isPaused;
    private operatingModeSub?;
    private isOnGroundSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param takeoffDelay The delay, in seconds, after takeoff before this manager switches the traffic system to its
     * operating mode. Defaults to {@link TrafficOperatingModeManager.DEFAULT_TAKEOFF_DELAY}.
     * @param landingDelay The delay, in seconds, after landing before this manager switches the traffic system to its
     * standby mode. Defaults to {@link TrafficOperatingModeManager.DEFAULT_LANDING_DELAY}.
     * @param operatingMode The traffic system operating mode that is automatically set by this manager after takeoff.
     * Defaults to {@link TrafficOperatingModeSetting.Operating}.
     */
    constructor(bus: EventBus, takeoffDelay?: number, landingDelay?: number, operatingMode?: TrafficOperatingModeSetting);
    /**
     * Initializes this manager. Once this manager is initialized, it will automatically change traffic system operating
     * mode on takeoff and landing. Additionally, at the time of initialization, the traffic system will be set to
     * operate if the airplane is already in the air.
     * @param paused Whether to initialize this manager as paused.
     * @throws Error if this manager has been destroyed.
     */
    init(paused?: boolean): void;
    /**
     * A callback which is called when whether own airplane is on the ground changes.
     * @param isOnGround Whether own airplane is on the ground.
     */
    private onGroundChanged;
    /**
     * Schedules a delayed operating mode change.
     * @param toMode The target operating mode.
     * @param delay The delay, in milliseconds.
     */
    private scheduleOperatingModeChange;
    /**
     * Cancels the currently scheduled operating mode change, if one exists.
     */
    private cancelOperatingModeChange;
    /**
     * Resumes this manager. Once this manager is resumed, it will automatically change traffic system operating
     * mode on takeoff and landing.
     * @throws Error if this manager has been destroyed.
     */
    resume(): void;
    /**
     * Pauses this manager. Once this manager is paused, it will no longer automatically change traffic system operating
     * mode on takeoff and landing until resumed.
     * @throws Error if this manager has been destroyed.
     */
    pause(): void;
    /**
     * Resets this manager. Sets the traffic systems operating mode to standby and arms (but does not schedule) the
     * transition to operating or standby modes based on whether the airplane is currently on the ground or in the air.
     * Has no effect if this manager is not initialized.
     * @throws Error if this manager has been destroyed.
     */
    reset(): void;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * Traffic alert level modes.
 */
declare enum MapTrafficAlertLevelMode {
    All = 0,
    Advisories = 1,
    TA_RA = 2,
    RA = 3
}
/**
 * Traffic motion vector modes.
 */
declare enum MapTrafficMotionVectorMode {
    Off = 0,
    Absolute = 1,
    Relative = 2
}
/**
 * Traffic display altitude restriction modes.
 */
declare enum MapTrafficAltitudeRestrictionMode {
    Unrestricted = 0,
    Above = 1,
    Normal = 2,
    Below = 3
}
/**
 * A module describing the display of traffic.
 */
declare class MapGarminTrafficModule {
    readonly trafficSystem: TrafficSystem;
    /** Whether to show traffic information. */
    readonly show: Subject<boolean>;
    /** The TCAS operating mode. */
    readonly operatingMode: Subscribable<TcasOperatingMode>;
    /** The ADS-B operating mode. */
    readonly adsbOperatingMode: Subscribable<AdsbOperatingMode>;
    /** Whether to show intruder labels. */
    readonly showIntruderLabel: Subject<boolean>;
    /** The index of the outer ring range. */
    readonly outerRangeIndex: Subject<number>;
    /** The index of the inner ring range. */
    readonly innerRangeIndex: Subject<number>;
    /** The alert level mode. */
    readonly alertLevelMode: Subject<MapTrafficAlertLevelMode>;
    /** The altitude restriction mode. */
    readonly altitudeRestrictionMode: Subject<MapTrafficAltitudeRestrictionMode>;
    /** Whether displayed intruder altitude is relative. */
    readonly isAltitudeRelative: Subject<boolean>;
    /** The motion vector mode. */
    readonly motionVectorMode: Subject<MapTrafficMotionVectorMode>;
    /** The motion vector mode. */
    readonly motionVectorLookahead: NumberUnitSubject<_microsoft_msfs_sdk.UnitFamily.Duration, _microsoft_msfs_sdk.SimpleUnit<_microsoft_msfs_sdk.UnitFamily.Duration>>;
    /**
     * Constructor.
     * @param trafficSystem This module's associated traffic system.
     */
    constructor(trafficSystem: TrafficSystem);
}

/**
 * User settings controlling the visibility of map airspaces.
 */
type MapTrafficUserSettings = Pick<MapUserSettingTypes, 'mapTrafficShow' | 'mapTrafficRangeIndex' | 'mapTrafficAlertLevelMode' | 'mapTrafficLabelShow' | 'mapTrafficLabelRangeIndex'>;
/**
 * Modules required for MapGarminTrafficController.
 */
interface MapGarminTrafficControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]?: MapIndexedRangeModule;
    /** Garmin traffic module. */
    [GarminMapKeys.Traffic]: MapGarminTrafficModule;
}
/**
 * Controls the display of traffic on a map based on user settings.
 */
declare class MapGarminTrafficController extends MapSystemController<MapGarminTrafficControllerModules> {
    private static readonly ALT_MODE_MAP;
    private static readonly MOTION_VECTOR_MODE_MAP;
    private static readonly ALERT_LEVEL_MODE_MAP;
    private readonly garminTrafficModule;
    private readonly altitudeModeSetting;
    private readonly altitudeRelativeSetting;
    private readonly motionVectorModeSetting;
    private readonly motionVectorLookaheadSetting;
    private readonly alertLevelModeSetting;
    private altitudeModeSettingPipe?;
    private altitudeRelativeSettingPipe?;
    private motionVectorModeSettingPipe?;
    private motionVectorLookaheadSettingSub?;
    private iconVisController?;
    private labelVisController?;
    private alertLevelModePipe?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param trafficSettingManager A user settings manager containing traffic settings.
     * @param mapSettingManager A user settings manager containing map traffic settings. If not defined, the display of
     * traffic will not be bound to map traffic user settings.
     */
    constructor(context: MapSystemContext<MapGarminTrafficControllerModules, any, any, any>, trafficSettingManager: UserSettingManager<Partial<TrafficUserSettingTypes>>, mapSettingManager?: UserSettingManager<Partial<MapTrafficUserSettings>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A module for map weather radar mode data.
 */
declare class MapNexradModule {
    /** Whether to show the NEXRAD overlay. */
    readonly showNexrad: Subject<boolean>;
    /**
     * The color array for the NEXRAD overlay. Each entry `E_i` of the array is a tuple `[color, rate]` that defines a
     * color stop, where `color` is an RGBA color expressed as `R + G * 256 + B * 256^2 + A * 256^3` and `rate` is a
     * precipitation rate in millimeters per hour.
     *
     * In general, the color defined by `E_i` is applied to precipitation rates ranging from the rate defined by `E_i-1`
     * to the rate defined by `E_i`. There are two special cases. The color defined by `E_0` is applied to the
     * precipitation rates from zero to the rate defined by `E_0`. The color defined by `E_n-1`, where `n` is the length
     * of the array, is applied to the precipitation rates from the rate defined by `E_n-2` to positive infinity.
     */
    readonly colors: Subject<readonly (readonly [number, number])[]>;
}

/**
 * User settings controlling the display of NEXRAD.
 */
type MapNexradUserSettings = Pick<MapUserSettingTypes, 'mapNexradShow' | 'mapNexradRangeIndex'>;
/**
 * Modules required by {@link MapNexradController}.
 */
interface MapNexradControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Range module. */
    [GarminMapKeys.Nexrad]: MapNexradModule;
    /** Declutter module. */
    [GarminMapKeys.Declutter]?: MapDeclutterModule;
}
/**
 * Controls the display of NEXRAD based on user settings.
 */
declare class MapNexradController extends MapSystemController<MapNexradControllerModules> {
    private readonly minRangeIndex;
    private readonly maxDeclutterMode;
    private readonly nexradModule;
    private readonly rangeIndex;
    private readonly declutterMode;
    private readonly showSetting?;
    private readonly rangeIndexSetting;
    private show?;
    /**
     * Creates a new instance of MapNexradController.
     * @param context This controller's map context.
     * @param minRangeIndex The minimum range range index, inclusive, at which NEXRAD is visible.
     * @param settingManager A setting manager containing the user settings controlling the display of NEXRAD. If not
     * defined, the display of NEXRAD will not be bound to user settings.
     * @param maxDeclutterMode The highest global declutter mode, inclusive, at which NEXRAD is visible. Defaults to
     * `MapDeclutterMode.Level2`. Ignored if `settingManager` is not defined.
     */
    constructor(context: MapSystemContext<MapNexradControllerModules, any, any, any>, minRangeIndex: number, settingManager?: UserSettingManager<Partial<MapNexradUserSettings>>, maxDeclutterMode?: MapDeclutterMode);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A module for the map crosshair.
 */
declare class MapCrosshairModule {
    readonly show: Subject<boolean>;
}

/**
 * A map module describing the integrity states of various data sources for Garmin maps.
 */
declare class MapGarminDataIntegrityModule extends MapDataIntegrityModule {
    /** Whether or not airplane position data is derived from dead reckoning. */
    readonly isDeadReckoning: Subject<boolean>;
}

/**
 * An entry describing a flight plan to display on a map.
 */
type MapGarminFlightPlanEntry = {
    /** The ID of this entry. */
    id: string;
    /** Whether to show this entry's flight plan. */
    show: Subject<boolean>;
    /** A data provider for this entry's flight plan. */
    dataProvider: MapFlightPlanDataProvider;
    /** Whether this entry's flight plan should be drawn in its entirety instead of only from the active lateral leg. */
    drawEntirePlan: Subscribable<boolean>;
    /** The waypoint renderer to use to draw waypoints for this entry's flight plan. */
    waypointRenderer: MapWaypointRenderer;
    /** The waypoint record manager to use to manage the waypoints to draw for this entry's flight plan. */
    waypointRecordManager: MapFlightPlanWaypointRecordManager;
    /** The flight path renderer to use to draw this entry's flight plan. */
    pathRenderer: MapFlightPathPlanRenderer;
};
/**
 * A module describing the display of flight plans.
 */
declare class MapGarminFlightPlanModule {
    /** Entries describing the display of flight plans. */
    readonly entries: readonly Readonly<MapGarminFlightPlanEntry>[];
    /**
     * Creates a new instance of MapGarminFlightPlanModule.
     * @param entries The entries to include in the module.
     */
    constructor(entries: Iterable<Readonly<MapGarminFlightPlanEntry>>);
}

/**
 * A module describing manual panning of the map.
 */
declare class MapPanningModule {
    /** Whether panning is active. */
    readonly isActive: Subject<boolean>;
    /** The desired map target. */
    readonly target: GeoPointSubject;
}

/**
 * A module describing the map pointer.
 */
declare class MapPointerModule {
    /** Whether the pointer is active. */
    readonly isActive: Subject<boolean>;
    /** The position of the pointer on the projected map, in pixel coordinates. */
    readonly position: Vec2Subject;
    /** The desired map target. */
    readonly target: GeoPointSubject;
}

/**
 * A module describing a flight plan procedure to be previewed.
 */
declare class MapProcedurePreviewModule {
    /** The procedure type previewed by the layer. */
    readonly procedureType: Subject<ProcedureType>;
    /** The flight plan containing the procedure to be previewed. */
    readonly procedurePlan: Subject<FlightPlan | null>;
    /** The flight plan containing the transitions to be previewed. */
    readonly transitionPlan: Subject<FlightPlan | null>;
}

/**
 * A module describing the map range compass.
 */
declare class MapRangeCompassModule {
    /** Whether to show the range compass. */
    readonly show: Subject<boolean>;
}

/**
 * A module describing the map range ring.
 */
declare class MapRangeRingModule {
    /** Whether to show the range ring. */
    readonly show: Subject<boolean>;
}

/**
 * Map terrain display mode.
 */
declare enum MapTerrainMode {
    None = 0,
    Absolute = 1,
    Relative = 2,
    Ground = 3
}
/**
 * A module describing the display of terrain.
 */
declare class MapTerrainModule {
    /** The terrain display mode. */
    readonly terrainMode: Subject<MapTerrainMode>;
    /** Whether to show the terrain scale. */
    readonly showScale: Subject<boolean>;
    /** Whether the relative terrain mode is in a failed state. */
    readonly isRelativeModeFailed: Subject<boolean>;
}

/**
 * A module describing the display of the track vector.
 */
declare class MapTrackVectorModule {
    /** Whether to show the track vector. */
    readonly show: Subject<boolean>;
    /** The track vector's lookahead time. */
    readonly lookaheadTime: NumberUnitSubject<_microsoft_msfs_sdk.UnitFamily.Duration, _microsoft_msfs_sdk.SimpleUnit<_microsoft_msfs_sdk.UnitFamily.Duration>>;
}

/**
 * A module which defines a highlighted waypoint.
 */
declare class MapWaypointHighlightModule {
    /** The highlighted waypoint. */
    readonly waypoint: Subject<Waypoint | null>;
}

/**
 * Airport size.
 */
declare enum AirportSize {
    Large = "Large",
    Medium = "Medium",
    Small = "Small"
}
/**
 * A waypoint associated with an airport.
 */
declare class AirportWaypoint extends BasicFacilityWaypoint<AirportFacility> {
    /** The longest runway at the airport associated with this waypoint, or null if the airport has no runways. */
    readonly longestRunway: AirportRunway | null;
    /** The size of the airport associated with this waypoint. */
    readonly size: AirportSize;
    /**
     * Creates a new instance of AirportWaypoint.
     * @param airport The airport associated with this waypoint.
     * @param bus The event bus.
     */
    constructor(airport: AirportFacility, bus: EventBus);
    /**
     * Gets the longest runway at an airport.
     * @param airport An airport.
     * @returns The longest runway at the specified airport, or `null` if the airport has no runways.
     */
    private static getLongestRunway;
    /**
     * Gets the size of an airport.
     * @param airport An airport.
     * @param longestRunway The longest runway at the airport.
     * @returns The size of the airport.
     */
    private static getAirportSize;
}

/**
 * A module describing the display of waypoints.
 */
declare class MapWaypointsModule {
    /** Whether to show airports. */
    readonly airportShow: Record<AirportSize, Subject<boolean>>;
    /** Whether to show VORs. */
    readonly vorShow: Subject<boolean>;
    /** Whether to show NDBs. */
    readonly ndbShow: Subject<boolean>;
    /** Whether to show intersections. */
    readonly intShow: Subject<boolean>;
    /** Whether to show user waypoints. */
    readonly userShow: Subject<boolean>;
    /** Whether to show runway outlines. */
    readonly runwayShow: Subject<boolean>;
    /** Whether to show runway labels. */
    readonly runwayLabelShow: Subject<boolean>;
    /** The minimum projected length of a runway, in pixels, required to show its label. */
    readonly runwayLabelMinLength: Subject<number>;
}

/**
 * A module describing the wind vector.
 */
declare class MapWindVectorModule {
    private readonly dataProvider;
    /** Whether to show the wind vector. */
    readonly show: Subject<boolean>;
    /** The current wind direction, in degrees true. */
    readonly windDirection: _microsoft_msfs_sdk.Subscribable<number>;
    /** The current wind speed, in knots. */
    readonly windSpeed: _microsoft_msfs_sdk.Subscribable<number>;
    /** Whether wind data is in a failed state. */
    readonly isDataFailed: _microsoft_msfs_sdk.Subscribable<boolean>;
    /**
     * Creates a new instance of MapWindModule.
     * @param dataProvider A provider of wind data.
     */
    constructor(dataProvider: WindDataProvider);
}

/**
 * A module which defines selected waypoint information for waypoint information maps.
 */
declare class WaypointMapSelectionModule {
    /** The selected waypoint. */
    readonly waypoint: Subject<Waypoint | null>;
    /** The selected airport runway. */
    readonly runway: Subject<AirportRunway | null>;
}

/**
 * Modules required for MapOrientationController.
 * @deprecated
 */
interface MapOrientationControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Orientation module. */
    [GarminMapKeys.Orientation]: MapOrientationModule;
    /** Pointer module. */
    [GarminMapKeys.Pointer]?: MapPointerModule;
}
/**
 * Context properties required by MapOrientationController.
 * @deprecated
 */
interface MapOrientationControllerContext {
    /** Resource moderator for control of the map's orientation mode. */
    [GarminMapKeys.OrientationControl]: ResourceModerator;
}
/**
 * User settings required by MapOrientationController.
 * @deprecated
 */
type MapOrientationControllerSettings = Pick<MapUserSettingTypes, 'mapOrientation' | 'mapAutoNorthUpActive' | 'mapAutoNorthUpRangeIndex'>;
/**
 * Controls the orientation of a map based on user settings.
 * @deprecated New, preferred logic for controlling map orientation based on user settings is available using
 * `MapOrientationSettingsController`.
 */
declare class MapOrientationController extends MapSystemController<MapOrientationControllerModules, any, any, MapOrientationControllerContext> {
    private readonly settingManager;
    private static readonly MODE_MAP;
    private readonly rangeModule;
    private readonly orientationModule;
    private readonly pointerModule;
    private readonly orientationControl;
    private readonly orientationControlConsumer;
    private orientation?;
    private orientationSub?;
    private isPointerActiveSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param settingManager The setting manager used by this controller.
     */
    constructor(context: MapSystemContext<MapOrientationControllerModules, any, any, MapOrientationControllerContext>, settingManager: UserSettingManager<Partial<MapOrientationControllerSettings>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapOrientationModeController.
 */
interface MapOrientationModeControllerModules {
    /** Orientation module. */
    [GarminMapKeys.Orientation]: MapOrientationModule;
}
/**
 * Context properties required by MapOrientationModeController.
 */
interface MapOrientationModeControllerContext {
    /** Resource moderator for control of the map's orientation mode. */
    [GarminMapKeys.OrientationControl]: ResourceModerator;
}
/**
 * Controls the orientation of a map based on the desired orientation mode.
 */
declare class MapOrientationModeController extends MapSystemController<MapOrientationModeControllerModules, any, any, MapOrientationModeControllerContext> {
    private readonly orientationModule;
    private readonly orientationControl;
    private readonly orientationControlConsumer;
    private orientationPipe?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapOrientationRTRController.
 */
interface MapOrientationRTRControllerModules {
    /** Rotation module. */
    [MapSystemKeys.Rotation]: MapRotationModule;
    /** Orientation module. */
    [GarminMapKeys.Orientation]: MapOrientationModule;
}
/**
 * Context properties required by MapOrientationRTRController.
 */
interface MapOrientationRTRControllerContext {
    /** Resource moderator for control of the map's rotation mode. */
    [GarminMapKeys.RotationModeControl]: ResourceModerator;
}
/**
 * Controls the rotation, range, and projected target offset of a map based on the orientation module's orientation
 * value.
 */
declare class MapOrientationRTRController extends MapSystemController<MapOrientationRTRControllerModules, any, any, MapOrientationRTRControllerContext> {
    private readonly nominalTargetOffsets?;
    private readonly nominalRangeEndpoints?;
    private static readonly DEFAULT_TARGET_OFFSET;
    private static readonly DEFAULT_RANGE_ENDPOINTS;
    private readonly orientationModule;
    private readonly rotationModule;
    private readonly rotationModeControl;
    private hasRotationModeControl;
    private readonly rotationModeControlConsumer;
    private readonly targetOffsetParam;
    private readonly rangeEndpointsParam;
    private readonly nominalTargetOffsetSubject;
    private readonly nominalRangeEndpointsSubject;
    private needUpdateTargetOffset;
    private needUpdateRangeEndpoints;
    private orientationSub?;
    private targetOffsetPipe?;
    private rangeEndpointsPipe?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param nominalTargetOffsets The nominal projected target offsets this controller applies for each orientation, as
     * `[x, y]` relative to the width and height of the map's projected window excluding the dead zone. If an orientation
     * does not have a defined offset, it will default to `[0, 0]`.
     * @param nominalRangeEndpoints The nominal range endpoints this controller applies for each orientation, as
     * `[x1, y1, x2, y2]` relative to the width and height of the map's projected window excluding the dead zone. If an
     * orientation does not have defined range endpoints, it will default to `[0.5, 0.5, 0.5, 0]`.
     */
    constructor(context: MapSystemContext<MapOrientationRTRControllerModules, any, any, MapOrientationRTRControllerContext>, nominalTargetOffsets?: Partial<Record<MapOrientation, Readonly<Omit<Float64Array, "set" | "sort" | "copyWithin">> | Subscribable<Readonly<Omit<Float64Array, "set" | "sort" | "copyWithin">>>>> | undefined, nominalRangeEndpoints?: Partial<Record<MapOrientation, Readonly<Omit<Float64Array, "set" | "sort" | "copyWithin">> | Subscribable<Readonly<Omit<Float64Array, "set" | "sort" | "copyWithin">>>>> | undefined);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onDeadZoneChanged(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onBeforeUpdated(): void;
    /**
     * Updates the map rotation mode based on the current map orientation.
     */
    private updateRotation;
    /**
     * Updates this controller's projected target offset.
     */
    private updateTargetOffset;
    /**
     * Updates this controller's range endpoints.
     */
    private updateRangeEndpoints;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapOrientationSettingsController.
 */
interface MapOrientationSettingsControllerModules {
    /** Orientation module. */
    [GarminMapKeys.Orientation]: MapOrientationModule;
}
/**
 * User settings required by MapOrientationSettingsController.
 */
type MapOrientationSettingsControllerSettings = Pick<MapUserSettingTypes, 'mapOrientation' | 'mapAutoNorthUpActive' | 'mapAutoNorthUpRangeIndex' | 'mapGroundNorthUpActive'>;
/**
 * Controls the orientation of a map based on user settings.
 */
declare class MapOrientationSettingsController extends MapSystemController<MapOrientationSettingsControllerModules> {
    private readonly settingManager;
    private static readonly MODE_MAP;
    private readonly orientationModule;
    private readonly subs;
    /**
     * Creates a new instance of MapOrientationSettingsController.
     * @param context This controller's map context.
     * @param settingManager The setting manager used by this controller.
     */
    constructor(context: MapSystemContext<MapOrientationSettingsControllerModules>, settingManager: UserSettingManager<Partial<MapOrientationSettingsControllerSettings>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapPanningRTRController.
 */
interface MapPanningRTRControllerModules {
    /** Panning module. */
    [GarminMapKeys.Panning]: MapPanningModule;
    /** Rotation module. */
    [MapSystemKeys.Rotation]?: MapRotationModule;
}
/**
 * Context properties required for MapPanningRTRController.
 */
interface MapPanningRTRControllerContext {
    /** Resource moderator for control of the map's projection target. */
    [MapSystemKeys.TargetControl]?: ResourceModerator;
    /** Resource moderator for control of the map's rotation mode. */
    [GarminMapKeys.RotationModeControl]?: ResourceModerator;
    /** Resource moderator for control of the map's orientation mode. */
    [GarminMapKeys.OrientationControl]?: ResourceModerator;
    /** Resource moderator for control of the map's range. */
    [MapSystemKeys.RangeControl]?: ResourceModerator;
    /** Resource moderator for the use range setting subject. */
    [GarminMapKeys.UseRangeSetting]?: ResourceModerator<Subject<boolean>>;
}
/**
 * Controls the target, orientation, and range of a map while manual map panning is active.
 */
declare class MapPanningRTRController extends MapSystemController<MapPanningRTRControllerModules, any, any, MapPanningRTRControllerContext> {
    private readonly panningModule;
    private readonly rotationModule;
    private readonly mapProjectionParams;
    private readonly targetControl;
    private hasTargetControl;
    private readonly targetControlConsumer;
    private readonly rotationModeControl;
    private readonly rotationModeControlConsumer;
    private readonly orientationControl;
    private readonly orientationControlConsumer;
    private readonly rangeControl;
    private readonly rangeControlConsumer;
    private readonly useRangeSetting;
    private readonly useRangeSettingConsumer;
    private panningActiveSub?;
    private panningTargetSub?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Responds to map panning activation changes.
     * @param isActive Whether map panning is active.
     */
    private onPanningActiveChanged;
    /**
     * Responds to map panning activation.
     */
    private onPanningActivated;
    /**
     * Responds to map panning deactivation.
     */
    private onPanningDeactivated;
    /**
     * Responds to when the map panning target changes.
     * @param target The new map panning target.
     */
    private onTargetChanged;
    /**
     * Sets the map projection's target.
     * @param target The target to set.
     */
    private setMapTarget;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapPointerController.
 */
interface MapPointerControllerModules {
    /** Pointer module. */
    [GarminMapKeys.Pointer]: MapPointerModule;
}
/**
 * Controls the pointer of a map.
 */
declare class MapPointerController extends MapSystemController<MapPointerControllerModules> {
    private static readonly geoPointCache;
    protected readonly pointerModule: MapPointerModule;
    /**
     * Activates or deactivates the map pointer.
     * @param isActive Whether to activate the map pointer.
     */
    setPointerActive(isActive: boolean): void;
    /**
     * Toggles activation of the map pointer.
     * @returns Whether the map pointer is active after the toggle operation.
     */
    togglePointerActive(): boolean;
    /**
     * Moves the map pointer.
     * @param dx The horizontal displacement, in pixels.
     * @param dy The vertical dispacement, in pixels.
     */
    movePointer(dx: number, dy: number): void;
    /**
     * Sets the map target to the current position of the pointer. The pointer will also be moved to the new projected
     * target position.
     */
    targetPointer(): void;
}

/**
 * Modules required for MapPointerRTRController.
 */
interface MapPointerRTRControllerModules {
    /** Pointer module. */
    [GarminMapKeys.Pointer]: MapPointerModule;
    /** Panning module. */
    [GarminMapKeys.Panning]: MapPanningModule;
    /** Orientation module. */
    [GarminMapKeys.Orientation]?: MapOrientationModule;
}
/**
 * Context properties required for MapPointerRTRController.
 */
type MapPointerRTRControllerContext = Record<string, never>;
/**
 * Controls the target, orientation, and range of a map while the map pointer is active.
 */
declare class MapPointerRTRController extends MapSystemController<MapPointerRTRControllerModules> {
    private readonly pointerModule;
    private readonly panningModule;
    private readonly orientationModule;
    protected readonly pointerBoundsOffset: Subscribable<ReadonlyFloat64Array>;
    private readonly pointerBounds;
    private needUpdatePointerScroll;
    private targetPipe?;
    private pointerBoundsOffsetSub?;
    private pointerActiveSub?;
    private pointerBoundsSub?;
    private pointerPositionSub?;
    private commandedOrientationSub?;
    /**
     * Creates a new instance of MapPointerRTRController.
     * @param context This controller's map context.
     * @param pointerBoundsOffset The offset of the boundary surrounding the area in which the pointer can freely move,
     * from the edge of the projected map, excluding the dead zone. Expressed as `[left, top, right, bottom]`, relative
     * to the width and height, as appropriate, of the projected map. A positive offset is directed toward the center of
     * the map.
     */
    constructor(context: MapSystemContext<MapPointerRTRControllerModules>, pointerBoundsOffset: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Updates this controller's pointer bounds.
     */
    private updatePointerBounds;
    /**
     * Responds to map pointer activation changes.
     * @param isActive Whether the map pointer is active.
     */
    protected onPointerActiveChanged(isActive: boolean): void;
    /**
     * Responds to map pointer activation.
     */
    protected onPointerActivated(): void;
    /**
     * Responds to map pointer deactivation.
     */
    protected onPointerDeactivated(): void;
    /**
     * Responds to map pointer position changes.
     */
    private onPointerPositionChanged;
    /**
     * Responds to map pointer bounds changes.
     */
    private onPointerBoundsChanged;
    /**
     * Schedules an update to scrolling due to the pointer.
     */
    protected schedulePointerScrollUpdate(): void;
    private readonly pointerVec2Cache;
    private readonly targetCache;
    /**
     * Updates scrolling due to the pointer.
     */
    protected updatePointerScroll(): void;
    /** @inheritdoc */
    onDeadZoneChanged(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onBeforeUpdated(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapRangeCompassController.
 */
interface MapRangeCompassControllerModules {
    /** Orientation module. */
    [GarminMapKeys.Orientation]: MapOrientationModule;
    /** Range compass module. */
    [GarminMapKeys.RangeCompass]: MapRangeCompassModule;
    /** Range ring module. */
    [GarminMapKeys.RangeRing]?: MapRangeRingModule;
}
/**
 * Controls the display of the range compass, and optionally the range ring, based on map orientation.
 */
declare class MapRangeCompassController extends MapSystemController<MapRangeCompassControllerModules> {
    private readonly orientation;
    private readonly rangeCompassShow;
    private readonly rangeRingShow;
    private orientationSub?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapRangeRTRController.
 */
interface MapRangeRTRControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
}
/**
 * Controls map projection range based on the range module's nominal range value.
 */
declare class MapRangeRTRController extends MapSystemController<MapRangeRTRControllerModules> {
    private readonly rangeModule;
    private readonly rangeParam;
    private needUpdateRange;
    private rangeSub?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onBeforeUpdated(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required by MapSymbolVisController.
 */
interface MapSymbolVisControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Declutter module. */
    [GarminMapKeys.Declutter]?: MapDeclutterModule;
}
/**
 * Controls the visibility of a specific type of map symbol whose visibility is dependent on its own show and maximum
 * range index settings as well as the global map declutter setting.
 */
declare class MapSymbolVisController extends MapSystemController<MapSymbolVisControllerModules> {
    private readonly showSetting;
    private readonly rangeIndexSetting;
    private readonly maxDeclutterMode;
    private readonly symbolVisibility;
    private readonly rangeModule;
    private readonly declutterModule;
    private isSymbolVisible?;
    private isSymbolVisiblePipe?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param showSetting A subscribable which provides the show setting of this controller's symbol.
     * @param rangeIndexSetting A subscribable which provides the maximum range index setting of this controller's
     * symbol.
     * @param maxDeclutterMode The highest global declutter mode, inclusive, at which this controller's symbol remains
     * visible.
     * @param symbolVisibility The mutable subscribable which controls the visibility of this controller's symbol.
     */
    constructor(context: MapSystemContext<MapSymbolVisControllerModules, any, any, any>, showSetting: Subscribable<boolean>, rangeIndexSetting: Subscribable<number>, maxDeclutterMode: MapDeclutterMode, symbolVisibility: MutableSubscribable<boolean>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A map terrain colors definition.
 */
type MapTerrainColorsDefinition = {
    /**
     * The earth colors array. Index 0 defines the water color, and indexes 1 to the end of the array define the terrain
     * colors.
     */
    colors: readonly number[];
    /** The elevation range over which the terrain colors are applied, as `[minimum, maximum]` in feet. */
    elevationRange: ReadonlyFloat64Array;
};
/**
 * Modules required for MapTerrainColorsController.
 */
interface MapTerrainColorsControllerModules {
    /** Terrain module. */
    [GarminMapKeys.Terrain]: MapTerrainModule;
    /** Terrain colors module. */
    [MapSystemKeys.TerrainColors]: MapTerrainColorsModule;
}
/**
 * Controls the display of terrain colors based on the terrain mode value in {@link MapTerrainModule}.
 */
declare class MapTerrainColorsController extends MapSystemController<MapTerrainColorsControllerModules> {
    private readonly colors;
    private readonly groundRelativeBlendDuration;
    private static readonly DEFAULT_COLORS;
    private static readonly MODE_REFERENCE_MAP;
    private static readonly BLEND_UPDATE_TARGET_STEP_COUNT;
    private static readonly BLEND_UPDATE_MAX_HZ;
    private readonly terrainModule;
    private readonly terrainColorsModule;
    private readonly groundRelativeBlendTimeStep;
    private readonly groundRelativeBlendTimeOffset;
    private readonly groundRelativeBlendColors?;
    private blendArmedMode;
    private isBlending;
    private blendDirection;
    private blendProgress;
    private lastBlendIndex;
    private lastBlendTime;
    private modeSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param colors The terrain colors to use for each terrain mode. Default colors will be used for any mode which does
     * not have a colors definition.
     * @param groundRelativeBlendDuration The amount of time, in milliseconds, over which to blend the on-ground and
     * relative terrain mode colors when transitioning between the two. Defaults to 0 milliseconds. A blend transition is
     * only possible if colors are defined for both the on-ground and relative terrain modes, and the colors for both
     * modes have the same number of steps and are applied over the same elevation range.
     */
    constructor(context: MapSystemContext<MapTerrainColorsControllerModules>, colors: Partial<Record<MapTerrainMode, Readonly<MapTerrainColorsDefinition>>>, groundRelativeBlendDuration?: number);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onAfterUpdated(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
    /**
     * Creates an array of terrain color arrays where each color array is an intermediate step in a blend transition
     * between the on-ground mode and relative mode color arrays.
     * @param groundColors The on-ground mode earth color array.
     * @param relativeColors The relative mode earth color array.
     * @param blendDuration The amount of time, in milliseconds, over which the blend transition occurs.
     * @param blendTimeStep The amount of time, in milliseconds, covered by each blend step.
     * @returns An array of terrain color arrays where each color array is an intermediate step in the specified blend
     * transition between the on-ground mode and relative mode color arrays, or `undefined` if a blend transition is not
     * possible.
     */
    private static createGroundRelativeBlendedColors;
}

/**
 * User settings controlling the display of terrain.
 */
type MapTerrainUserSettings = Pick<MapUserSettingTypes, 'mapTerrainMode' | 'mapTerrainRangeIndex' | 'mapTerrainScaleShow'>;
/**
 * Modules required by MapTerrainController.
 */
interface MapTerrainControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Range module. */
    [GarminMapKeys.Terrain]: MapTerrainModule;
    /** Own airplane properties module. */
    [MapSystemKeys.OwnAirplaneProps]?: MapOwnAirplanePropsModule;
    /** Data integrity module. */
    [MapSystemKeys.DataIntegrity]?: MapDataIntegrityModule;
}
/**
 * Configuration options for {@link MapTerrainController}.
 */
type MapTerrainControllerOptions = {
    /** Whether to allow relative terrain mode. Ignored if a user setting manager is not provided. Defaults to `true`. */
    allowRelative?: boolean;
    /**
     * The default terrain mode to which to revert if the desired terrain mode defined by user settings cannot be engaged.
     * Ignored if a user setting manager is not provided. Defaults to `MapTerrainMode.None`.
     */
    defaultMode?: MapTerrainMode | Subscribable<MapTerrainMode>;
};
/**
 * Controls the display of terrain based on user settings.
 */
declare class MapTerrainController extends MapSystemController<MapTerrainControllerModules> {
    private readonly terrainModule;
    private readonly rangeIndex;
    private readonly isOnGround;
    private readonly isGpsDataValid;
    private readonly modeSetting?;
    private readonly rangeIndexSetting;
    private readonly showScaleSetting?;
    private readonly allowRelative;
    private readonly defaultTerrainMode;
    private terrainModeState?;
    private showScalePipe?;
    /**
     * Creates a new instance of MapTerrainController.
     * @param context This controller's map context.
     * @param settingManager A setting manager containing the user settings controlling the display of terrain. If not
     * defined, the display of terrain will not be bound to user settings.
     * @param allowRelative Whether to allow relative terrain mode. Defaults to `true`. Ignored if `settingManager` is
     * not defined.
     */
    constructor(context: MapSystemContext<MapTerrainControllerModules, any, any, any>, settingManager?: UserSettingManager<Partial<MapTerrainUserSettings>>, allowRelative?: boolean);
    /**
     * Creates a new instance of MapTerrainController.
     * @param context This controller's map context.
     * @param settingManager A setting manager containing the user settings controlling the display of terrain. If not
     * defined, the display of terrain will not be bound to user settings.
     * @param options Options with which to configure the controller.
     */
    constructor(context: MapSystemContext<MapTerrainControllerModules, any, any, any>, settingManager?: UserSettingManager<Partial<MapTerrainUserSettings>>, options?: Readonly<MapTerrainControllerOptions>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapTrafficController.
 */
interface MapTrafficControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]?: MapIndexedRangeModule;
    /** Traffic module. */
    [MapSystemKeys.Traffic]: MapTrafficModule;
    /** Garmin traffic module. */
    [GarminMapKeys.Traffic]: MapGarminTrafficModule;
}
/**
 * Controls the display of traffic based on the values in {@link MapGarminTrafficModule}.
 */
declare class MapTrafficController extends MapSystemController<MapTrafficControllerModules> {
    private readonly useOuterRangeAsOffScale;
    private static readonly NAN_RANGE;
    private static readonly ALERT_LEVEL_VIS_MAP;
    private static readonly ALTITUDE_RESTRICTION_UNRES;
    private static readonly ALTITUDE_RESTRICTION_NORMAL;
    private readonly rangeModule;
    private readonly trafficModule;
    private readonly garminTrafficModule;
    private showPipe?;
    private alertLevelPipe?;
    private isAltitudeRelativePipe?;
    private altitudeModeSub?;
    private offScaleRange?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param useOuterRangeAsOffScale Whether to use the map's outer traffic range as the traffic off-scale range.
     */
    constructor(context: MapSystemContext<MapTrafficControllerModules, any, any, any>, useOuterRangeAsOffScale: boolean);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * User settings controlling the visibility of map waypoints.
 */
type MapWaypointVisUserSettings = Pick<MapUserSettingTypes, 'mapAirportLargeRangeIndex' | 'mapAirportLargeShow' | 'mapAirportMediumRangeIndex' | 'mapAirportMediumShow' | 'mapAirportSmallRangeIndex' | 'mapAirportSmallShow' | 'mapIntersectionRangeIndex' | 'mapIntersectionShow' | 'mapNdbRangeIndex' | 'mapNdbShow' | 'mapVorRangeIndex' | 'mapVorShow' | 'mapUserWaypointRangeIndex' | 'mapUserWaypointShow'>;
/**
 * Modules required by MapWaypointsVisController.
 */
interface MapWaypointsVisControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Range module. */
    [MapSystemKeys.NearestWaypoints]: MapWaypointsModule;
    /** Declutter module. */
    [GarminMapKeys.Declutter]?: MapDeclutterModule;
}
/**
 * Configuration options for {@link MapWaypointsVisController}.
 */
type MapWaypointsVisControllerOptions = {
    /**
     * The highest global declutter mode, inclusive, at which large airports should remain visible. Defaults to
     * {@link MapDeclutterMode.Level2}.
     */
    airportLargeMaxDeclutterMode?: MapDeclutterMode;
    /**
     * The highest global declutter mode, inclusive, at which medium airports should remain visible. Defaults to
     * {@link MapDeclutterMode.Level2}.
     */
    airportMediumMaxDeclutterMode?: MapDeclutterMode;
    /**
     * The highest global declutter mode, inclusive, at which small airports should remain visible. Defaults to
     * {@link MapDeclutterMode.Level2}.
     */
    airportSmallMaxDeclutterMode?: MapDeclutterMode;
    /**
     * The highest global declutter mode, inclusive, at which VORs should remain visible. Defaults to
     * {@link MapDeclutterMode.Level3}.
     */
    vorMaxDeclutterMode?: MapDeclutterMode;
    /**
     * The highest global declutter mode, inclusive, at which NDBs should remain visible. Defaults to
     * {@link MapDeclutterMode.Level3}.
     */
    ndbMaxDeclutterMode?: MapDeclutterMode;
    /**
     * The highest global declutter mode, inclusive, at which intersections should remain visible. Defaults to
     * {@link MapDeclutterMode.Level3}.
     */
    intMaxDeclutterMode?: MapDeclutterMode;
    /**
     * The highest global declutter mode, inclusive, at which user waypoints should remain visible. Defaults to
     * {@link MapDeclutterMode.Level3}.
     */
    userMaxDeclutterMode?: MapDeclutterMode;
};
/**
 * Controls the visibility of map waypoint symbols.
 */
declare class MapWaypointsVisController extends MapSystemController<MapWaypointsVisControllerModules> {
    private readonly waypointsModule;
    private readonly controllers;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param settingManager A setting manager containing the user settings controlling waypoint visibility.
     * @param options Options with which to configure the controller.
     */
    constructor(context: MapSystemContext<MapWaypointsVisControllerModules, any, any, any>, settingManager: UserSettingManager<Partial<MapWaypointVisUserSettings>>, options?: Readonly<MapWaypointsVisControllerOptions>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * User settings controlling the display of the wind vector.
 */
type MapWindVectorUserSettings = Pick<MapUserSettingTypes, 'mapWindVectorShow'>;
/**
 * Modules required by {@link MapWindVectorController}.
 */
interface MapWindVectorControllerModules {
    /** Wind vector module. */
    [GarminMapKeys.WindVector]: MapWindVectorModule;
    /** Pointer module. */
    [GarminMapKeys.Pointer]?: MapPointerModule;
}
/**
 * Controls the display of the wind vector based on user settings.
 *
 * The controller displays the wind vector if and only if user settings are set to show the vector and the map pointer
 * is not active.
 */
declare class MapWindVectorController extends MapSystemController<MapWindVectorControllerModules> {
    private readonly windVectorModule;
    private readonly pointerModule;
    private readonly show?;
    /**
     * Creates a new instance of MapWindVectorController.
     * @param context This controller's map context.
     * @param settingManager A setting manager containing the user settings controlling the display of the wind vector.
     */
    constructor(context: MapSystemContext<MapWindVectorControllerModules, any, any, any>, settingManager: UserSettingManager<Partial<MapWindVectorUserSettings>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapWxrController.
 */
interface MapWxrControllerModules {
    /** NEXRAD module. */
    [GarminMapKeys.Nexrad]: MapNexradModule;
    /** Weather module. */
    [MapSystemKeys.Weather]: MapWxrModule;
}
/**
 * Controls the display of weather on the map based on options set by {@link MapNexradModule}.
 */
declare class MapWxrController extends MapSystemController<MapWxrControllerModules> {
    private readonly nexradModule;
    private readonly weatherModule;
    private nexradShowSub?;
    private nexradColorsSub?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for NearestMapRTRController.
 */
interface NearestMapRTRControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Waypoint highlight module. */
    [GarminMapKeys.WaypointHighlight]: MapWaypointHighlightModule;
}
/**
 * Required controllers for NearestMapRTRController.
 */
interface NearestMapRTRControllerControllers {
    /** Range controller. */
    [GarminMapKeys.Range]: MapRangeController;
}
/**
 * Context properties required for NearestMapRTRController.
 */
interface NearestMapRTRControllerContext {
    /** Resource moderator for control of the map's range. */
    [MapSystemKeys.RangeControl]?: ResourceModerator;
}
/**
 * Controls the range of a nearest waypoint map to keep a highlighted waypoint in view.
 */
declare class NearestMapRTRController extends MapSystemController<NearestMapRTRControllerModules, any, NearestMapRTRControllerControllers, NearestMapRTRControllerContext> {
    private readonly defaultNoTargetRangeIndex;
    private readonly rangeModule;
    private readonly waypointHighlightModule;
    private readonly rangeControl;
    private hasRangeControl;
    private readonly rangeControlConsumer;
    private waypointSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param defaultNoTargetRangeIndex A subscribable which provides the default map range index to apply when
     * not targeting a waypoint, or `null` if no range index should be applied.
     */
    constructor(context: MapSystemContext<NearestMapRTRControllerModules, any, any, NearestMapRTRControllerContext>, defaultNoTargetRangeIndex: Subscribable<number> | null);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Attempts to set the range of this controller's map so that the highlighted waypoint is in view. If there is no
     * highlighted waypoint or this controller does not have map range control privileges, this method does nothing.
     */
    trySetRangeForWaypoint(): void;
    /**
     * Sets the range index of this controller's map.
     * @param index The index to set.
     */
    private setRangeIndex;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapTrafficRangeController.
 */
interface TrafficMapRangeControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Garmin traffic module. */
    [GarminMapKeys.Traffic]: MapGarminTrafficModule;
    /** Display units module. */
    [GarminMapKeys.Units]?: MapUnitsModule;
}
/**
 * User settings required by MapTrafficRangeController.
 */
type TrafficMapRangeControllerSettings = {
    /** The range setting. */
    mapRangeIndex: number;
};
/**
 * Controls traffic map range.
 */
declare class TrafficMapRangeController extends MapSystemController<TrafficMapRangeControllerModules> {
    private readonly nauticalRangeArray?;
    private readonly metricRangeArray?;
    private readonly useSetting?;
    private readonly rangeModule;
    private readonly trafficModule;
    private readonly distanceUnitsMode;
    private readonly rangeSetting?;
    private distanceModeSub?;
    private indexSub?;
    private settingSub?;
    private useSettingSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param nauticalRangeArray The map range array this controller sets for nautical distance mode. If not defined,
     * this controller will not change the range array when entering nautical distance mode.
     * @param metricRangeArray The map range array this controller sets for metric distance mode. If not defined, this
     * controller will not change the range array when entering metric distance mode.
     * @param settingManager A setting manager containing the map range index setting. If not defined, map range will
     * be set directly through the map model.
     * @param useSetting A subscribable which provides whether to control map range via the user setting. If not defined,
     * map range will always be controlled via the user setting. Ignored if `settingManager` is undefined.
     */
    constructor(context: MapSystemContext<TrafficMapRangeControllerModules, any, any, any>, nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance, _microsoft_msfs_sdk.Unit<UnitFamily.Distance>>[] | undefined, metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance, _microsoft_msfs_sdk.Unit<UnitFamily.Distance>>[] | undefined, settingManager?: UserSettingManager<TrafficMapRangeControllerSettings>, useSetting?: Subscribable<boolean> | undefined);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Sets the map range index. If the index is out of bounds, it will be clamped before being set.
     * @param index The index to set.
     * @returns The index that was set.
     */
    setRangeIndex(index: number): number;
    /**
     * Changes the range index by a given number of steps. Each step changes the range index to the next or previous
     * index that holds a range different from the current range.
     * @param delta The number of steps by which to change the range.
     * @returns The final index that was set.
     */
    changeRangeIndex(delta: number): number;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for WaypointMapHighlightController.
 */
interface WaypointMapHighlightControllerModules {
    /** Waypoint info module. */
    [GarminMapKeys.WaypointSelection]: WaypointMapSelectionModule;
    /** Waypoint highlight module. */
    [GarminMapKeys.WaypointHighlight]: MapWaypointHighlightModule;
}
/**
 * Controls the highlighted waypoint of a waypoint map.
 */
declare class WaypointMapHighlightController extends MapSystemController<WaypointMapHighlightControllerModules> {
    private readonly waypointSelectModule;
    private readonly waypointHighlightModule;
    private waypointPipe?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for WaypointMapRTRController.
 */
interface WaypointMapRTRControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Waypoint info module. */
    [GarminMapKeys.WaypointSelection]: WaypointMapSelectionModule;
}
/**
 * Required controllers for WaypointMapRTRController.
 */
interface WaypointMapRTRControllerControllers {
    /** Range controller. */
    [GarminMapKeys.Range]: MapRangeController;
}
/**
 * Context properties required for WaypointMapRTRController.
 */
interface WaypointMapRTRControllerContext {
    /** Resource moderator for control of the map's projection target. */
    [MapSystemKeys.TargetControl]?: ResourceModerator;
    /** Resource moderator for control of the map's range. */
    [MapSystemKeys.RangeControl]?: ResourceModerator;
}
/**
 * Controls the target and range of a waypoint map based on the selected waypoint.
 */
declare class WaypointMapRTRController extends MapSystemController<WaypointMapRTRControllerModules, any, WaypointMapRTRControllerControllers, WaypointMapRTRControllerContext> {
    private readonly supportAirportAutoRange;
    private readonly defaultAirportRangeIndex?;
    private readonly rangeModule;
    private readonly waypointSelectModule;
    private readonly targetParams;
    private readonly targetControl;
    private readonly hasTargetControl;
    private readonly targetControlConsumer;
    private readonly rangeControl;
    private readonly hasRangeControl;
    private readonly rangeControlConsumer;
    private readonly canTargetWaypoint;
    private readonly pointHeap;
    private readonly nominalMargins;
    private readonly marginState?;
    private readonly margins;
    private readonly fovCalculator;
    private readonly fov;
    private readonly waypointState;
    private waypointLocationSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param supportAirportAutoRange Whether this controller automatically adjusts the map range when an airport is
     * the highlighted waypoint to give an appropriate view of the selected runway, or all runways if there is no
     * selected runway.
     * @param defaultAirportRangeIndex A subscribable which provides the default map range index to apply when a range
     * cannot be automatically selected for an airport. Ignored if `supportAirportAutoRange` is `false`. If not defined,
     * the map range will not be reset when targeting an airport and a range cannot be automatically selected.
     * @param airportAutoRangeMargins The nominal margins (relative to the map's dead zone boundaries), to respect when
     * calculating the map range for airports, as `[left, top, right, bottom]` in pixels. Ignored if
     * `supportAirportAutoRange` is `false`. Defaults to `[0, 0, 0, 0]`.
     */
    constructor(context: MapSystemContext<WaypointMapRTRControllerModules, any, any, WaypointMapRTRControllerContext>, supportAirportAutoRange: boolean, defaultAirportRangeIndex?: Subscribable<number> | undefined, airportAutoRangeMargins?: Subscribable<ReadonlyFloat64Array>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Attempts to target the map to the selected waypoint. If there is no selected waypoint or this controller does not
     * have map target or range control privileges, this method does nothing.
     * @param resetRange Whether to reset the map range if the selected waypoint is an airport and airport auto-range is
     * supported.
     * @returns Whether the map was successfully targeted.
     */
    tryTargetWaypoint(resetRange: boolean): boolean;
    /**
     * Calculates the field of view for a selected airport and optional selected runway.
     * @param airport The selected airport.
     * @param runway The selected runway.
     * @param out The object to which to write the results.
     * @returns The field of view for the selected airport and optional selected runway.
     */
    private calculateFovForAirport;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for WeatherMapOrientationController.
 * @deprecated
 */
interface WeatherMapOrientationControllerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Orientation module. */
    [GarminMapKeys.Orientation]: MapOrientationModule;
    /** Pointer module. */
    [GarminMapKeys.Pointer]?: MapPointerModule;
}
/**
 * Context properties required by WeatherMapOrientationController.
 * @deprecated
 */
interface WeatherMapOrientationControllerContext {
    /** Resource moderator for control of the map's orientation mode. */
    [GarminMapKeys.OrientationControl]: ResourceModerator;
}
/**
 * User settings required by WeatherMapOrientationController.
 * @deprecated
 */
type WeatherMapOrientationControllerSettings = Pick<MapUserSettingTypes & WeatherMapUserSettingTypes, 'weatherMapOrientation' | 'mapOrientation' | 'mapAutoNorthUpActive' | 'mapAutoNorthUpRangeIndex'>;
/**
 * Controls the orientation of a weather map based on user settings.
 * @deprecated New, preferred logic for controlling weather map orientation based on user settings is available using
 * `WeatherMapOrientationSettingsController`.
 */
declare class WeatherMapOrientationController extends MapSystemController<WeatherMapOrientationControllerModules, any, any, WeatherMapOrientationControllerContext> {
    private readonly settingManager;
    private static readonly MODE_MAP;
    private static readonly WEATHER_MODE_MAP;
    private readonly rangeModule;
    private readonly orientationModule;
    private readonly pointerModule;
    private readonly orientationControl;
    private readonly orientationControlConsumer;
    private orientation?;
    private orientationSub?;
    private isPointerActiveSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param settingManager The setting manager used by this controller.
     */
    constructor(context: MapSystemContext<WeatherMapOrientationControllerModules, any, any, WeatherMapOrientationControllerContext>, settingManager: UserSettingManager<Partial<WeatherMapOrientationControllerSettings>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for WeatherMapOrientationSettingsController.
 */
interface WeatherMapOrientationSettingsControllerModules {
    /** Orientation module. */
    [GarminMapKeys.Orientation]: MapOrientationModule;
}
/**
 * User settings required by WeatherMapOrientationSettingsController.
 */
type WeatherMapOrientationSettingsControllerSettings = Pick<MapUserSettingTypes & WeatherMapUserSettingTypes, 'weatherMapOrientation' | 'mapOrientation' | 'mapAutoNorthUpActive' | 'mapAutoNorthUpRangeIndex'>;
/**
 * Controls the orientation of a weather map based on user settings.
 */
declare class WeatherMapOrientationSettingsController extends MapSystemController<WeatherMapOrientationSettingsControllerModules> {
    private readonly settingManager;
    private static readonly MODE_MAP;
    private static readonly WEATHER_MODE_MAP;
    private readonly orientationModule;
    private readonly subs;
    /**
     * Creates a new instance of WeatherMapOrientationSettingsController.
     * @param context This controller's map context.
     * @param settingManager The setting manager used by this controller.
     */
    constructor(context: MapSystemContext<WeatherMapOrientationSettingsControllerModules>, settingManager: UserSettingManager<Partial<WeatherMapOrientationSettingsControllerSettings>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapCrosshairLayer.
 */
interface MapCrosshairLayerModules {
    /** Crosshair module. */
    [GarminMapKeys.Crosshair]: MapCrosshairModule;
}
/**
 * A map layer which displays a crosshair at the projected position of the map target.
 */
declare class MapCrosshairLayer extends MapLayer<MapLayerProps<MapCrosshairLayerModules>> {
    private readonly crosshairRef;
    private needReposition;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /**
     * Updates this layer according to its current visibility.
     */
    private updateFromVisibility;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Repositions this layer's crosshair.
     */
    private repositionCrosshair;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Modules required for MapDeadReckoningLayer.
 */
interface MapDeadReckoningLayerModules {
    /** Own airplane props module. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
    /** Own airplane icon module. */
    [MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule;
    /** Data integrity module. */
    [MapSystemKeys.DataIntegrity]: MapGarminDataIntegrityModule;
}
/**
 * Component props for MapDeadReckoningLayer.
 */
interface MapDeadReckoningLayerProps extends MapLayerProps<MapDeadReckoningLayerModules> {
    /** The size of the airplane icon, in pixels. */
    airplaneIconSize: number | Subscribable<number>;
    /**
     * The point on the airplane icon which is anchored to the airplane's position, expressed relative to the icon's
     * width and height, with `[0, 0]` at the top left and `[1, 1]` at the bottom right.
     */
    airplaneIconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
}
/**
 * A map layer which displays a dead reckoning annunciation at the position of the airplane icon.
 */
declare class MapDeadReckoningLayer extends MapLayer<MapDeadReckoningLayerProps> {
    private static readonly vec2Cache;
    private readonly style;
    private readonly ownAirplanePropsModule;
    private readonly ownAirplaneIconModule;
    private readonly dataIntegrityModule;
    private readonly iconSize;
    private readonly iconAnchor;
    private readonly iconCenterOffset;
    private readonly visibilityBounds;
    private readonly isInsideVisibilityBounds;
    private readonly show;
    private readonly visibility;
    private needUpdatePosition;
    private positionSub?;
    private headingSub?;
    private iconSizeSub?;
    private iconAnchorSub?;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Updates the annunciation's offset from the projected position of the airplane.
     */
    private updateOffset;
    /**
     * Updates the boundaries within the map's projected window that define a region such that if the airplane's
     * projected position falls outside of it, the annunciation is not visible and therefore does not need to be updated.
     */
    private updateVisibilityBounds;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates the annunciation's projected position.
     */
    private updatePosition;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapMiniCompassLayer.
 */
interface MapMiniCompassLayerProps extends MapLayerProps<any> {
    /** The source for the arrow graphic. */
    imgSrc: string;
}
/**
 * The map layer showing a rotating compass arrow pointing to true north.
 */
declare class MapMiniCompassLayer extends MapLayer<MapMiniCompassLayerProps> {
    private readonly rootRef;
    private readonly imgRef;
    private needUpdate;
    private cssClassSub?;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(): void;
    /**
     * Updates the rotation of the arrow.
     */
    private updateRotation;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapPointerInfoLayer.
 */
interface MapPointerInfoLayerModules {
    /** Own airplane properties module. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
    /** Pointer module. */
    [GarminMapKeys.Pointer]: MapPointerModule;
    /** Display units module. */
    [GarminMapKeys.Units]?: MapUnitsModule;
}
/**
 * Map pointer information box size.
 */
declare enum MapPointerInfoLayerSize {
    Full = 0,
    Medium = 1,
    Small = 2
}
/**
 * Component props for MapPointerInfoLayer.
 */
interface MapPointerInfoLayerProps extends MapLayerProps<MapPointerInfoLayerModules> {
    /** The size of the information box. */
    size: MapPointerInfoLayerSize;
}
/**
 * A map layer which displays a pointer information box.
 */
declare class MapPointerInfoLayer extends MapLayer<MapPointerInfoLayerProps> {
    private static readonly geoPointCache;
    private readonly rootRef;
    private readonly ownAirplanePropsModule;
    private readonly pointerModule;
    private readonly unitsModule;
    private readonly distanceLargeUnits;
    private readonly distanceSmallUnits;
    private readonly navAngleUnits;
    private readonly distance;
    private readonly distanceUnit;
    private readonly bearing;
    private readonly latLon;
    private isInit;
    private needUpdate;
    private airplanePositionSub?;
    private pointerPositionSub?;
    /** @inheritDoc */
    onVisibilityChanged(isVisible: boolean): void;
    /**
     * Updates this layer according to its current visibility.
     */
    private updateFromVisibility;
    /** @inheritDoc */
    onAfterRender(): void;
    /** @inheritDoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritDoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this layer's displayed information.
     */
    private updateInfo;
    /**
     * Updates the displayed distance unit type.
     */
    private updateDistanceUnit;
    /** @inheritDoc */
    render(): VNode;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * Modules required by MapPointerLayer.
 */
interface MapPointerLayerModules {
    /** Pointer module. */
    [GarminMapKeys.Pointer]: MapPointerModule;
}
/**
 * A map layer which displays a pointer.
 */
declare class MapPointerLayer extends MapLayer<MapLayerProps<MapPointerLayerModules>> {
    private readonly pointerRef;
    private readonly pointerModule;
    private needRepositionPointer;
    private positionSub?;
    private isActiveSub?;
    /** @inheritdoc */
    onVisibilityChanged(): void;
    /**
     * Updates this layer according to its current visibility.
     */
    private updateFromVisibility;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onUpdated(): void;
    /**
     * Repositions this layer's pointer.
     */
    private repositionPointer;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Renders the default pointer icon.
     * @returns The default pointer icon, as a VNode.
     */
    private renderDefault;
    /**
     * Renders a custom pointer icon.
     * @returns The custom pointer icon, as a VNode.
     */
    private renderCustom;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required by MapProcedurePreviewLayer.
 */
interface MapProcedurePreviewLayerModules {
    /** Procedure preview module. */
    [GarminMapKeys.ProcedurePreview]: MapProcedurePreviewModule;
}
/**
 * Component props for MapProcedurePreviewLayer.
 */
interface MapProcedurePreviewLayerProps extends MapLayerProps<MapProcedurePreviewLayerModules> {
    /** The event bus. */
    bus: EventBus;
    /** The waypoint renderer to use. */
    waypointRenderer: MapWaypointRenderer;
    /** The flight path renderer to use. */
    pathRenderer: MapFlightPathProcRenderer;
}
/**
 * A map layer which displays a procedure preview.
 */
declare class MapProcedurePreviewLayer extends MapLayer<MapProcedurePreviewLayerProps> {
    private static readonly CLIP_BOUNDS_BUFFER;
    private readonly flightPathLayerRef;
    private readonly waypointLayerRef;
    private readonly procPreviewModule;
    private readonly resampler;
    private readonly facLoader;
    private readonly waypointCache;
    private readonly clipBoundsSub;
    private readonly clippedPathStream;
    private readonly pathStreamStack;
    private readonly procedureWaypointRecordManager;
    private readonly transitionWaypointRecordManager;
    private needDrawRoute;
    private needRefreshProcedureWaypoints;
    private needRepickProcedureWaypoints;
    private needRefreshTransitionWaypoints;
    private needRepickTransitionWaypoints;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes the waypoint renderer.
     */
    private initWaypointRenderer;
    /**
     * Initializes handlers to respond to flight plan events.
     */
    private initFlightPlanHandlers;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Updates this layer's canvas clipping bounds.
     */
    private updateClipBounds;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Checks if the flight path layer's display canvas has been invalidated, and if so, clears it and schedules a redraw.
     */
    private updateFromFlightPathLayerInvalidation;
    /**
     * Redraws the flight path if a redraw is scheduled.
     */
    private updateRedrawRoute;
    /**
     * Draws the flight path route.
     */
    private drawRoute;
    /**
     * Refreshes this layer's flight plan leg waypoint records if a refresh is scheduled.
     */
    private updateRefreshWaypoints;
    /**
     * Schedules flight plan drawing updates.
     * @param scheduleRedrawRoute Whether to schedule a redraw of the flight path.
     * @param scheduleRefreshProcedureWaypoints Whether to schedule a refresh of procedure waypoint records.
     * @param scheduleRepickProcedureWaypoints Whether to schedule a repick of procedure waypoint records.
     * @param scheduleRefreshTransitionWaypoints Whether to schedule a refresh of transition waypoint records.
     * @param scheduleRepickTransitionWaypoints Whether to schedule a repick of transition waypoint records.
     */
    private scheduleUpdates;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Modules required by MapRangeCompassLayer.
 */
interface MapRangeCompassLayerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Own airplane properties module. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
    /** Autopilot properties module. */
    [MapSystemKeys.AutopilotProps]?: MapGarminAutopilotPropsModule;
    /** Follow airplane module. */
    [MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule;
    /** Orientation module. */
    [GarminMapKeys.Orientation]: MapOrientationModule;
    /** Range compass module. */
    [GarminMapKeys.RangeCompass]: MapRangeCompassModule;
    /** Display units module. */
    [GarminMapKeys.Units]?: MapUnitsModule;
}
/**
 * A function which renders labels for map range compasses.
 */
type MapRangeCompassLabelRenderer = (range: Subscribable<NumberUnitInterface<UnitFamily.Distance>>, displayUnit: Subscribable<Unit<UnitFamily.Distance>>) => VNode;
/**
 * Component props for MapRangeCompassLayer.
 */
interface MapRangeCompassLayerProps extends MapLayerProps<MapRangeCompassLayerModules> {
    /** The event bus. */
    bus: EventBus;
    /** Whether to show the range label. */
    showLabel: boolean;
    /**
     * A function which renders labels for the rings. If not defined, a default label of type {@link MapRangeDisplay}
     * will be rendered.
     */
    renderLabel?: MapRangeCompassLabelRenderer;
    /**
     * Whether to show the selected heading bug. Showing the selected heading bug requires a
     * {@link MapGarminAutopilotPropsModule} to be added to the map under the key {@link MapSystemKeys.AutopilotProps}.
     */
    showHeadingBug: boolean;
    /**
     * Whether to support autopilot selected heading sync behavior. If `true`, then
     * {@link MapGarminAutopilotPropsModule.manualHeadingSelect} will be used to determine when manual adjustments to
     * selected heading are made. If `false`, then any change to selected heading is considered a manual adjustment.
     * Ignored if `showHeadingBug` is `false`. Defaults to `false`.
     */
    supportHeadingSync?: boolean;
    /** The width, in pixels, of the compass arc stroke. Defaults to 2 pixels. */
    arcStrokeWidth?: number;
    /** The style of the compass arc stroke. Defaults to `'white'`. */
    arcStrokeColor?: string;
    /** The length, in pixels, of major bearing ticks. */
    bearingTickMajorLength: number;
    /** The length, in pixels, of minor bearing ticks. */
    bearingTickMinorLength: number;
    /** The length, in pixels, of the tick marks at the ends of the compass arc. Defaults to the major bearing tick length. */
    arcEndTickLength?: number;
    /** The bearing label font type. */
    bearingLabelFont: string;
    /** The size, in pixels, of the bearing label font. */
    bearingLabelFontSize: number;
    /** The color of the bearing label font. Defaults to the arc stroke color. */
    bearingLabelFontColor?: string;
    /** The width, in pixels, of the bearing label font's outline. Defaults to 6 pixels. */
    bearingLabelOutlineWidth?: number;
    /** The color of the bearing label outline. Defaults to `'black'`. */
    bearingLabelOutlineColor?: string;
    /**
     * The radial offset, in pixels, of bearing labels from its associated tick mark. Positive values shift the label
     * away from the tick mark. Defaults to 0 pixels.
     */
    bearingLabelRadialOffset?: number;
    /**
     * The width, in pixels, of the reference tick. Defaults to the arc stroke width.
     */
    referenceTickWidth?: number;
    /**
     * The height, in pixels, of the reference tick. Defaults to the minor bearing tick length.
     */
    referenceTickHeight?: number;
    /**
     * The width, in pixels, of the selected heading bug.
     */
    headingBugWidth?: number;
    /**
     * The height, in pixels, of the selected heading bug.
     */
    headingBugHeight?: number;
    /** The width, in pixels, of the selected heading line. Defaults to the arc stroke width. */
    headingLineWidth?: number;
    /** The style of the selected heading line. Defaults to `'cyan'`. */
    headingLineStyle?: string | CanvasGradient | CanvasPattern;
    /**
     * The dash array of the selected heading line. Defaults to `[3 * width, 3 * width]`, where `width` is the width of
     * the heading line.
     */
    headingLineDash?: readonly number[];
    /**
     * The width, in pixels, of the reference arrow.
     */
    referenceArrowWidth?: number;
    /**
     * The height, in pixels, of the reference arrow.
     */
    referenceArrowHeight?: number;
}
/**
 * A map layer which draws a range compass in front of the map target.
 */
declare class MapRangeCompassLayer extends MapLayer<MapRangeCompassLayerProps> {
    /** The angular width of the compass arc, in degrees. */
    static readonly ARC_ANGULAR_WIDTH = 120;
    /** The angular interval, in degrees, between major bearing ticks. */
    static readonly BEARING_TICK_MAJOR_INTERVAL = 30;
    /** The number of minor bearing ticks per major bearing tick. */
    static readonly BEARING_TICK_MINOR_FACTOR = 3;
    /** The radial on which the range label is positioned, in degrees. */
    static readonly RANGE_LABEL_RADIAL_ANGLE = -135;
    private static readonly DEFAULT_ARC_STROKE_WIDTH;
    private static readonly DEFAULT_ARC_STROKE_COLOR;
    private static readonly DEFAULT_HEADING_LABEL_OUTLINE_WIDTH;
    private static readonly DEFAULT_HEADING_LABEL_OUTLINE_COLOR;
    private static readonly DEFAULT_HEADING_LABEL_RADIAL_OFFSET;
    private static readonly DEFAULT_HEADING_BUG_WIDTH;
    private static readonly DEFAULT_HEADING_BUG_HEIGHT;
    private static readonly DEFAULT_HEADING_LINE_STYLE;
    private static readonly DEFAULT_REF_ARROW_WIDTH;
    private static readonly DEFAULT_REF_ARROW_HEIGHT;
    private static readonly vec2Cache;
    private thisNode?;
    private readonly rootRef;
    private readonly arcLayerRef;
    private readonly roseLayerContainerRef;
    private readonly roseLayerRef;
    private readonly referenceMarkerContainerRef;
    private readonly roseLabelsLayerRef;
    private readonly headingIndicatorRef;
    private readonly rangeDisplayContainerRef;
    private readonly arcStrokeWidth;
    private readonly arcStrokeColor;
    private readonly arcEndTickLength;
    private readonly bearingLabelFontColor;
    private readonly bearingLabelOutlineWidth;
    private readonly bearingLabelOutlineColor;
    private readonly bearingLabelRadialOffset;
    private readonly referenceTickWidth;
    private readonly referenceTickHeight;
    private readonly headingBugWidth;
    private readonly headingBugHeight;
    private readonly headingLineWidth;
    private readonly headingLineStyle;
    private readonly headingLineDash;
    private readonly referenceArrowWidth;
    private readonly referenceArrowHeight;
    private readonly unitsModule;
    private readonly rangeModule;
    private readonly orientationModule;
    private readonly rangeCompassModule;
    private readonly isFollowingAirplane;
    private readonly centerSubject;
    private readonly radiusSubject;
    private readonly rotationSubject;
    private readonly magVarCorrectionSubject;
    private readonly referenceMarkerTypeSub;
    private needUpdateRootVisibility;
    private needRedrawArc;
    private needRedrawBearings;
    private needRotateBearingTicks;
    private needRechooseReferenceMarker;
    private needRepositionReferenceMarker;
    private needReclipTicks;
    private needUpdateHeadingIndicatorVisibility;
    private needRepositionLabel;
    private readonly subscriptions;
    /** @inheritdoc */
    onAfterRender(thisNode: VNode): void;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes listeners.
     */
    private initListeners;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates the visibility of this layer's root.
     */
    private updateRootVisibility;
    /**
     * Redraws the compass.
     */
    private redraw;
    /**
     * Redraws the arc of the compass.
     */
    private redrawArc;
    /**
     * Composes the path of the compass arc.
     * @param center The center of the compass, in pixels.
     * @param radius The radius of the compass, in pixels.
     * @param angularWidth The angular width of the arc, in radians.
     * @param leftTickStart The position of the start of the left end tick, in pixels.
     * @param leftTickEnd The position of the end of the left end tick, in pixels.
     * @param rightTickStart The position of the start of the right end tick, in pixels.
     * @param rightTickEnd The position of the end of the right end tick, in pixels.
     */
    private composeArcPath;
    /**
     * Redraws the bearing tick and labels.
     */
    private redrawBearings;
    /**
     * Updates the bearing tick clip mask.
     */
    private updateBearingTickClip;
    /**
     * Redraws the reference marker.
     */
    private updateReferenceMarker;
    /**
     * Updates the selected heading indicator.
     */
    private updateHeadingIndicator;
    /**
     * Updates the range display label.
     */
    private updateLabel;
    /**
     * Updates this layer's sublayers.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    private updateSubLayers;
    /**
     * Updates this layer's visibility.
     */
    private updateVisibility;
    /**
     * Updates the ring.
     */
    private updateParameters;
    /**
     * Responds to changes in the location of the center of the compass.
     */
    private onCenterChanged;
    /**
     * Responds to changes in the radius of the compass.
     */
    private onRadiusChanged;
    /**
     * Responds to changes in the rotation of the compass.
     */
    private onRotationChanged;
    /**
     * Responds to changes in the magnetic variation correction for the compass.
     */
    private onMagVarCorrectionChanged;
    /**
     * Responds to changes in the nominal map range.
     */
    private onRangeChanged;
    /**
     * Responds to changes in the map orientation.
     */
    private onOrientationChanged;
    /**
     * Responds to changes in whether to show the range ring.
     */
    private onRangeCompassShowChanged;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Renders the selected heading indicator.
     * @returns a VNode representing the range display label.
     */
    private renderSelectedHeadingIndicator;
    /**
     * Renders the range display label.
     * @returns a VNode representing the range display label.
     */
    private renderRangeDisplay;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required by MapRangeRingLayer.
 */
interface MapRangeRingLayerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapRangeModule;
    /** Range ring module. */
    [GarminMapKeys.RangeRing]: MapRangeRingModule;
    /** Display units module. */
    [GarminMapKeys.Units]?: MapUnitsModule;
}
/**
 * A function which renders labels for map range rings.
 */
type MapRangeRingLabelRenderer = (range: Subscribable<NumberUnitInterface<UnitFamily.Distance>>, displayUnit: Subscribable<Unit<UnitFamily.Distance>>) => VNode;
/**
 * Component props for MapRangeRingLayer.
 */
interface MapRangeRingLayerProps extends MapLayerProps<MapRangeRingLayerModules> {
    /** Whether to show the range label. */
    showLabel: boolean;
    /**
     * The radial on which the range label is positioned, in degrees. A value of zero is in the positive x direction.
     * Defaults to 225 degrees.
     */
    labelRadial?: number;
    /**
     * A function which renders labels for the rings. If not defined, a default label of type {@link MapRangeDisplay}
     * will be rendered.
     */
    renderLabel?: MapRangeRingLabelRenderer;
    /** The stroke width of the range ring, in pixels. Defaults to 2 pixels. */
    strokeWidth?: number;
    /** The stroke style of the range ring. Defaults to `'white'`. */
    strokeStyle?: string | CanvasGradient | CanvasPattern;
    /** The stroke dash of the range ring. Defaults to no dash. */
    strokeDash?: readonly number[];
    /** The outline width of the range ring, in pixels. Defaults to 0. */
    outlineWidth?: number;
    /** The outline style of the range ring. Defaults to `'black'`. */
    outlineStyle?: string | CanvasGradient | CanvasPattern;
    /** The outline dash of the range ring. Defaults to no dash. */
    outlineDash?: readonly number[];
}
/**
 * A map layer which draws a range ring around the map target.
 */
declare class MapRangeRingLayer extends MapLabeledRingLayer<MapRangeRingLayerProps> {
    private readonly rangeModule;
    private readonly rangeRingModule;
    private label;
    private needUpdateRing;
    /** @inheritdoc */
    protected updateFromVisibility(): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes the range display label.
     */
    private initLabel;
    /**
     * Initializes ring styles.
     */
    private initStyles;
    /**
     * Initializes modules listeners.
     */
    private initModuleListeners;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Updates this layer's visibility.
     */
    private updateVisibility;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates the ring.
     */
    private updateRing;
    /**
     * A callback which is called when the nominal map range changes.
     */
    private onRangeChanged;
}

/**
 * Modules required for {@link MapSharedFlightPlanLayer}.
 */
interface MapSharedFlightPlanLayerModules {
    /** Garmin flight plan module. */
    [GarminMapKeys.FlightPlan]: MapGarminFlightPlanModule;
}
/**
 * Component props for {@link MapSharedFlightPlanLayer}.
 */
interface MapSharedFlightPlanLayerProps extends MapLayerProps<MapSharedFlightPlanLayerModules> {
    /** The event bus. */
    bus: EventBus;
}
/**
 * A map layer that draws zero or more flight plans to a shared canvas.
 */
declare class MapSharedFlightPlanLayer extends MapLayer<MapSharedFlightPlanLayerProps> {
    private readonly canvasLayerRef;
    private readonly subs;
    /** @inheritDoc */
    onAttached(): void;
    /** @inheritDoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritDoc */
    onUpdated(time: number, elapsed: number): void;
    /** @inheritDoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapTrackVectorLayer.
 */
interface MapTrackVectorLayerModules {
    /** Own airplane properties module. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
    /** Track vector module. */
    [GarminMapKeys.TrackVector]: MapTrackVectorModule;
    /** Data integrity module. */
    [MapSystemKeys.DataIntegrity]?: MapDataIntegrityModule;
}
/**
 * Component props for MapTrackVectorLayer.
 */
interface MapTrackVectorLayerProps extends MapLayerProps<MapTrackVectorLayerModules> {
    /** The minimum turn rate of the player airplane, in degrees per second, required to draw the track vector as an arc. */
    arcTurnRateThreshold: number | Subscribable<number>;
    /** The maximum lookahead time for which the track vector can be drawn as an arc. */
    arcMaxLookaheadTime: NumberUnitInterface<UnitFamily.Duration> | Subscribable<NumberUnitInterface<UnitFamily.Duration>>;
    /** The width of the vector stroke, in pixels. Defaults to 2 pixels. */
    strokeWidth?: number;
    /** The style of the vector stroke. Defaults to `'cyan'`. */
    strokeStyle?: string;
    /** The width of the vector outline, in pixels. Defaults to 1 pixel. */
    outlineWidth?: number;
    /** The style of the vector outline. Defaults to `'#505050'`. */
    outlineStyle?: string;
}
/**
 * A map layer which displays a track vector.
 */
declare class MapTrackVectorLayer extends MapLayer<MapTrackVectorLayerProps> {
    private static readonly DEFAULT_STROKE_WIDTH;
    private static readonly DEFAULT_STROKE_STYLE;
    private static readonly DEFAULT_OUTLINE_WIDTH;
    private static readonly DEFAULT_OUTLINE_STYLE;
    private static readonly vec2Cache;
    private readonly canvasLayerRef;
    private readonly strokeWidth;
    private readonly strokeStyle;
    private readonly outlineWidth;
    private readonly outlineStyle;
    private readonly ownAirplanePropsModule;
    private readonly trackVectorModule;
    private readonly arcTurnRateThreshold;
    private readonly arcMaxLookaheadTime;
    private readonly projectedPlanePosition;
    private readonly projectPlanePositionHandler;
    private readonly turnRateSmoother;
    private isVectorVisible?;
    private needUpdate;
    private readonly subscriptions;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required by MapWaypointHighlightLayer.
 */
interface MapWaypointHighlightLayerModules {
    /** Waypoint highlight module. */
    [GarminMapKeys.WaypointHighlight]: MapWaypointHighlightModule;
}
/**
 * Component props for MapWaypointHighlightLayer
 */
interface MapWaypointHighlightLayerProps extends MapLayerProps<MapWaypointHighlightLayerModules> {
    /** The waypoint renderer to use. */
    waypointRenderer: MapWaypointRenderer;
}
/**
 * The map layer showing highlighted waypoints.
 */
declare class MapWaypointHighlightLayer extends MapSyncedCanvasLayer<MapWaypointHighlightLayerProps> {
    private registeredWaypoint;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes the waypoint renderer.
     */
    private initWaypointRenderer;
    /**
     * Initializes the waypoint highlight listener.
     */
    private initModuleListener;
    /**
     * A callback which is called when the highlighted waypoint changes.
     * @param waypoint The new highlighted waypoint.
     */
    private onWaypointChanged;
}

/**
 * Modules required by MapWaypointsLayer.
 */
interface MapWaypointsLayerModules {
    /** Waypoints module. */
    [MapSystemKeys.NearestWaypoints]: MapWaypointsModule;
}
/**
 * Component props for MapWaypointsLayer.
 */
interface MapWaypointsLayerProps extends MapLayerProps<MapWaypointsLayerModules> {
    /** The event bus. */
    bus: EventBus;
    /** The waypoint renderer to use. */
    waypointRenderer: MapWaypointRenderer;
    /** Whether to support the rendering of runway outlines. */
    supportRunwayOutlines: boolean;
    /**
     * A function that filters user facilities to be displayed by the layer based on their scopes. If not defined, then
     * user facilities will not be filtered based on scope.
     * @param scope A user facility scope.
     * @returns Whether to display the user facility with the specified scope.
     */
    userFacilityScopeFilter?: (scope: string) => boolean;
}
/**
 * A map layer which displays waypoints.
 */
declare class MapWaypointsLayer extends MapLayer<MapWaypointsLayerProps> {
    private static readonly SEARCH_ITEM_LIMITS;
    private readonly waypointsLayerRef;
    private readonly waypointsModule;
    private readonly waypointCache;
    private readonly runwayOutlineWaypointCache;
    private readonly runwayLabelWaypointCache;
    private isAirportVisible;
    private isVorVisible;
    private isNdbVisible;
    private isIntersectionVisible;
    private isUserVisible;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Initializes waypoint visibility flags and listeners.
     */
    private initVisibilityFlags;
    /**
     * Updates airport waypoint visibility.
     * @param size The airport size class to update.
     */
    private updateAirportVisibility;
    /**
     * Updates VOR waypoint visibility.
     */
    private updateVorVisibility;
    /**
     * Updates NDB waypoint visibility.
     */
    private updateNdbVisibility;
    /**
     * Updates intersection waypoint visibility.
     */
    private updateIntersectionVisibility;
    /**
     * Updates user waypoint visibility.
     */
    private updateUserVisibility;
    /** @inheritdoc */
    private initWaypointRenderer;
    /**
     * Responds to when this layer's facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     * @param userSession The user facility search session.
     */
    private onSessionsStarted;
    /**
     * Checks whether a waypoint is visible.
     * @param waypoint A waypoint.
     * @returns whether the waypoint is visible.
     */
    private isWaypointVisible;
    /** @inheritdoc */
    private shouldRefreshSearch;
    /**
     * Registers a waypoint with a renderer.
     * @param waypoint The waypoint to register.
     * @param renderer A waypoint renderer.
     */
    private registerWaypoint;
    /**
     * Deregisters a waypoint with a renderer.
     * @param waypoint The waypoint to deregister.
     * @param renderer A waypoint renderer.
     */
    private deregisterWaypoint;
    /**
     * Gets an array of runway outline and label waypoints from an airport.
     * @param airport An airport.
     * @returns An array of runway outline and label waypoints for the specified airport.
     */
    private getRunwayWaypoints;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Modules required for {@link MapWindVectorLayer}.
 */
interface MapWindVectorLayerModules {
    /** Wind vector module. */
    [GarminMapKeys.WindVector]: MapWindVectorModule;
}
/**
 * Component props for {@link MapWindVectorLayer}.
 */
type MapWindVectorLayerProps = MapLayerProps<MapWindVectorLayerModules>;
/**
 * A map layer which displays a readout of wind speed and an arrow depicting wind direction.
 */
declare class MapWindVectorLayer extends MapLayer<MapWindVectorLayerProps> {
    private static readonly SHOW_ARROW_WIND_SPEED_THRESHOLD;
    private static readonly SHOW_ARROW_WIND_SPEED_HYSTERESIS;
    private static readonly FORMATTER;
    private readonly windVectorModule;
    private readonly rootDisplay;
    private readonly arrowDisplay;
    private readonly arrowTransform;
    private readonly speedValue;
    private readonly show;
    private isAttached;
    private isAwake;
    private isPaused;
    private needUpdateArrow;
    private readonly pauseableSubs;
    private cssClassSub?;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onWake(): void;
    /** @inheritdoc */
    onSleep(): void;
    /**
     * Updates whether this layer is paused.
     */
    private updateIsPaused;
    /** @inheritdoc */
    onUpdated(): void;
    /**
     * Updates the rotation of this layer's arrow.
     */
    private updateArrow;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for TrafficMapRangeLayer.
 */
interface TrafficMapRangeLayerModules {
    /** Range module. */
    [GarminMapKeys.Range]: MapIndexedRangeModule;
    /** Traffic module. */
    [GarminMapKeys.Traffic]: MapGarminTrafficModule;
}
/**
 * A function which renders labels for traffic map range rings.
 */
type TrafficMapRangeLabelRenderer = (range: Subscribable<NumberUnitInterface<UnitFamily.Distance>>, displayUnit: Subscribable<Unit<UnitFamily.Distance>>) => VNode;
/**
 * Component props for TrafficMapRangeLayer.
 */
interface TrafficMapRangeLayerProps extends MapLayerProps<TrafficMapRangeLayerModules> {
    /** The stroke width of the outer range ring, in pixels. Defaults to 2 pixels. */
    outerStrokeWidth?: number;
    /** The stroke style of the outer range ring. Defaults to `'white'`. */
    outerStrokeStyle?: string | CanvasGradient | CanvasPattern;
    /** The stroke dash of the outer range ring. Defaults to `[4, 4]`. */
    outerStrokeDash?: readonly number[];
    /** The outline width of the outer range ring, in pixels. Defaults to 0 pixels. */
    outerOutlineWidth?: number;
    /** The outline style of the outer range ring. Defaults to `'black'`. */
    outerOutlineStyle?: string | CanvasGradient | CanvasPattern;
    /** The outline dash of the outer range ring. Defaults to `[]`. */
    outerOutlineDash?: readonly number[];
    /** The stroke width of the inner range ring, in pixels. Defaults to 2 pixels. */
    innerStrokeWidth?: number;
    /** The stroke style of the inner range ring. Defaults to `'white'`. */
    innerStrokeStyle?: string | CanvasGradient | CanvasPattern;
    /** The stroke dash of the inner range ring. Defaults to `[4, 4]`. */
    innerStrokeDash?: readonly number[];
    /** The outline width of the inner range ring, in pixels. Defaults to 0 pixels. */
    innerOutlineWidth?: number;
    /** The outline style of the inner range ring. Defaults to `'black'`. */
    innerOutlineStyle?: string | CanvasGradient | CanvasPattern;
    /** The outline dash of the inner range ring. Defaults to `[]`. */
    innerOutlineDash?: readonly number[];
    /** The color of the ring ticks. Defaults to `'white'`. */
    tickColor?: string;
    /** The color of the major outer ring ticks. Defaults to the value of `tickColor`. */
    outerMajorTickColor?: string;
    /** The size of the major outer ring ticks, in pixels. Defaults to 10 pixels. */
    outerMajorTickSize?: number;
    /** The color of the minor outer ring ticks. Defaults to the value of `tickColor`. */
    outerMinorTickColor?: string;
    /** The size of the minor outer ring ticks, in pixels. Defaults to 5 pixels. */
    outerMinorTickSize?: number;
    /** The color of the major inner ring ticks. Defaults to the value of `tickColor`. */
    innerMajorTickColor?: string;
    /** The size of the major inner ring ticks, in pixels. Defaults to 10 pixels. */
    innerMajorTickSize?: number;
    /** The color of the minor inner ring ticks. Defaults to the value of `tickColor`. */
    innerMinorTickColor?: string;
    /** The size of the minor inner ring ticks, in pixels. Defaults to 5 pixels. */
    innerMinorTickSize?: number;
    /**
     * The radial on which the outer range label is positioned, in degrees. A value of 0 degrees is in the direction of
     * the positive x axis. If `null`, the outer range label will not be displayed. Defaults to `null`.
     */
    outerLabelRadial?: number | null;
    /**
     * The radial on which the inner range label is positioned, in degrees. A value of 0 degrees is in the direction of
     * the positive x axis. If `null`, the inner range label will not be displayed. Defaults to `null`.
     */
    innerLabelRadial?: number | null;
    /**
     * A function which renders labels for the rings. If not defined, a default label of type {@link MapRangeDisplay}
     * will be rendered.
     */
    renderLabel?: TrafficMapRangeLabelRenderer;
}
/**
 * A map layer which displays inner and outer range rings for traffic maps.
 */
declare class TrafficMapRangeLayer extends MapLayer<TrafficMapRangeLayerProps> {
    private static readonly DEFAULT_STROKE_WIDTH;
    private static readonly DEFAULT_STROKE_STYLE;
    private static readonly DEFAULT_STROKE_DASH;
    private static readonly DEFAULT_OUTLINE_WIDTH;
    private static readonly DEFAULT_OUTLINE_STYLE;
    private static readonly DEFAULT_OUTLINE_DASH;
    private static readonly DEFAULT_TICK_COLOR;
    private static readonly DEFAULT_MAJOR_TICK_SIZE;
    private static readonly DEFAULT_MINOR_TICK_SIZE;
    private static readonly vec2Cache;
    private readonly canvasLayerRef;
    private readonly tickLayerRef;
    private readonly innerRingLayerRef;
    private readonly outerRingLayerRef;
    private readonly outerStrokeWidth;
    private readonly outerStrokeStyle;
    private readonly outerStrokeDash;
    private readonly outerOutlineWidth;
    private readonly outerOutlineStyle;
    private readonly outerOutlineDash;
    private readonly innerStrokeWidth;
    private readonly innerStrokeStyle;
    private readonly innerStrokeDash;
    private readonly innerOutlineWidth;
    private readonly innerOutlineStyle;
    private readonly innerOutlineDash;
    private readonly outerMajorTickColor;
    private readonly outerMajorTickSize;
    private readonly outerMinorTickColor;
    private readonly outerMinorTickSize;
    private readonly innerMajorTickColor;
    private readonly innerMajorTickSize;
    private readonly innerMinorTickColor;
    private readonly innerMinorTickSize;
    private readonly rangeModule;
    private readonly trafficModule;
    private readonly innerRange;
    private readonly outerRange;
    private innerRadius;
    private outerRadius;
    private innerLabel;
    private outerLabel;
    private needUpdateRings;
    private needUpdateTicks;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes the range display labels.
     */
    private initLabels;
    /**
     * Initializes ring styles.
     */
    private initStyles;
    /**
     * Initializes modules listeners.
     */
    private initModuleListeners;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates the rings.
     */
    private updateRings;
    /**
     * Updates this layer's ring tick marks.
     * @param context A canvas 2D rendering context to which to render the ticks.
     */
    private updateTicks;
    /**
     * Draws this layer's ring tick marks to a canvas. One major tick is drawn at each of the four cardinal positions,
     * and one minor tick is drawn at each of the eight remaining hour positions.
     * @param context A canvas 2D rendering context.
     * @param center The projected center of the outer ring.
     * @param radius The radius of the ring, in pixels.
     * @param majorTickColor The color of each major tick.
     * @param majorTickSize The size of each major tick, in pixels.
     * @param minorTickColor The color of each minor tick.
     * @param minorTickSize The size of each minor tick, in pixels.
     */
    private drawTicks;
    /**
     * Draws a ring tick to a canvas.
     * @param context A canvas 2D rendering context.
     * @param x The x-coordinate of the center of the tick.
     * @param y The y-coordinate of the center of the tick.
     * @param size The size of the tick, in pixels.
     */
    private drawTick;
    /**
     * Updates the inner ring range.
     */
    private updateInnerRange;
    /**
     * Updates the outer ring range.
     */
    private updateOuterRange;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Configuration options for MapTrafficIntruderIcon.
 */
type MapTrafficIntruderIconOptions = {
    /** The size of the icon, in pixels. */
    iconSize: number;
    /** The size of the icon font, in pixels. */
    fontSize: number;
    /** Whether to draw the icon if the intruder is off-scale. */
    drawOffScale: boolean;
    /** Whether to support the display of ADS-B motion vectors. */
    supportAdsbVector: boolean;
    /** Whether or not to force drawing of the non-arrow icons. */
    forceDrawNoArrow?: boolean;
    /** Whether or not to force TA and RA vectors to be drawn as normal motion vectors. */
    drawTARAVectorAsNormalVector?: boolean;
    /** Forces the motion vector length to a set pixel length. */
    vectorLength?: number;
};
/**
 * A view representation of a TCAS intruder for MapTrafficIntruderLayer.
 */
declare class MapTrafficIntruderIcon extends AbstractMapTrafficIntruderIcon {
    private readonly garminTrafficModule;
    private readonly followAirplaneModule;
    private readonly options;
    private static readonly VERTICAL_SPEED_THRESHOLD;
    private static readonly TA_COLOR;
    private static readonly TA_OFFSCALE_COLOR;
    private static readonly RA_COLOR;
    private static readonly RA_OFFSCALE_COLOR;
    private static readonly TIS_VECTOR_DIR_PRECISION;
    private static readonly TIS_VECTOR_LOOKAHEAD;
    private static readonly VECTOR_STROKE_WIDTH;
    private static readonly VECTOR_ABS_COLOR;
    private static readonly VECTOR_REL_COLOR;
    private static readonly VECTOR_LINE_DASH;
    private static readonly EMPTY_LINE_DASH;
    private static readonly vec2Cache;
    private readonly supportTisVector;
    private lastDrawnAltitudeValue?;
    private lastDrawnAltitudePrefix?;
    private altitudeText;
    /**
     * Constructor.
     * @param intruder This view's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The own airplane properties module for this icon's parent map.
     * @param garminTrafficModule The Garmin traffic module for this icon's parent map.
     * @param followAirplaneModule The follow airplane module for this icon's parent map.
     * @param options Configuration options for this icon.
     */
    constructor(intruder: TcasIntruder, trafficModule: MapTrafficModule, ownshipModule: MapOwnAirplanePropsModule, garminTrafficModule: MapGarminTrafficModule, followAirplaneModule: MapFollowAirplaneModule, options: MapTrafficIntruderIconOptions);
    /** @inheritdoc */
    protected drawIcon(projection: MapProjection, context: CanvasRenderingContext2D, projectedPos: ReadonlyFloat64Array, isOffScale: boolean): void;
    /**
     * Draws the icon without a directional arrow display.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param projectedPos The projected position of the intruder.
     * @param isOffScale Whether the intruder is off-scale.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    private drawNoArrowIcon;
    /**
     * Draws a diamond icon.
     * @param context The canvas rendering context to which to draw the icon.
     * @param isFilled Whether the diamond should be filled.
     */
    private drawDiamondIcon;
    /**
     * Draws a circle icon for TAs.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param projectedPos The projected position of the intruder.
     * @param isOffScale Whether the intruder is off-scale.
     */
    private drawCircleIcon;
    /**
     * Draws a square icon for RAs.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param projectedPos The projected position of the intruder.
     * @param isOffScale Whether the intruder is off-scale.
     */
    private drawSquareIcon;
    /**
     * Draws the icon with a directional arrow display.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param projectedPos The projected position of the intruder.
     * @param isOffScale Whether the intruder is off-scale.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    private drawArrowIcon;
    /**
     * Draws the icon's background when it has a directional arrow display.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param projectedPos The projected position of the intruder.
     * @param isOffScale Whether the intruder is off-scale.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    private drawArrowIconBackground;
    /**
     * Draws the icon's directional arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    private drawIconArrow;
    /**
     * Draws the icon's directional arrow background.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    private drawIconArrowBackground;
    /**
     * Draws the icon's directional arrow outline.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    private drawIconArrowOutline;
    /**
     * Draws the icon's vertical speed indicator arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    private drawIconVSArrow;
    /**
     * Draws the icon's altitude label.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    private drawIconAltitudeLabel;
    /**
     * Draws a TIS motion vector for this icon.
     * @param context The canvas rendering context to which to draw the vector.
     * @param projection The map projection.
     */
    private drawTisMotionVector;
    /**
     * Draws an ADS-B motion vector for this icon.
     * @param context The canvas rendering context to which to draw the vector.
     * @param projection The map projection.
     */
    private drawAdsbMotionVector;
    /**
     * Draws a motion vector projected to a certain lookahead time.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw the vector.
     * @param color The color of the vector.
     * @param vector The vector to draw.
     * @param lookaheadTime The lookahead time, in seconds.
     */
    private drawLookaheadVector;
    /**
     * Draws a motion vector projected to the point of closest horizontal approach (CPA).
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw the vector.
     * @param prediction The time of closest approach prediction to use.
     * @param color The color of the vector.
     * @param vector The vector to draw.
     */
    private drawCPAVector;
}

declare enum MapTrafficOffScaleStatus {
    None = 0,
    TA = 1,
    RA = 2
}

/**
 * A cache of images for runway designations.
 */
interface MapRunwayDesignationImageCache {
    /**
     * Retrieves an image from this cache for a runway number.
     * @param num The runway number for which to retrieve an image.
     * @returns The image for the specified runway number, or `undefined` if one could not be found.
     */
    getNumber(num: number): HTMLImageElement | undefined;
    /**
     * Retrieves an image from this cache for a runway designator.
     * @param designator The runway designator for which to retrieve an image.
     * @returns The image for the specified runway designator, or `undefined` if one could not be found.
     */
    getDesignator(designator: RunwayDesignator): HTMLImageElement | undefined;
}
/**
 * A default implementation of {@link MapRunwayDesignationImageCache}.
 */
declare class DefaultMapRunwayDesignationImageCache implements MapRunwayDesignationImageCache {
    protected readonly numberCache: Map<number, HTMLImageElement>;
    protected readonly designatorCache: Map<RunwayDesignator, HTMLImageElement>;
    /**
     * Registers an image with this cache for a runway number.
     * @param num The runway number for which to register the image.
     * @param src The source URI of the image to register.
     */
    registerNumber(num: number, src: string): void;
    /**
     * Registers an image with this cache for a runway designator.
     * @param designator The runway designator for which to register the image.
     * @param src The source URI of the image to register.
     */
    registerDesignator(designator: RunwayDesignator, src: string): void;
    /** @inheritdoc */
    getNumber(num: number): HTMLImageElement | undefined;
    /** @inheritdoc */
    getDesignator(designator: RunwayDesignator): HTMLImageElement | undefined;
}

/**
 * A waypoint for a map runway outline.
 */
declare class MapRunwayOutlineWaypoint extends AbstractWaypoint {
    readonly runway: AirportRunway;
    private static readonly TYPE;
    private readonly _uid;
    private readonly _location;
    /** The surface category of this waypoint's associated runway. */
    readonly surfaceCategory: _microsoft_msfs_sdk.RunwaySurfaceCategory;
    /** The primary runway number of this waypoint's associated runway. */
    readonly primaryNumber: number;
    /** The secondary runway number of this waypoint's associated runway, or `undefined` if there is no secondary runway. */
    readonly secondaryNumber: number | undefined;
    /**
     * Constructor.
     * @param airport The parent airport of the runway associated with this waypoint.
     * @param runway The runway associated with this waypoint.
     */
    constructor(airport: AirportFacility, runway: AirportRunway);
    /** @inheritdoc */
    get type(): string;
    /** @inheritdoc */
    get uid(): string;
    /** @inheritdoc */
    get location(): Subscribable<GeoPointInterface>;
    /**
     * Gets the unique ID for a MapRunwayLabelWaypoint associated with a given airport and runway.
     * @param airport The parent airport of the runway associated with the waypoint.
     * @param runway The runway associated with the waypoint.
     * @returns The unique ID for the waypoint associated with the specified airport and runway.
     */
    static getUid(airport: AirportFacility, runway: AirportRunway): string;
}

/**
 * Styling options for {@link MapRunwayOutlineIcon}.
 */
type MapRunwayOutlineIconOptions = {
    /** The fill style of the runway. Defaults to `'#afafaf'`. */
    fillStyle?: string | CanvasGradient | CanvasPattern | Subscribable<string | CanvasGradient | CanvasPattern>;
    /** The width of the runway outline, in pixels. Defaults to 1 pixel. */
    outlineWidth?: number | Subscribable<number>;
    /** The outline style of the runway. Defaults to `'white'`. */
    outlineStyle?: string | CanvasGradient | CanvasPattern | Subscribable<string | CanvasGradient | CanvasPattern>;
    /** The color of the runway markings. Defaults to `'white'`. */
    markingColor?: string | Subscribable<string>;
    /** Whether to draw centerline markings. Defaults to `true`. */
    drawCenterLine?: boolean | Subscribable<boolean>;
    /** Whether to draw threshold markings. Defaults to `true`. */
    drawThreshold?: boolean | Subscribable<boolean>;
    /** Whether to draw designation markings. Defaults to `true`. */
    drawDesignation?: boolean | Subscribable<boolean>;
    /** Whether to draw displaced threshold markings. Defaults to `true`. */
    drawDisplacedThreshold?: boolean | Subscribable<boolean>;
};
/**
 * An icon which depicts a schematic outline of a runway.
 */
declare class MapRunwayOutlineIcon implements MapWaypointIcon<MapRunwayOutlineWaypoint> {
    readonly waypoint: MapRunwayOutlineWaypoint;
    private static readonly CENTER_LINE_LENGTH;
    private static readonly CENTER_LINE_GAP;
    private static readonly CENTER_LINE_WIDTH_FACTOR;
    private static readonly CENTER_LINE_DASH_ARRAY;
    private static readonly THRESHOLD_BAR_LENGTH;
    private static readonly THRESHOLD_STRIPE_COUNT;
    private static readonly THRESHOLD_STRIPE_WIDTH_FACTOR;
    private static readonly THRESHOLD_STRIPE_LENGTH_FACTOR;
    private static readonly THRESHOLD_STRIPE_CENTER_GAP_FACTOR;
    private static readonly THRESHOLD_STRIPE_SIDE_MARGIN_FACTOR;
    private static readonly THRESHOLD_STRIPE_END_MARGIN_FACTOR;
    private static readonly DESIGNATION_WIDTH_FACTOR;
    private static readonly DESIGNATION_LENGTH_FACTOR;
    private static readonly DESIGNATION_GAP_FACTOR;
    private static readonly DISP_THRESHOLD_ARROW_STROKE_WIDTH_FACTOR;
    private static readonly DISP_THRESHOLD_ARROW_WIDTH_FACTOR;
    private static readonly DISP_THRESHOLD_ARROW_LENGTH_FACTOR;
    private static readonly DISP_THRESHOLD_ARROW_STEM_LENGTH_FACTOR;
    private static readonly DISP_THRESHOLD_ARROW_END_MARGIN_FACTOR;
    private static readonly DEFAULT_FILL_STYLE;
    private static readonly DEFAULT_OUTLINE_WIDTH;
    private static readonly DEFAULT_OUTLINE_STYLE;
    private static readonly DEFAULT_MARKING_COLOR;
    private static readonly vec2Cache;
    readonly priority: Subscribable<number>;
    private readonly fillStyle;
    private readonly outlineWidth;
    private readonly outlineStyle;
    private readonly markingColor;
    private readonly drawCenterLine;
    private readonly drawThreshold;
    private readonly drawDesignation;
    private readonly drawDisplacedThreshold;
    private readonly hasSecondary;
    private readonly hasDesignatorChar;
    private readonly usableLength;
    private readonly centerLineWidth;
    private readonly thresholdBarLength;
    private readonly thresholdStripeWidth;
    private readonly thresholdStripeCenterGap;
    private readonly thresholdStripeSideMargin;
    private readonly thresholdStripeGap;
    private readonly thresholdStripeEndMargin;
    private readonly thresholdStripeStart;
    private readonly thresholdStripeLength;
    private readonly designationWidth;
    private readonly designationGap;
    private readonly designationStart;
    private readonly desiredDesignationLength;
    private readonly desiredTotalDesignationLength;
    private readonly trueTotalDesignationLength;
    private readonly primaryDesignationNumberImg?;
    private readonly primaryDesignationDesignatorImg?;
    private readonly secondaryDesignationNumberImg?;
    private readonly secondaryDesignationDesignatorImg?;
    private readonly centerLineStart;
    private readonly dispThresholdArrowStrokeWidth;
    private readonly dispThresholdArrowWidth;
    private readonly dispThresholdArrowLength;
    private readonly dispThresholdArrowStemLength;
    private readonly dispThresholdArrowGapLength;
    private readonly dispThresholdArrowEndMargin;
    private readonly transform;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon, or a subscribable which provides it. Icons with higher
     * priorities should be rendered above those with lower priorities.
     * @param options Styling options.
     * @param designationImgCache The cache from which this icon retrieves runway designation images. If not defined,
     * this icon will not render runway designations.
     */
    constructor(waypoint: MapRunwayOutlineWaypoint, priority: number | Subscribable<number>, options?: Readonly<MapRunwayOutlineIconOptions>, designationImgCache?: MapRunwayDesignationImageCache);
    /** @inheritdoc */
    draw(context: CanvasRenderingContext2D, mapProjection: MapProjection): void;
    /**
     * Draws threshold and displaced threshold markings for a directional runway.
     * @param context The canvas 2D rendering context to which to render. The context should be transformed such that
     * the end of the runway lies at the origin and the direction of the runway points in the positive x direction, and
     * the scaling factor equals the local scaling factor of the map projection.
     * @param runwayWidth The width of the runway, in meters.
     * @param runwayHalfWidth The width of the runway divided by two, in meters.
     * @param displacedThresholdLength The length of the runway's displaced threshold, in meters.
     * @param numberImg The runway number image.
     * @param designatorImg The runway designator image.
     */
    private drawEndMarkings;
    /**
     * Draws a single unit of a displaced threshold end arrow pattern.
     * @param context The canvas 2D rendering context to which to render.
     * @param x The x coordinate of the top of the arrow, in meters.
     * @param y The y coordinate of the center of the arrow, in meters.
     */
    private drawDisplacedThresholdArrowEndPattern;
    /**
     * Draws a single unit of a displaced threshold centerline arrow pattern.
     * @param context The canvas 2D rendering context to which to render.
     * @param y The y coordinate of the start of the pattern unit, in meters.
     */
    private drawDisplacedThresholdArrowCenterPattern;
}

/**
 * An airport icon.
 */
declare class MapAirportIcon<T extends AirportWaypoint> extends MapWaypointSpriteIcon<T> {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img The image to use for the icon.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint: T, priority: number | Subscribable<number>, img: HTMLImageElement, size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, options?: AbstractMapWaypointIconOptions);
    protected getSpriteFrame(mapProjection: MapProjection): number;
}
/**
 * Initialization options for a MapWaypointHighlightIcon.
 */
type MapWaypointHighlightIconOptions = {
    /** The buffer of the ring around the base icon, in pixels. Defaults to `0`. */
    ringRadiusBuffer?: number | Subscribable<number>;
    /** The width of the stroke for the ring, in pixels. Defaults to `2`. */
    strokeWidth?: number | Subscribable<number>;
    /** The color of the stroke for the ring. Defaults to `'white'`. */
    strokeColor?: string | Subscribable<string>;
    /** The width of the outline for the ring, in pixels. Defaults to `0`. */
    outlineWidth?: number | Subscribable<number>;
    /** The color of the outline for the ring. Defaults to `'black'`. */
    outlineColor?: string | Subscribable<string>;
    /** The color of the ring background. Defaults to `'#3c3c3c'`. */
    bgColor?: string | Subscribable<string>;
};
/**
 * An icon for a highlighted waypoint. This icon embellishes a pre-existing ("base") icon with a surrounding ring and
 * background.
 */
declare class MapWaypointHighlightIcon<T extends Waypoint> extends AbstractMapWaypointIcon<T> {
    private readonly baseIcon;
    /** The buffer of the ring around this icon's base icon, in pixels. */
    readonly ringRadiusBuffer: Subscribable<number>;
    /** The width of the stroke for this icon's ring, in pixels. */
    readonly strokeWidth: Subscribable<number>;
    /** The color of the stroke for this icon's ring. */
    readonly strokeColor: Subscribable<string>;
    /** The width of the outline for this icon's ring, in pixels. */
    readonly outlineWidth: Subscribable<number>;
    /** The color of the outline for this icon's ring. */
    readonly outlineColor: Subscribable<string>;
    /** The color of this icon's ring background. */
    readonly bgColor: Subscribable<string>;
    /**
     * Constructor.
     * @param baseIcon This icon's base waypoint icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param options Options with which to initialize this icon.
     */
    constructor(baseIcon: AbstractMapWaypointIcon<T>, priority: number | Subscribable<number>, options?: MapWaypointHighlightIconOptions);
    /** @inheritdoc */
    protected drawIconAt(context: CanvasRenderingContext2D, mapProjection: MapProjection, left: number, top: number): void;
    /**
     * Draws the ring background for this icon.
     * @param context  A canvas rendering context.
     */
    private drawRingBackground;
    /**
     * Draws the ring for this icon.
     * @param context  A canvas rendering context.
     */
    private drawRing;
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context A canvas rendering context.
     * @param lineWidth The width of the stroke.
     * @param strokeStyle The style of the stroke.
     */
    private applyStroke;
}

/**
 * Map waypoint icon styles.
 */
type MapWaypointIconStyles = {
    /** The render priority of the icon. Icons with higher priority will be rendered on top of icons with lower priority. */
    priority: number | Subscribable<number>;
    /** The size of the icon, as `[width, height]` in pixels. */
    size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
};
/**
 * Map runway outline icon styles.
 */
type MapRunwayOutlineIconStyles = {
    /** The render priority of the icon. Icons with higher priority will be rendered on top of icons with lower priority. */
    priority: number | Subscribable<number>;
    /** Style options for the icon. */
    options?: MapRunwayOutlineIconOptions;
};
/**
 * Map highlighted waypoint icon styles.
 */
type MapWaypointIconHighlightStyles = MapWaypointIconStyles & {
    /** Style options for the highlight icon. */
    highlightOptions: MapWaypointHighlightIconOptions;
};
/**
 * Map waypoint label styles.
 */
type MapWaypointLabelStyles = {
    /**
     * The render priority of the label. Labels with higher priority will be rendered on top of labels with lower
     * priority. Moreover, labels with lower priority will be preferentially culled over labels with higher priority.
     */
    priority: number | Subscribable<number>;
    /** Whether the label is immune to culling. */
    alwaysShow: boolean | Subscribable<boolean>;
    /** Style options for the label. */
    options?: MapLocationTextLabelOptions;
};
/**
 * Configures how waypoints are rendered.
 */
interface MapWaypointDisplayBuilder {
    /**
     * Configures this builder to have the waypoint renderer use specific icon and label factories for certain render
     * roles.
     * @param roles The render roles for which to use the factories.
     * @param icon A function which creates the icon factory to use.
     * @param label A function which creates the label factory to use.
     * @returns This builder, after it has been configured.
     */
    withFactory(roles: number, icon: () => MapWaypointRendererIconFactory<Waypoint>, label: () => MapWaypointRendererLabelFactory<Waypoint>): this;
    /**
     * Configures this builder to have the waypoint renderer use specific icon and label styles for waypoints rendered
     * under the normal role. Icon and label factories which respect the specified styles will automatically be created
     * for the role.
     * @param iconStyleSelector A function which selects styles for icons.
     * @param labelStyleSelector A function which selects styles for labels.
     * @param runwayOutlineIconStyleSelector A function which selects styles for runway outline icons. If not defined,
     * runway outline icons will not be rendered.
     * @param runwayDesignationImgCache The image cache from which this factory retrieves runway designation images. If
     * not defined, runway designations will not be rendered.
     * @returns This builder, after it has been configured.
     */
    withNormalStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles, runwayOutlineIconStyleSelector?: (waypoint: MapRunwayOutlineWaypoint) => MapRunwayOutlineIconStyles, runwayDesignationImgCache?: MapRunwayDesignationImageCache): this;
    /**
     * Configures this builder to have the waypoint renderer use specific icon and label styles for waypoints rendered
     * under the inactive flight plan role. Icon and label factories which respect the specified styles will
     * automatically be created for the role.
     * @param iconStyleSelector A function which selects styles for icons.
     * @param labelStyleSelector A function which selects styles for labels.
     * @returns This builder, after it has been configured.
     */
    withFlightPlanInactiveStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /**
     * Configures this builder to have the waypoint renderer use specific icon and label styles for waypoints rendered
     * under the active flight plan role. Icon and label factories which respect the specified styles will automatically
     * be created for the role.
     * @param iconStyleSelector A function which selects styles for icons.
     * @param labelStyleSelector A function which selects styles for labels.
     * @returns This builder, after it has been configured.
     */
    withFlightPlanActiveStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /**
     * Configures this builder to have the waypoint renderer use specific icon and label styles for waypoints rendered
     * under the highlight role. Icon and label factories which respect the specified styles will automatically be
     * created for the role.
     * @param iconStyleSelector A function which selects styles for icons.
     * @param labelStyleSelector A function which selects styles for labels.
     * @returns This builder, after it has been configured.
     */
    withHighlightStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /**
     * Configures this builder to have the waypoint renderer use specific icon and label styles for waypoints rendered
     * under the VNAV role. Icon and label factories which respect the specified styles will automatically be created
     * for the role.
     * @param iconStyleSelector A function which selects styles for icons.
     * @param labelStyleSelector A function which selects styles for labels.
     * @returns This builder, after it has been configured.
     */
    withVNavStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /**
     * Configures this builder to have the waypoint renderer use specific icon and label styles for waypoints rendered
     * under the procedure preview role. Icon and label factories which respect the specified styles will automatically
     * be created for the role.
     * @param iconStyleSelector A function which selects styles for icons.
     * @param labelStyleSelector A function which selects styles for labels.
     * @returns This builder, after it has been configured.
     */
    withProcPreviewStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /**
     * Configures this builder to have the waypoint renderer use specific icon and label styles for waypoints rendered
     * under the procedure transition preview role. Icon and label factories which respect the specified styles will
     * automatically be created for the role.
     * @param iconStyleSelector A function which selects styles for icons.
     * @param labelStyleSelector A function which selects styles for labels.
     * @returns This builder, after it has been configured.
     */
    withProcTransitionPreviewStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
}
/**
 *
 */
declare class MapWaypointDisplayBuilderClass implements MapWaypointDisplayBuilder {
    private readonly factories;
    /** @inheritdoc */
    withFactory(roles: number, icon: () => MapWaypointRendererIconFactory<Waypoint>, label: () => MapWaypointRendererLabelFactory<Waypoint>): this;
    /** @inheritdoc */
    withNormalStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles, runwayOutlineIconStyleSelector?: (waypoint: MapRunwayOutlineWaypoint) => MapRunwayOutlineIconStyles, runwayDesignationImgCache?: MapRunwayDesignationImageCache): this;
    /** @inheritdoc */
    withFlightPlanInactiveStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /** @inheritdoc */
    withFlightPlanActiveStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /** @inheritdoc */
    withHighlightStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconHighlightStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /** @inheritdoc */
    withVNavStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconHighlightStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /** @inheritdoc */
    withProcPreviewStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /** @inheritdoc */
    withProcTransitionPreviewStyles(imgCache: WaypointIconImageCache, iconStyleSelector: (waypoint: Waypoint) => MapWaypointIconStyles, labelStyleSelector: (waypoint: Waypoint) => MapWaypointLabelStyles): this;
    /**
     * Applies this builder's configurations to a waypoint renderer.
     * @param renderer A waypoint renderer.
     */
    apply(renderer: MapWaypointRenderer): void;
}

/**
 * Styling options for the range ring.
 */
type RangeRingOptions = Omit<MapRangeRingLayerProps, keyof MapLayerProps<any>>;
/**
 * Styling options for the range compass.
 */
type RangeCompassOptions = Omit<MapRangeCompassLayerProps, keyof MapLayerProps<any> | 'bus'>;
/**
 * Styling options for the range compass heading bug.
 */
type RangeCompassHeadingBugOptions = {
    /** The width of the reference heading arrow, in pixels. */
    referenceArrowWidth: number;
    /** The height of the reference heading arrow, in pixels. */
    referenceArrowHeight: number;
    /** The width of the heading bug, in pixels. */
    headingBugWidth: number;
    /** The height of the heading bug, in pixels. */
    headingBugHeight: number;
};
/**
 * Options for the nearest waypoints layer.
 */
type GarminMapBuilderWaypointsLayerOptions = {
    /** Whether to support the rendering of airport runway outlines. Defaults to `false`. */
    supportRunwayOutlines?: boolean;
    /**
     * A function that filters user facilities to be displayed by the nearest waypoints layer based on their scopes. If
     * not defined, then user facilities will not be filtered based on scope.
     * @param scope A user facility scope.
     * @returns Whether to display the user facility with the specified scope.
     */
    userFacilityScopeFilter?: (scope: string) => boolean;
};
/**
 * A function that creates an entry describing the display of a flight plan.
 * @param context The context of the map for which to create the entry.
 * @returns An entry describing the display of a flight plan.
 */
type MapGarminFlightPlanEntryFactory = (context: MapSystemContext<EmptyRecord, EmptyRecord, EmptyRecord, any>) => MapGarminFlightPlanEntry;
/**
 * Options for the display of the active flight plan.
 */
type GarminMapBuilderActiveFlightPlanOptions = {
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
    /** Whether the entire primary flight plan should always be drawn. */
    drawEntirePlan: boolean | Subscribable<boolean>;
    /**
     * A function that creates a flight plan waypoint record manager to use to manage the waypoints to draw for the
     * flight plan.
     * @param context The map system context.
     * @param waypointRenderer The waypoint renderer used to draw the flight plan waypoints.
     * @returns A flight plan waypoint record manager to use to manage the waypoints to draw for the flight plan.
     */
    waypointRecordManagerFactory: (context: MapSystemContext<any, any, any, any>, waypointRenderer: MapWaypointRenderer) => MapFlightPlanWaypointRecordManager;
    /**
     * A function that creates a flight path renderer to use to draw the flight plan.
     * @param context The map system context.
     * @returns A flight path renderer to use to draw the flight plan.
     */
    pathRendererFactory: (context: MapSystemContext<any, any, any, any>) => MapFlightPathPlanRenderer;
    /**
     * Whether to support flight plan focus on the primary flight plan. If focus is supported, the primary flight plan
     * will be drawn when it is focused, regardless of whether it is active. Defaults to `false`.
     */
    supportFocus?: boolean;
};
/**
 * Options for the waypoint highlight line.
 */
type WaypointHighlightLineOptions = Omit<MapLineLayerProps, keyof MapLayerProps<any> | 'start' | 'end'>;
/**
 * Options for traffic intruder icons.
 */
type TrafficIconOptions = MapTrafficIntruderIconOptions & {
    /** The name of the icon font. */
    font: string;
};
/**
 * Options for the traffic map range rings.
 */
type TrafficRangeRingOptions = Omit<TrafficMapRangeLayerProps, keyof MapLayerProps<any>>;
/**
 * Options for the altitude intercept arc.
 */
type AltitudeArcOptions = Omit<MapAltitudeArcLayerProps, keyof MapLayerProps<any>>;
/**
 * Options for the track vector.
 */
type TrackVectorOptions = Omit<MapTrackVectorLayerProps, keyof MapLayerProps<any>>;
/** Callback functions for indicator groups. */
type IndicatorGroupCallbacks = Omit<MapGenericLayerProps<any>, keyof MapLayerProps<any>>;
/**
 * A builder for Garmin maps.
 */
declare class GarminMapBuilder {
    /**
     * Configures a map builder to add a module describing the player airplane's autopilot properties, and optionally
     * binds the module's properties to data received over the event bus.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.AutopilotProps]: MapGarminAutopilotPropsModule`
     *
     * Controllers:
     * * `[MapSystemKeys.AutopilotProps]: MapGarminAutopilotPropsController` (optional)
     * @param mapBuilder The map builder to configure.
     * @param propertiesToBind Properties on the autopilot module to bind to data received over the event bus.
     * @param updateFreq The update frequency, in hertz, of the data bindings, or a subscribable which provides it. If
     * not defined, the data bindings will update every frame. Ignored if `propertiesToBind` is undefined.
     * @returns This builder, after it has been configured.
     */
    static autopilotProps<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, propertiesToBind?: Iterable<MapGarminAutopilotPropsKey | MapGarminAutopilotPropsBinding>, updateFreq?: number | Subscribable<number>): MapBuilder;
    /**
     * Configures a map builder to generate a map with measurement unit support.
     *
     * Adds the module `[GarminMapKeys.Units]: MapUnitsModule`.
     * @param mapBuilder The map builder to configure.
     * @param settingManager A units setting manager to control the map's measurement units. If not defined, the map
     * will use a default set of measurement units.
     * @returns The map builder, after it has been configured.
     */
    static units<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, settingManager?: UnitsUserSettingManager): MapBuilder;
    /**
     * Configures a map builder to generate a map which supports multiple indexed ranges, with optional support for
     * controlling the map range with a user setting.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.RangeControl]: ResourceModerator<void>`
     * * `[GarminMapKeys.UseRangeSetting]: ResourceModerator<Subject<boolean>>` (only if user setting support is enabled)
     *
     * Modules:
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
     *
     * Controllers:
     * * `[GarminMapKeys.RangeRTR]: MapRangeRTRController`
     * * `[GarminMapKeys.Range]: MapRangeController` (can be used to control map range)
     * * `'useRangeSettingDefault': MapSystemCustomController` (only if user setting support is enabled)
     * @param mapBuilder The map builder to configure.
     * @param nauticalRangeArray The map range array to use for nautical distance mode. If not defined, a range array
     * will not automatically be set when entering nautical distance mode.
     * @param metricRangeArray The map range array to use for metric distance mode. If not defined, a range array will
     * not automatically be set when entering metric distance mode.
     * @param settingManager A setting manager containing a user setting to control the map range. If not defined, range
     * will not be controlled by a user setting.
     * @param useRangeSettingByDefault Whether the range user setting should control the map range by default. Defaults
     * to `true`. Is ignored if `settingManager` is undefined.
     * @returns The map builder, after it has been configured.
     */
    static range<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[], metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[], settingManager?: UserSettingManager<MapRangeControllerSettings>, useRangeSettingByDefault?: boolean): MapSystemBuilder;
    /**
     * Configures a map builder to generate a map which supports different orientations, as enumerated by
     * {@link MapOrientation}. Each orientation defines a different rotation behavior, target offset, and range
     * endpoints.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.RotationControl]: ResourceModerator<void>`
     * * `[GarminMapKeys.OrientationControl]: ResourceModerator<void>`
     * * `[GarminMapKeys.DesiredOrientationControl]: ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.Rotation]: MapRotationModule`
     * * `[GarminMapKeys.Orientation]: MapOrientationModule`
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Rotation]: MapRotationController`
     * * `[GarminMapKeys.OrientationRTR]: MapOrientationRTRController`
     * * `[GarminMapKeys.Orientation]: MapOrientationModeController`
     * * `[GarminMapKeys.DesiredOrientation]: MapDesiredOrientationController`
     * @param mapBuilder The map builder to configure.
     * @param nominalTargetOffsets The nominal projected target offsets defined by each orientation. Each target offset
     * is a 2-tuple `[x, y]`, where each component is expressed relative to the width or height of the map's projected
     * window, *excluding* the dead zone. If an orientation does not have a defined offset, it will default to `[0, 0]`.
     * @param nominalRangeEndpoints The nominal range endpoints defined by each orientation. Each set of range endpoints
     * is a 4-tuple `[x1, y1, x2, y2]`, where each component is expressed relative to the width or height of the map's
     * projected window, *excluding* the dead zone. If an orientation does not have defined range endpoints, it will
     * default to `[0.5, 0.5, 0.5, 0]` (center to top-center).
     * @returns The map builder, after it has been configured.
     */
    private static orientationBase;
    /**
     * Configures a map builder to generate a map which supports different orientations, as enumerated by
     * {@link MapOrientation}. Each orientation defines a different rotation behavior, target offset, and range
     * endpoints.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.RotationControl]: ResourceModerator<void>`
     * * `[GarminMapKeys.OrientationControl]: ResourceModerator<void>`
     * * `[GarminMapKeys.DesiredOrientationControl]: ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.Rotation]: MapRotationModule`
     * * `[GarminMapKeys.Orientation]: MapOrientationModule`
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Rotation]: MapRotationController`
     * * `[GarminMapKeys.OrientationRTR]: MapOrientationRTRController`
     * * `[GarminMapKeys.Orientation]: MapOrientationModeController`
     * * `[GarminMapKeys.DesiredOrientation]: MapDesiredOrientationController`
     * * `[GarminMapKeys.OrientationSettings]: MapOrientationSettingsController` (only with user setting support)
     * @param mapBuilder The map builder to configure.
     * @param nominalTargetOffsets The nominal projected target offsets defined by each orientation. Each target offset
     * is a 2-tuple `[x, y]`, where each component is expressed relative to the width or height of the map's projected
     * window, *excluding* the dead zone. If an orientation does not have a defined offset, it will default to `[0, 0]`.
     * @param nominalRangeEndpoints The nominal range endpoints defined by each orientation. Each set of range endpoints
     * is a 4-tuple `[x1, y1, x2, y2]`, where each component is expressed relative to the width or height of the map's
     * projected window, *excluding* the dead zone. If an orientation does not have defined range endpoints, it will
     * default to `[0.5, 0.5, 0.5, 0]` (center to top-center).
     * @param settingManager A setting manager containing user settings used to control the map orientation. If not
     * defined, map orientation will not be bound to user settings.
     * @returns The map builder, after it has been configured.
     */
    static orientation<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, nominalTargetOffsets?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>, nominalRangeEndpoints?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>, settingManager?: UserSettingManager<Partial<MapOrientationSettingsControllerSettings>>): MapBuilder;
    /**
     * Configures a map builder to generate a map which supports different weather map orientations, as enumerated by
     * {@link MapOrientation}. Each orientation defines a different rotation behavior, target offset, and range
     * endpoints.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.RotationControl]: ResourceModerator<void>`
     * * `[GarminMapKeys.OrientationControl]: ResourceModerator<void>`
     * * `[GarminMapKeys.DesiredOrientationControl]: ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.Rotation]: MapRotationModule`
     * * `[GarminMapKeys.Orientation]: MapOrientationModule`
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Rotation]: MapRotationController`
     * * `[GarminMapKeys.OrientationRTR]: MapOrientationRTRController`
     * * `[GarminMapKeys.Orientation]: MapOrientationModeController`
     * * `[GarminMapKeys.DesiredOrientation]: MapDesiredOrientationController`
     * * `[GarminMapKeys.OrientationSettings]: WeatherMapOrientationSettingsController` (only with user setting support)
     * @param mapBuilder The map builder to configure.
     * @param nominalTargetOffsets The nominal projected target offsets defined by each orientation. Each target offset
     * is a 2-tuple `[x, y]`, where each component is expressed relative to the width or height of the map's projected
     * window, *excluding* the dead zone. If an orientation does not have a defined offset, it will default to `[0, 0]`.
     * @param nominalRangeEndpoints The nominal range endpoints defined by each orientation. Each set of range endpoints
     * is a 4-tuple `[x1, y1, x2, y2]`, where each component is expressed relative to the width or height of the map's
     * projected window, *excluding* the dead zone. If an orientation does not have defined range endpoints, it will
     * default to `[0.5, 0.5, 0.5, 0]` (center to top-center).
     * @param settingManager A setting manager containing user settings used to control the map orientation. If not
     * defined, map orientation will not be bound to user settings.
     * @returns The map builder, after it has been configured.
     */
    static weatherOrientation<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, nominalTargetOffsets?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>, nominalRangeEndpoints?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>, settingManager?: UserSettingManager<Partial<WeatherMapOrientationSettingsControllerSettings>>): MapBuilder;
    /**
     * Configures a map builder to generate a map which supports data integrity state. During loss of valid heading
     * information, the map will default to North Up orientation, and the player airplane icon will optionally be changed
     * to reflect this state. During loss of valid GPS signal, the map will stop attempting to follow the player
     * airplane, and the player airplane icon will be hidden.
     * @param mapBuilder The map builder to configure.
     * @param airplaneIconSrc A mutable subscribable which controls the player airplane icon's image source URI.
     * Required for this controller to change the player airplane icon.
     * @param airplaneIconAnchor A mutable subscribable which controls the anchor point of the player airplane icon.
     * Required for this controller to change the player airplane icon.
     * @param normalIconSrc The URI of the normal player airplane icon's image source, or a subscribable which provides
     * it. Required for the player airplane icon to change during loss of valid heading information.
     * @param normalIconAnchor The anchor point of the normal player airplane icon, as `[x, y]`, where each component is
     * relative to the width or height of the icon, or a subscribable which provides it. Required for the player airplane
     * icon to change during loss of valid heading information.
     * @param noHeadingIconSrc The URI of the no-heading player airplane icon's image source, or a subscribable which
     * provides it. Required for the player airplane icon to change during loss of valid heading information.
     * @param noHeadingIconAnchor The anchor point of the no-heading player airplane icon, as `[x, y]`, where each
     * component is relative to the width or height of the icon, or a subscribable which provides it. Required for the
     * player airplane icon to change during loss of valid heading information.
     * @returns The map builder, after it has been configured.
     */
    static dataIntegrity<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, airplaneIconSrc?: MutableSubscribable<string>, airplaneIconAnchor?: MutableSubscribable<ReadonlyFloat64Array>, normalIconSrc?: string | Subscribable<string>, normalIconAnchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, noHeadingIconSrc?: string | Subscribable<string>, noHeadingIconAnchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>): MapBuilder;
    /**
     * Configures a map builder to generate a map which supports declutter modes, and optionally binds the declutter
     * mode to a user setting.
     * @param mapBuilder The map builder to configure.
     * @param settingManager A user setting manager containing the setting controlling declutter mode.
     * @returns The map builder, after it has been configured.
     */
    static declutter<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, settingManager?: UserSettingManager<{
        'mapDeclutter'?: MapDeclutterSettingMode;
    }>): MapBuilder;
    /**
     * Configures a map builder to generate a map which supports terrain color modes, and optionally binds the modes to
     * user settings.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule` (only with user settings support)
     * * `[GarminMapKeys.Terrain]: MapTerrainModule`
     *
     * Controllers:
     * * `[MapSystemKeys.TerrainColors]: MapTerrainColorsController`
     * * `[GarminMapKeys.Terrain]: MapTerrainController` (only with user settings support)
     * @param mapBuilder The map builder to configure.
     * @param colors The terrain colors to use for each terrain mode. Ignored if `includeTerrain` is `false`.
     * @param settingManager A user setting manager containing settings which control terrain colors. If not defined,
     * terrain color mode will not be controlled by user settings.
     * @param terrainModeOptions Options with which to configure the terrain mode controller. If a `boolean` value is
     * provided in place of an options object, then it will be interpreted as the `allowRelative` option. Ignored if
     * terrain colors is not controlled by user settings.
     * @param groundRelativeBlendDuration The amount of time, in milliseconds, over which to blend the on-ground and
     * relative terrain mode colors when transitioning between the two. A blend transition is only possible if colors
     * are defined for both the on-ground and relative terrain modes, and the colors for both modes have the same number
     * of steps and are applied over the same elevation range. Defaults to 0 milliseconds.
     * @returns The map builder, after it has been configured.
     */
    static terrainColors<MapBuilder extends MapSystemBuilder<{
        [MapSystemKeys.TerrainColors]: MapTerrainColorsModule;
    }>>(mapBuilder: MapBuilder, colors: Partial<Record<MapTerrainMode, MapTerrainColorsDefinition>>, settingManager?: UserSettingManager<Partial<MapTerrainUserSettings>>, terrainModeOptions?: Readonly<MapTerrainControllerOptions> | boolean, groundRelativeBlendDuration?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map which supports NEXRAD, and optionally binds the display of NEXRAD to
     * user settings.
     *
     * Requires the module `[MapSystemKeys.Weather]: MapWxrModule`.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
     * * `[GarminMapKeys.Nexrad]: MapNexradModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Weather]: MapWxrController`
     * * `[GarminMapKeys.Nexrad]: MapNexradController`
     * @param mapBuilder The map builder to configure.
     * @param minRangeIndex The minimum range index, inclusive, at which NEXRAD is visible. Defaults to `0`.
     * @param settingManager A user setting manager containing settings which control NEXRAD. If not defined, NEXRAD will
     * not be controlled by user settings.
     * @param maxDeclutterMode The highest global declutter mode, inclusive, at which NEXRAD is visible. Defaults
     * to `MapDeclutterMode.Level2`. Ignored if NEXRAD user settings are not supported.
     * @param colors The color array for the NEXRAD overlay. If not defined, default colors will be applied.
     * @returns The map builder, after it has been configured.
     */
    static nexrad<MapBuilder extends MapSystemBuilder<{
        [MapSystemKeys.Weather]: MapWxrModule;
    }>>(mapBuilder: MapBuilder, minRangeIndex?: number, settingManager?: UserSettingManager<Partial<MapNexradUserSettings>>, maxDeclutterMode?: MapDeclutterMode, colors?: readonly (readonly [number, number])[]): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays a range ring.
     *
     * Requires the modules defined in {@link MapRangeRingLayerModules} with the exception of `'rangeRing'`.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.RangeRing]: MapRangeRingModule`
     *
     * Layers:
     * * `[GarminMapKeys.RangeRing]: MapRangeRingLayer`
     * @param mapBuilder The map builder to configure.
     * @param options Styling options for the ring.
     * @param order The order to assign to the range ring layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static rangeRing<MapBuilder extends MapSystemBuilder<Omit<MapRangeRingLayerModules, typeof GarminMapKeys.RangeRing>>>(mapBuilder: MapBuilder, options: RangeRingOptions, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays a range compass. The range compass is displayed only in
     * Heading Up and Track Up orientation. If the map also supports a range ring, the range ring will be hidden while
     * the range compass is displayed.
     *
     * Requires the modules defined in {@link MapRangeCompassLayerModules} with the exception of `'rangeCompass'`.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.RangeCompass]: MapRangeCompassModule`
     *
     * Layers:
     * * `[GarminMapKeys.RangeCompass]: MapRangeCompassLayer`
     *
     * Controllers:
     * * `[GarminMapKeys.RangeCompass]: MapRangeCompassController`
     * @param mapBuilder The map builder to configure.
     * @param options Styling options for the compass.
     * @param order The order to assign to the range compass layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static rangeCompass<MapBuilder extends MapSystemBuilder<Omit<MapRangeCompassLayerModules, typeof GarminMapKeys.RangeCompass>>>(mapBuilder: MapBuilder, options: RangeCompassOptions, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays a crosshair at the projected target position when the
     * map is not following the player airplane. If the map does not have the module
     * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`, the map is assumed to never follow the player airplane,
     * and the crosshair will always be visible.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.Crosshair]: MapCrosshairModule`
     *
     * Layers:
     * * `[GarminMapKeys.Crosshair]: MapCrosshairLayer`
     *
     * Controllers:
     * * `[GarminMapKeys.Crosshair]: MapBindingsController`
     * @param mapBuilder The map builder to configure.
     * @returns The map builder, after it has been configured.
     */
    static crosshair<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder): MapBuilder;
    /**
     * Configures a map builder to generate a map which supports the display of waypoints located within the boundaries
     * of the map's projected window. Waypoints displayed in this manner are rendered by a {@link MapWaypointRenderer}
     * under the role {@link MapWaypointRenderRole.Normal}. Optionally binds the visibility of waypoints to user
     * settings.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.WaypointRenderer]: MapWaypointRenderer`
     * * `[GarminMapKeys.WaypointDisplayBuilder]: MapWaypointDisplayBuilder`
     *
     * Modules:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointsModule`
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule` (only if user settings are supported)
     *
     * Layers:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointsLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.WaypointRenderer]: MapSystemCustomController` (handles initialization and updating of the
     * waypoint renderer)
     * * `[GarminMapKeys.WaypointsVisibility]: MapWaypointsVisController` (only if user settings are supported)
     * @param mapBuilder The map builder to configure.
     * @param configure A function used to configure the display and styling of waypoint icons and labels.
     * @param settingManager A setting manager containing the user settings controlling waypoint visibility. If not
     * defined, waypoint visibility will not be bound to user settings.
     * @param options Options with which to configure the layer.
     * @param order The order to assign to the waypoint layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static waypoints<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, configure: (builder: MapWaypointDisplayBuilder, context: MapSystemContext<any, any, any, any>) => void, settingManager?: UserSettingManager<Partial<MapWaypointVisUserSettings>>, options?: Readonly<GarminMapBuilderWaypointsLayerOptions>, order?: number): MapBuilder;
    /**
     * Configures a map builder to bind the visibility of waypoints to user settings.
     *
     * Requires the modules defined in {@link MapWaypointsVisControllerModules}.
     *
     * Adds the controller `[GarminMapKeys.WaypointsVisibility]: MapWaypointsVisController`.
     * @param mapBuilder The map builder to configure.
     * @param settingManager A setting manager containing the user settings controlling waypoint visibility.
     * @param options Options with which to configure waypoint visibility.
     * @returns The map builder, after it has been configured.
     */
    static waypointVisSettings<MapBuilder extends MapSystemBuilder<MapWaypointsVisControllerModules>>(mapBuilder: MapBuilder, settingManager: UserSettingManager<Partial<MapWaypointVisUserSettings>>, options?: Readonly<MapWaypointsVisControllerOptions>): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays flight plans. The flight path and all waypoints that are
     * part of each flight plan are displayed. Waypoints displayed in this manner are rendered by a
     * {@link MapWaypointRenderer} under the roles {@link MapWaypointRenderRole.FlightPlanActive} or
     * {@link MapWaypointRenderRole.FlightPlanInactive} to a flight plan waypoint layer. Additionally, if VNAV is
     * supported, TOD and BOD markers will also be rendered under the role {@link MapWaypointRenderRole.VNav} to the same
     * waypoint layer.
     *
     * If a text layer has already been added to the builder, then its order will be changed so that it is rendered above
     * the flight plan layer and the flight plan waypoint layer. Otherwise, a text layer will be added to the builder
     * after the flight plan layer and the flight plan waypoint layer.
     *
     * The flight plans to display are taken from the map context property under the `GarminMapKeys.FlightPlan` key. The
     * property should be an array of {@link MapGarminFlightPlanEntryFactory} functions. Each function is evaluated to generate an
     * entry describing the display of a single flight plan. Each entry is then added to the
     * {@link MapGarminFlightPlanModule} stored under the `GarminMapKeys.FlightPlan` key.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.WaypointRenderer]: MapWaypointRenderer`
     * * `[GarminMapKeys.WaypointDisplayBuilder]: MapWaypointDisplayBuilder`
     *
     * Modules:
     * * `[GarminMapKeys.FlightPlan]: MapGarminFlightPlanModule`
     *
     * Layers:
     * * `[GarminMapKeys.FlightPlan]: MapSharedFlightPlanLayer`
     * * `[GarminMapKeys.FlightPlanWaypoints]: MapSyncedCanvasLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.WaypointRenderer]: MapSystemGenericController` (handles initialization and updating of the
     * waypoint renderer)
     * * `[GarminMapKeys.FlightPlanWaypoints]: MapSystemGenericController` (initializes the canvas contexts assigned to
     * the waypoint renderer's flight plan waypoint roles)
     * @param mapBuilder The map builder to configure.
     * @param configure A function used to configure the display and styling of flight plan waypoint icons and labels.
     * @param order The order to assign to the flight plan layers. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static sharedFlightPlans<MapBuilder extends MapSystemBuilder<any, any, any, {
        [GarminMapKeys.FlightPlan]?: MapGarminFlightPlanEntryFactory[];
    }>>(mapBuilder: MapBuilder, configure: (builder: MapWaypointDisplayBuilder, context: MapSystemContext<any, any, any, any>) => void, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays the active flight plan. The flight path and all
     * waypoints that are part of the flight plan are displayed. Waypoints displayed in this manner are rendered by a
     * {@link MapWaypointRenderer} under the roles {@link MapWaypointRenderRole.FlightPlanActive} or
     * {@link MapWaypointRenderRole.FlightPlanInactive} to a flight plan waypoint layer. Additionally, if VNAV is
     * supported, TOD and BOD markers will also be rendered under the role {@link MapWaypointRenderRole.VNav} to the same
     * waypoint layer.
     *
     * If a text layer has already been added to the builder, then its order will be changed so that it is rendered above
     * the flight plan layer and the flight plan waypoint layer. Otherwise, a text layer will be added to the builder
     * after the flight plan layer and the flight plan waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.WaypointRenderer]: MapWaypointRenderer`
     * * `[GarminMapKeys.WaypointDisplayBuilder]: MapWaypointDisplayBuilder`
     *
     * Modules:
     * * `[GarminMapKeys.FlightPlan]: MapGarminFlightPlanModule`
     *
     * Layers:
     * * `[GarminMapKeys.FlightPlan]: MapSharedFlightPlanLayer`
     * * `[GarminMapKeys.FlightPlanWaypoints]: MapSyncedCanvasLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.WaypointRenderer]: MapSystemGenericController` (handles initialization and updating of the
     * waypoint renderer)
     * * `[GarminMapKeys.FlightPlanWaypoints]: MapSystemGenericController` (initializes the canvas contexts assigned to
     * the waypoint renderer's flight plan waypoint roles)
     * * `'activeFlightPlanProvider': MapSystemGenericController` (handles the logic for selecting the active flight plan
     * to display)
     * @param mapBuilder The map builder to configure.
     * @param flightPlanner The flight planner from which to retrieve the active flight plan.
     * @param configure A function used to configure the display and styling of flight plan waypoint icons and labels.
     * @param options Options with which to configure the display of the active flight plan.
     * @param order The order to assign to the flight plan layers. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static activeFlightPlan<MapBuilder extends MapSystemBuilder<any, any, any, {
        [GarminMapKeys.FlightPlan]?: MapGarminFlightPlanEntryFactory[];
    }>>(mapBuilder: MapBuilder, flightPlanner: FlightPlanner | Subscribable<FlightPlanner>, configure: (builder: MapWaypointDisplayBuilder) => void, options: Readonly<GarminMapBuilderActiveFlightPlanOptions>, order?: number): MapBuilder;
    /**
     * Configures a map builder to provide entries describing the display of an active flight plan with support for
     * flight plan focus. Factories for the entries are added to the array stored in the map context under the
     * `GarminMapKeys.FlightPlan` key.
     *
     * Adds the controller `'activeFlightPlanProvider': MapSystemGenericController`.
     * @param mapBuilder The map builder to configure.
     * @param flightPlanner The flight planner from which to retrieve the active flight plan.
     * @param options Options with which to configure the display of the active flight plan.
     * @returns The map builder, after it has been configured.
     */
    private static activeFlightPlanWithFocusProvider;
    /**
     * Configures a map builder to provide entries describing the display of an active flight plan without support for
     * flight plan focus. Factories for the entries are added to the array stored in the map context under the
     * `GarminMapKeys.FlightPlan` key.
     *
     * Adds the controller `'activeFlightPlanProvider': MapSystemGenericController`.
     * @param mapBuilder The map builder to configure.
     * @param flightPlanner The flight planner from which to retrieve the active flight plan.
     * @param options Options with which to configure the display of the active flight plan.
     * @returns The map builder, after it has been configured.
     */
    private static activeFlightPlanNoFocusProvider;
    /**
     * Configures a map builder to generate a map which supports displaying a highlighted waypoint, and optionally
     * drawing a line from the highlighted waypoint to the position of the player airplane.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * highlighted waypoint layers. Otherwise, a text layer will be added to the builder after the highlighted waypoint
     * layers.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.WaypointRenderer]: MapWaypointRenderer`
     * * `[GarminMapKeys.WaypointDisplayBuilder]: MapWaypointDisplayBuilder`
     *
     * Modules:
     * * `[GarminMapKeys.WaypointHighlight]: MapWaypointHighlightModule`
     *
     * Layers:
     * * `[GarminMapKeys.WaypointHighlightLine]: MapLineLayer` (only if line support is included)
     * * `[GarminMapKeys.WaypointHighlight]: MapWaypointHighlightLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.WaypointRenderer]: MapSystemCustomController` (handles initialization and updating of the
     * waypoint renderer)
     * @param mapBuilder The map builder to configure.
     * @param includeLine Whether to include support for drawing a line from the highlighted waypoint to the player
     * airplane.
     * @param configure A function used to configure the display and styling of highlighted waypoint icons and labels.
     * @param lineOptions Styling options for the waypoint highlight line. The default values are the same as for
     * {@link MapLineLayer}, except the `strokeDash` property defaults to `[5, 3, 2, 3]`. Ignored if `includeLine` is
     * `false`.
     * @param order The order to assign to the highlighted waypoint layers. Layers with lower assigned order will be
     * attached to the map before and appear below layers with greater assigned order values. Defaults to the number of
     * layers already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static waypointHighlight<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, includeLine: boolean, configure: (builder: MapWaypointDisplayBuilder) => void, lineOptions?: Readonly<WaypointHighlightLineOptions>, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays airspaces, and optionally binds the visibility of
     * airspaces to user settings.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.AirspaceManager]: GenericAirspaceRenderManager`
     *
     * Modules:
     * * `[MapSystemKeys.Airspace]: MapAirspaceModule`
     *
     * Layers:
     * * `[MapSystemKeys.Airspace]: MapAirspaceLayer`
     *
     * Controllers:
     * * `[GarminMapKeys.AirspaceVisibility]: MapAirspaceVisController` (only with user settings support)
     * @param mapBuilder The map builder to configure.
     * @param settingManager A setting manager containing the user settings controlling airspace visibility. If not
     * defined, airspace visibility will not be controlled by user settings.
     * @param order The order to assign to the airspace layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static airspaces<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, settingManager?: UserSettingManager<Partial<MapAirspaceVisUserSettings>>, order?: number): MapBuilder;
    /**
     * Configures a map builder to bind the visibility of airspaces to user settings.
     *
     * Requires the modules defined in {@link MapAirspaceVisControllerModules}.
     *
     * Adds the controller `[GarminMapKeys.AirspaceVisibility]: MapAirspaceVisController`.
     * @param mapBuilder The map builder to configure.
     * @param settingManager A setting manager containing the user settings controlling airspace visibility.
     * @returns The map builder, after it has been configured.
     */
    static airspaceVisSettings<MapBuilder extends MapSystemBuilder<MapAirspaceVisControllerModules>>(mapBuilder: MapBuilder, settingManager: UserSettingManager<Partial<MapAirspaceVisUserSettings>>): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays TCAS intruders.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`
     * * `[MapSystemKeys.Traffic]: MapTrafficModule`
     * * `[GarminMapKeys.Traffic]: MapGarminTrafficModule`
     *
     * Layers:
     * * `[MapSystemKeys.Traffic]: MapSystemTrafficLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.Traffic]: MapTrafficController`
     * * `[GarminMapKeys.Traffic]: MapGarminTrafficController` (only with user settings support)
     * @param mapBuilder The map builder to configure.
     * @param trafficSystem The traffic system from which to derive intruder data.
     * @param iconOptions Configuration options for intruder icons.
     * @param useOuterRangeAsOffScale Whether to use the outer traffic range defined in {@link MapGarminTrafficModule} as
     * the off-scale traffic range.
     * @param offScaleStatus A mutable subscribable to update with the layer's off-scale traffic status.
     * @param iconFactory A function which creates intruder icons for the traffic display. If not defined, a default icon
     * of type {@link MapTrafficIntruderIcon} is created for each intruder.
     * @param initCanvasStyles A function which initializes global canvas styles for the traffic display.
     * @param trafficSettingManager A setting manager containing user settings controlling the operation of the traffic
     * system. If not defined, the display of map traffic will not be controlled by those settings.
     * @param mapSettingManager A setting manager containing user settings controlling the display of traffic on maps. If
     * not defined, the display of map traffic will not be controlled by those settings.
     * @param order The order to assign to the traffic layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static traffic<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, trafficSystem: TrafficSystem, iconOptions: TrafficIconOptions, useOuterRangeAsOffScale: boolean, offScaleStatus?: MutableSubscribable<MapTrafficOffScaleStatus>, iconFactory?: MapTrafficIntruderIconFactory, initCanvasStyles?: (context: CanvasRenderingContext2D) => void, trafficSettingManager?: UserSettingManager<Partial<TrafficUserSettingTypes>>, mapSettingManager?: UserSettingManager<Partial<MapTrafficUserSettings>>, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map which supports multiple indexed traffic map ranges, with optional
     * support for controlling the map range with a user setting. At each range index there is an outer range and an
     * inner range, except for the first index, at which there is just an outer range. The inner range is always the
     * largest range in the range array that is less than the outer range.
     *
     * Requires the module `[GarminMapKeys.Traffic]: MapGarminTrafficModule`.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[GarminMapKeys.UseRangeSetting]: ResourceModerator<Subject<boolean>>` (only if user setting support is enabled)
     *
     * Modules:
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule`
     *
     * Controllers:
     * * `[GarminMapKeys.RangeRTR]: MapRangeRTRController`
     * * `[GarminMapKeys.TrafficRange]: TrafficMapRangeController` (can be used to control map range)
     * * `'useRangeSettingDefault': MapSystemCustomController` (only if user setting support is enabled)
     * @param mapBuilder The map builder to configure.
     * @param nauticalRangeArray The map range array to use for nautical distance mode. If not defined, a range array
     * will not automatically be set when entering nautical distance mode.
     * @param metricRangeArray The map range array to use for metric distance mode. If not defined, a range array will
     * not automatically be set when entering metric distance mode.
     * @param settingManager A setting manager containing a user setting to control the map range. If not defined, range
     * will not be controlled by a user setting.
     * @param useRangeSettingByDefault Whether the range user setting should control the map range by default. Defaults
     * to `true`. Is ignored if `settingManager` is undefined.
     * @returns The map builder, after it has been configured.
     */
    static trafficRange<MapBuilder extends MapSystemBuilder<{
        [GarminMapKeys.Traffic]: MapGarminTrafficModule;
    }>>(mapBuilder: MapBuilder, nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[], metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[], settingManager?: UserSettingManager<TrafficMapRangeControllerSettings>, useRangeSettingByDefault?: boolean): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays traffic range rings. There are two rings: an outer and
     * an inner ring. Each ring has tick marks at the 12 clock positions, with major ticks at the 4 cardinal positions.
     * Each ring also has an optional label which displays the range marked by the ring.
     *
     * Requires the modules defined in {@link TrafficMapRangeLayerModules}.
     *
     * Adds the layer `[GarminMapKeys.TrafficRange]: TrafficMapRangeLayer`.
     * @param mapBuilder The map builder to configure.
     * @param ringOptions Styling options for the rings.
     * @param order The order to assign to the ring layer. Layers with lower assigned order will be attached to the map
     * before and appear below layers with greater assigned order values. Defaults to the number of layers already added
     * to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static trafficRangeRings<MapBuilder extends MapSystemBuilder<TrafficMapRangeLayerModules>>(mapBuilder: MapBuilder, ringOptions?: TrafficRangeRingOptions, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map with pointer support. Activating the pointer allows the pointer to
     * control map panning and stops the map from actively rotating.
     *
     * If map target, orientation, or rotation control resource moderators exist on the map context, the panning RTR
     * controller will attempt to claim those resources with a priority of `100`. Otherwise, the controller assumes
     * nothing else controls the map target or rotation.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.Panning]: MapPanningModule`
     * * `[GarminMapKeys.Pointer]: MapPointerModule`
     *
     * Layers:
     * * `[GarminMapKeys.Pointer]: MapPointerLayer`
     *
     * Controllers:
     * * `[GarminMapKeys.PanningRTR]: MapPanningRTRController`
     * * `[GarminMapKeys.Pointer]: MapPointerController` (can be used to control the behavior of the pointer)
     * * `[GarminMapKeys.PointerRTR]: MapPointerRTRController`
     * @param mapBuilder The map builder to configure.
     * @param pointerBoundsOffset The offset of the boundary surrounding the area in which the pointer can freely move,
     * from the edge of the projected map, excluding the dead zone, or a subscribable which provides it. Expressed as
     * `[left, top, right, bottom]`, relative to the width and height, as appropriate, of the projected map window. A
     * positive offset is directed toward the center of the map.
     * @param icon The pointer icon to render, as a VNode. If not default, a default icon will be rendered.
     * @param order The order to assign to the pointer layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static pointer<MapBuilder extends MapSystemBuilder<any, any, any, MapPanningRTRControllerContext>>(mapBuilder: MapBuilder, pointerBoundsOffset: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, icon?: VNode, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays a pointer information box when the pointer is active.
     *
     * Requires the modules defined in {@link MapPointerInfoLayerModules}.
     *
     * Adds the layer `[GarminMapKeys.PointerInfo]: MapPointerInfoLayer`.
     * @param mapBuilder The map builder to configure.
     * @param size The size of the pointer information box.
     * @param order The order to assign to the pointer information layer. Layers with lower assigned order will be
     * attached to the map before and appear below layers with greater assigned order values. Defaults to the number of
     * layers already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static pointerInfo<MapBuilder extends MapSystemBuilder<MapPointerInfoLayerModules>>(mapBuilder: MapBuilder, size: MapPointerInfoLayerSize, order?: number): MapBuilder;
    /**
     * Configures the map builder to generate a map which supports flight plan focus. Flight plan focus automatically
     * adjusts the map's target and range to place a portion of a flight plan into view.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.FlightPlanFocus]: MapFlightPlanFocusModule`
     *
     * Controllers:
     * * `[GarminMapKeys.FlightPlanFocus]: MapFlightPlanFocusRTRController`
     * @param mapBuilder The map builder to configure.
     * @param nominalFocusMargins A subscribable which provides the nominal focus margins, as
     * `[left, top, right, bottom]` in pixels. The nominal margins define the offset of the boundaries of the focus
     * region relative to the map's projected window, *excluding* the dead zone. Positive values represent offsets
     * toward the center of the window. When the flight plan is focused, the focused elements of the plan are guaranteed
     * to be contained within the focus region.
     * @param defaultFocusRangeIndex The default map range index to apply when the flight plan focus consists of only a
     * single point in space.
     * @param focusDebounceDelay The debounce delay, in milliseconds, to apply to focus target calculations when the
     * flight plan focus changes. Defaults to 500 milliseconds.
     * @returns The map builder, after it has been configured.
     */
    static flightPlanFocus<MapBuilder extends MapSystemBuilder<Omit<MapFlightPlanFocusRTRControllerModules, typeof GarminMapKeys.FlightPlanFocus>, any, any, MapFlightPlanFocusRTRControllerContext>>(mapBuilder: MapBuilder, nominalFocusMargins?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, defaultFocusRangeIndex?: number, focusDebounceDelay?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map with an altitude intercept arc, and optionally binds the display of the
     * arc to a user setting.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.AltitudeArc]: MapAltitudeArcModule`
     *
     * Layers:
     * * `[MapSystemKeys.AltitudeArc]: MapAltitudeArcLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.AltitudeArc]: MapBindingsController` (only if user settings are supported)
     * @param mapBuilder The map builder to configure.
     * @param options Options for the arc.
     * @param settingManager A setting manager containing user settings used to control the display of the arc. If not
     * defined, the display of the arc will not be bound to user settings.
     * @param order The order to assign to the altitude arc layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static altitudeArc<MapBuilder extends MapSystemBuilder<Omit<MapAltitudeArcLayerModules, typeof MapSystemKeys.AltitudeArc>>>(mapBuilder: MapBuilder, options: AltitudeArcOptions, settingManager?: UserSettingManager<{
        'mapAltitudeArcShow'?: boolean;
    }>, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map with a track vector, and optionally binds the display options of the
     * vector to user settings.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.TrackVector]: MapTrackVectorModule`
     *
     * Layers:
     * * `[GarminMapKeys.TrackVector]: MapTrackVectorLayer`
     *
     * Controllers:
     * * `[GarminMapKeys.TrackVector]: MapBindingsController` (only if user settings are supported)
     * @param mapBuilder The map builder to configure.
     * @param options Options for the track vector.
     * @param settingManager A setting manager containing user settings used to control the track vector. If not defined,
     * the track vector will not be bound to user settings.
     * @param order The order to assign to the track vector layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static trackVector<MapBuilder extends MapSystemBuilder<Omit<MapTrackVectorLayerModules, typeof GarminMapKeys.TrackVector>>>(mapBuilder: MapBuilder, options: TrackVectorOptions, settingManager?: UserSettingManager<{
        'mapTrackVectorShow'?: boolean;
        'mapTrackVectorLookahead'?: number;
    }>, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map with a wind vector, and optionally binds the display options of the
     * vector to user settings.
     *
     * Adds the following...
     *
     * Modules:
     * * `[GarminMapKeys.WindVector]: MapWindVectorModule`
     *
     * Layers:
     * * `[GarminMapKeys.WindVector]: MapWindVectorLayer`
     *
     * Controllers:
     * * `[GarminMapKeys.WindVector]: MapWindVectorController` (only if user settings are supported)
     * @param mapBuilder The map builder to configure.
     * @param dataProvider A provider of wind data.
     * @param settingManager A setting manager containing user settings used to control the wind vector. If not defined,
     * the wind vector will not be bound to user settings.
     * @param order The order to assign to the wind vector layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static windVector<MapBuilder extends MapSystemBuilder<Omit<MapTrackVectorLayerModules, typeof GarminMapKeys.TrackVector>>>(mapBuilder: MapBuilder, dataProvider: WindDataProvider, settingManager?: UserSettingManager<Partial<MapWindVectorUserSettings>>, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map which displays a miniature compass.
     *
     * Adds the layer `GarminMapKeys.MiniCompass: MapMiniCompassLayer`.
     * @param mapBuilder The map builder to configure.
     * @param imgSrc The URI of the mini-compass's image asset.
     * @param order The order to assign to the mini-compass layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static miniCompass<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, imgSrc: string, order?: number): MapBuilder;
    /**
     * Configures a map builder to generate a map which supports a flight plan procedure preview.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * highlighted waypoint layers. Otherwise, a text layer will be added to the builder after the highlighted waypoint
     * layers.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.WaypointRenderer]: MapWaypointRenderer`
     * * `[GarminMapKeys.WaypointDisplayBuilder]: MapWaypointDisplayBuilder`
     *
     * Modules:
     * * `[GarminMapKeys.ProcedurePreview]: MapProcedurePreviewModule`
     *
     * Layers:
     * * `[GarminMapKeys.ProcedurePreview]: MapProcedurePreviewLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.WaypointRenderer]: MapSystemCustomController` (handles initialization and updating of the
     * waypoint renderer)
     * @param mapBuilder The map builder to configure.
     * @param pathRenderer The flight path renderer to use to render the procedure preview.
     * @param configure A function used to configure the display and styling of procedure preview waypoint icons and
     * labels.
     * @param order The order to assign to the highlighted waypoint layers. Layers with lower assigned order will be
     * attached to the map before and appear below layers with greater assigned order values. Defaults to the number of
     * layers already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static procPreview<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, pathRenderer: MapFlightPathProcRenderer, configure: (builder: MapWaypointDisplayBuilder) => void, order?: number): MapBuilder;
    /**
     * Configures a map builder to include an indicator group.
     * @param mapBuilder The map builder to configure.
     * @param key The key of the indicator group.
     * @param indicatorFactories An array of functions which create the indicators. The order of functions in the array
     * determines the order in which the created indicators will be added to the group.
     * @param callbacks Optional callback functions to register with the indicator group.
     * @param cssClass The CSS class(es) to apply to the root of the indicator group.
     * @param order The order to assign to the layer containing the indicator group. Layers with lower assigned order
     * will be attached to the map before and appear below layers with greater assigned order values. Defaults to the
     * number of layers already added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static indicatorGroup<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, key: string, indicatorFactories: ReadonlyArray<(context: MapBuilder extends MapSystemBuilder<infer M, infer L, infer C, infer Context> ? MapSystemContext<M, L, C, Context> : never) => VNode>, callbacks?: IndicatorGroupCallbacks, cssClass?: string | SubscribableSet<string>, order?: number): MapBuilder;
}

/**
 * Options for creating a next-generation (NXi, G3000, etc) Garmin Connext weather map.
 */
type NextGenConnextMapOptions = {
    /** The ID to assign to the map's bound Bing Map instance. */
    bingId: string;
    /** The amount of time, in milliseconds, to delay binding the map's Bing Map instance. Defaults to 0. */
    bingDelay?: number;
    /** The frequency, in hertz, with which player airplane and autopilot properties are updated from event bus data. */
    dataUpdateFreq: number | Subscribable<number>;
    /** The image cache from which to retrieve waypoint icon images. */
    waypointIconImageCache: WaypointIconImageCache;
    /** The font type to use for waypoint labels. */
    waypointStyleFontType: 'Roboto' | 'DejaVu';
    /** The scaling factor of waypoint icons and labels. Defaults to `1`. */
    waypointStyleScale?: number;
    /**
     * The nominal projected target offset of the map for each orientation mode, as `[x, y]`, where each component is
     * expressed relative to the width or height of the map's projected window, *excluding* the dead zone. Defaults to
     * the following:
     * ```
     * {
     *   [MapOrientation.NorthUp]: [0, 0],
     *   [MapOrientation.HeadingUp]: [0, 0.17],
     *   [MapOrientation.TrackUp]: [0, 0.17]
     * }
     * ```
     */
    targetOffsets?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>;
    /**
     * The range endpoints of the map for each orientation mode, as `[x1, y1, x2, y2]`, where each component is expressed
     * relative to the width or height of the map's projected window, *excluding* the dead zone. Defaults to the
     * following:
     * ```
     * {
     *   [MapOrientation.NorthUp]: [0.5, 0.5, 0.5, 0.25],
     *   [MapOrientation.HeadingUp]: [0.5, 0.67, 0.5, 0.33],
     *   [MapOrientation.TrackUp]: [0.5, 0.67, 0.5, 0.33]
     * }
     * ```
     */
    rangeEndpoints?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>;
    /** The map range array to use for nautical units mode. Defaults to a standard range array. */
    nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** The map range array to use for metric units mode. Defaults to a standard range array. */
    metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** Whether to support data integrity state. Defaults to `true`. */
    supportDataIntegrity?: boolean;
    /** The URI of the no-heading player airplane icon's image asset, or a subscribable which provides it. */
    noHeadingAirplaneIconSrc?: string | Subscribable<string>;
    /**
     * The point on the no-heading player airplane icon that is anchored to the airplane's position, or a subscribable
     * which provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the
     * top left and [1, 1] at the bottom right.
     */
    noHeadingAirplaneIconAnchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The text of the banner that is displayed when GPS position is not available. Defaults to `'NO GPS POSITION'`. */
    noGpsBannerText?: string;
    /** Styling options for the range ring. */
    rangeRingOptions: RangeRingOptions;
    /** Styling options for the range compass. */
    rangeCompassOptions: RangeCompassOptions;
    /** Whether to display airport runway outlines. Defaults to `false`. */
    includeRunwayOutlines?: boolean;
    /**
     * The image cache from which to retrieve runway designation images. If not defined, runway designations will not be
     * rendered. Ignored if `includeRunwayOutlines` is `false`.
     */
    runwayDesignationImageCache?: MapRunwayDesignationImageCache;
    /**
     * A function that filters user facilities to be displayed by the nearest waypoints layer based on their scopes. If
     * not defined, then user facilities will not be filtered based on scope.
     * @param scope A user facility scope.
     * @returns Whether to display the user facility with the specified scope.
     */
    userFacilityScopeFilter?: (scope: string) => boolean;
    /** Whether to display airspaces. Defaults to `true`. */
    includeAirspaces?: boolean;
    /** The URI of the player airplane icon's image asset */
    airplaneIconSrc: string | Subscribable<string>;
    /** The size of the player airplane icon, in pixels. */
    airplaneIconSize: number;
    /**
     * The point on the player airplane icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the top
     * left and [1, 1] at the bottom right.
     */
    airplaneIconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The flight planner containing the active flight plan. Required to display the active flight plan. */
    flightPlanner?: FlightPlanner;
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
    /** Whether to include the track vector display. Defaults to `true`. */
    includeTrackVector?: boolean;
    /** Whether to include the altitude intercept arc display. Defaults to `true`. */
    includeAltitudeArc?: boolean;
    /** Whether to include the wind vector display. Defaults to `true`. Ignored if `windDataProvider` is not defined. */
    includeWindVector?: boolean;
    /** A provider of wind data for the wind vector. Required to display the wind vector. */
    windDataProvider?: WindDataProvider;
    /**
     * The offset of the boundary surrounding the area in which the pointer can freely move, from the edge of the
     * projected map, excluding the dead zone, or a subscribable which provides it. Expressed as
     * `[left, top, right, bottom]`, relative to the width and height, as appropriate, of the projected map window. A
     * positive offset is directed toward the center of the map. Required to support the map pointer.
     */
    pointerBoundsOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The size of the pointer information box. Required to display the pointer information box. Ignored if the map
     * pointer is not supported.
     */
    pointerInfoSize?: MapPointerInfoLayerSize;
    /** The URI of the mini-compass's image asset. Required to display the mini-compass. */
    miniCompassImgSrc?: string;
    /** Whether to include an orientation indicator. Defaults to `true`. */
    includeOrientationIndicator?: boolean;
    /** Whether to include a map range indicator. Defaults to `false`. */
    includeRangeIndicator?: boolean;
    /**
     * A user setting manager containing map settings. If not defined, map options will not be controlled by user
     * settings.
     */
    settingManager?: UserSettingManager<Partial<MapUserSettingTypes & WeatherMapUserSettingTypes>>;
    /** A display units user setting manager. If not defined, map display units will not be controlled by user settings. */
    unitsSettingManager?: UnitsUserSettingManager;
    /** Whether the map's range should be controlled by user setting by default. Defaults to `true`. */
    useRangeUserSettingByDefault?: boolean;
    /** Whether to bind map orientation to user settings. Defaults to `true`. Ignored if `settingManager` is not defined. */
    useOrientationUserSettings?: boolean;
    /**
     * The minimum range index, inclusive, at which the radar overlay is visible.
     */
    radarOverlayMinRangeIndex?: number;
    /**
     * Whether to bind the display of the radar overlay to user settings. Defaults to `true`. Ignored if `settingManager`
     * is not defined.
     */
    useRadarOverlayUserSettings?: boolean;
    /**
     * Whether to bind waypoint visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useWaypointVisUserSettings?: boolean;
    /**
     * Whether to bind airspace visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useAirspaceVisUserSettings?: boolean;
    /**
     * Whether to bind track vector options to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useTrackVectorUserSettings?: boolean;
    /**
     * Whether to bind altitude intercept arc options to user settings. Defaults to `true`. Ignored if `settingManager`
     * is not defined.
     */
    useAltitudeArcUserSettings?: boolean;
    /**
     * Whether to bind wind vector options to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useWindVectorUserSettings?: boolean;
};
/**
 * Builds next-generation (NXi, G3000, etc) Garmin Connext weather maps.
 */
declare class NextGenConnextMapBuilder {
    /**
     * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin Connext weather map.
     *
     * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
     * the range of the map.
     *
     * If the map pointer is supported, the controller `[GarminMapKeys.Pointer]: MapPointerController` is added to the
     * map context and can be used to control the pointer.
     *
     * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
     * the map.
     * @param mapBuilder The map builder to configure.
     * @param options Options for configuring the map.
     * @returns The builder, after it has been configured.
     */
    static build<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, options: NextGenConnextMapOptions): MapBuilder;
}

/**
 * Configurations for traffic intruder icons for next-generation (NXi, G3000, etc) HSI maps.
 */
type NextGenHsiMapTrafficIconOptions = Pick<TrafficIconOptions, 'iconSize' | 'font' | 'fontSize'> & Partial<Pick<TrafficIconOptions, 'drawOffScale' | 'supportAdsbVector'>>;
/**
 * Options for creating a next-generation (NXi, G3000, etc) Garmin HSI map.
 */
type NextGenHsiMapOptions = {
    /** The ID to assign to the map's bound Bing Map instance. */
    bingId: string;
    /** The amount of time, in milliseconds, to delay binding the map's Bing Map instance. Defaults to 0. */
    bingDelay?: number;
    /** The frequency, in hertz, with which player airplane and autopilot properties are updated from event bus data. */
    dataUpdateFreq: number | Subscribable<number>;
    /** The image cache from which to retrieve waypoint icon images. */
    waypointIconImageCache: WaypointIconImageCache;
    /** The font type to use for waypoint labels. */
    waypointStyleFontType: 'Roboto' | 'DejaVu';
    /** The scaling factor of waypoint icons and labels. Defaults to `1`. */
    waypointStyleScale?: number;
    /**
     * The nominal projected target offset of the map, as `[x, y]`, where each component is expressed relative to the
     * width or height of the map's projected window, *excluding* the dead zone. Defaults to `[0, 0]`.
     */
    targetOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The range endpoints of the map, as `[x1, y1, x2, y2]`, where each component is expressed relative to the width or
     * height of the map's projected window, *excluding* the dead zone. Defaults to `[0.5, 0.5, 0.5, 0]`.
     */
    rangeEndpoints?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The map range array to use for nautical units mode. Defaults to a standard range array. */
    nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** The map range array to use for metric units mode. Defaults to a standard range array. */
    metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** Whether to support data integrity state. Defaults to `true`. */
    supportDataIntegrity?: boolean;
    /** The URI of the no-heading player airplane icon's image asset, or a subscribable which provides it. */
    noHeadingAirplaneIconSrc?: string | Subscribable<string>;
    /**
     * The point on the no-heading player airplane icon that is anchored to the airplane's position, or a subscribable
     * which provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the
     * top left and [1, 1] at the bottom right.
     */
    noHeadingAirplaneIconAnchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** Whether to display airport runway outlines. Defaults to `false`. */
    includeRunwayOutlines?: boolean;
    /**
     * The image cache from which to retrieve runway designation images. If not defined, runway designations will not be
     * rendered. Ignored if `includeRunwayOutlines` is `false`.
     */
    runwayDesignationImageCache?: MapRunwayDesignationImageCache;
    /**
     * A function that filters user facilities to be displayed by the nearest waypoints layer based on their scopes. If
     * not defined, then user facilities will not be filtered based on scope.
     * @param scope A user facility scope.
     * @returns Whether to display the user facility with the specified scope.
     */
    userFacilityScopeFilter?: (scope: string) => boolean;
    /** Whether to display airspaces. Defaults to `true`. */
    includeAirspaces?: boolean;
    /** The URI of the player airplane icon's image asset */
    airplaneIconSrc: string | Subscribable<string>;
    /** The size of the player airplane icon, in pixels. */
    airplaneIconSize: number;
    /**
     * The point on the player airplane icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the top
     * left and [1, 1] at the bottom right.
     */
    airplaneIconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The flight planner containing the active flight plan. Required to display the active flight plan. */
    flightPlanner?: FlightPlanner;
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
    /** The traffic system from which to retrieve traffic intruder data. Required to display traffic. */
    trafficSystem?: TrafficSystem;
    /** Configuration options for traffic icons. Required to display traffic. */
    trafficIconOptions?: NextGenHsiMapTrafficIconOptions;
    /** Whether to include the track vector display. Defaults to `true`. */
    includeTrackVector?: boolean;
    /** Whether to include the altitude intercept arc display. Defaults to `true`. */
    includeAltitudeArc?: boolean;
    /** Whether to include a map range indicator. Defaults to `true`. */
    includeRangeIndicator?: boolean;
    /** Whether to include a detail indicator. Defaults to `true`. */
    includeDetailIndicator?: boolean;
    /** Whether to include a traffic off-scale status indicator. Defaults to `true`. */
    includeTrafficOffScaleIndicator?: boolean;
    /** Whether to include a traffic status indicator. Defaults to `true`. */
    includeTrafficStatusIndicator?: boolean;
    /**
     * A user setting manager containing map settings. If not defined, map options will not be controlled by user
     * settings.
     */
    settingManager?: UserSettingManager<Partial<MapUserSettingTypes>>;
    /**
     * A user setting manager containing settings controlling the operation of the traffic system. If not defined,
     * certain traffic display options will not be controlled by user settings.
     */
    trafficSettingManager?: UserSettingManager<Partial<TrafficUserSettingTypes>>;
    /** A display units user setting manager. If not defined, map display units will not be controlled by user settings. */
    unitsSettingManager?: UnitsUserSettingManager;
    /** Whether the map's range should be controlled by user setting by default. Defaults to `true`. */
    useRangeUserSettingByDefault?: boolean;
    /** Whether to bind terrain colors to user settings. Defaults to `true`. Ignored if `settingManager` is not defined. */
    useTerrainUserSettings?: boolean;
    /**
     * Whether to allow relative terrain mode. Defaults to `true`. Ignored if `useTerrainUserSettings` is `false` or
     * `settingManager` is not defined.
     */
    allowRelativeTerrainMode?: boolean;
    /**
     * The amount of time, in milliseconds, over which to blend the on-ground and relative terrain mode colors when
     * transitioning between the two. Defaults to 10000 milliseconds.
     */
    groundRelativeTerrainBlendDuration?: number;
    /**
     * The minimum range index, inclusive, at which NEXRAD is visible.
     */
    nexradMinRangeIndex?: number;
    /**
     * Whether to bind the display of NEXRAD to user settings. Defaults to `false`. Ignored if `settingManager` is not
     * defined.
     */
    useNexradUserSettings?: boolean;
    /**
     * Whether to bind the global declutter function to user settings. Defaults to `true`. Ignored if `settingManager` is
     * not defined.
     */
    useDeclutterUserSetting?: boolean;
    /**
     * Whether to bind waypoint visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useWaypointVisUserSettings?: boolean;
    /**
     * Whether to bind airspace visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useAirspaceVisUserSettings?: boolean;
    /**
     * Whether to bind track vector options to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useTrackVectorUserSettings?: boolean;
    /**
     * Whether to bind altitude intercept arc options to user settings. Defaults to `true`. Ignored if `settingManager`
     * is not defined.
     */
    useAltitudeArcUserSettings?: boolean;
};
/**
 * Builds next-generation (NXi, G3000, etc) Garmin HSI maps.
 */
declare class NextGenHsiMapBuilder {
    /**
     * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin HSI map.
     *
     * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
     * the range of the map.
     *
     * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
     * the map.
     * @param mapBuilder The map builder to configure.
     * @param options Options for configuring the map.
     * @returns The builder, after it has been configured.
     */
    static build<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, options: NextGenHsiMapOptions): MapBuilder;
}

/**
 * Configurations for traffic intruder icons for next-generation (NXi, G3000, etc) navigation maps.
 */
type NextGenNavMapTrafficIconOptions = Pick<TrafficIconOptions, 'iconSize' | 'font' | 'fontSize'> & Partial<Pick<TrafficIconOptions, 'supportAdsbVector'>>;
/**
 * Options for creating a next-generation (NXi, G3000, etc) Garmin navigation map.
 */
type NextGenNavMapOptions = {
    /** The ID to assign to the map's bound Bing Map instance. */
    bingId: string;
    /** The amount of time, in milliseconds, to delay binding the map's Bing Map instance. Defaults to 0. */
    bingDelay?: number;
    /** The frequency, in hertz, with which player airplane and autopilot properties are updated from event bus data. */
    dataUpdateFreq: number | Subscribable<number>;
    /** The image cache from which to retrieve waypoint icon images. */
    waypointIconImageCache: WaypointIconImageCache;
    /** The font type to use for waypoint labels. */
    waypointStyleFontType: 'Roboto' | 'DejaVu';
    /** The scaling factor of waypoint icons and labels. Defaults to `1`. */
    waypointStyleScale?: number;
    /**
     * The nominal projected target offset of the map for each orientation mode, as `[x, y]`, where each component is
     * expressed relative to the width or height of the map's projected window, *excluding* the dead zone. Defaults to
     * the following:
     * ```
     * {
     *   [MapOrientation.NorthUp]: [0, 0],
     *   [MapOrientation.HeadingUp]: [0, 0.17],
     *   [MapOrientation.TrackUp]: [0, 0.17]
     * }
     * ```
     */
    targetOffsets?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>;
    /**
     * The range endpoints of the map for each orientation mode, as `[x1, y1, x2, y2]`, where each component is expressed
     * relative to the width or height of the map's projected window, *excluding* the dead zone. Defaults to the
     * following:
     * ```
     * {
     *   [MapOrientation.NorthUp]: [0.5, 0.5, 0.5, 0.25],
     *   [MapOrientation.HeadingUp]: [0.5, 0.67, 0.5, 0.33],
     *   [MapOrientation.TrackUp]: [0.5, 0.67, 0.5, 0.33]
     * }
     * ```
     */
    rangeEndpoints?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>;
    /** The map range array to use for nautical units mode. Defaults to a standard range array. */
    nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** The map range array to use for metric units mode. Defaults to a standard range array. */
    metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** Whether to support data integrity state. Defaults to `true`. */
    supportDataIntegrity?: boolean;
    /** The URI of the no-heading player airplane icon's image asset, or a subscribable which provides it. */
    noHeadingAirplaneIconSrc?: string | Subscribable<string>;
    /**
     * The point on the no-heading player airplane icon that is anchored to the airplane's position, or a subscribable
     * which provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the
     * top left and [1, 1] at the bottom right.
     */
    noHeadingAirplaneIconAnchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The text of the banner that is displayed when GPS position is not available. Defaults to `'NO GPS POSITION'`. */
    noGpsBannerText?: string;
    /** Styling options for the range ring. */
    rangeRingOptions: RangeRingOptions;
    /** Styling options for the range compass. */
    rangeCompassOptions: RangeCompassOptions;
    /** Whether to display airport runway outlines. Defaults to `false`. */
    includeRunwayOutlines?: boolean;
    /**
     * The image cache from which to retrieve runway designation images. If not defined, runway designations will not be
     * rendered. Ignored if `includeRunwayOutlines` is `false`.
     */
    runwayDesignationImageCache?: MapRunwayDesignationImageCache;
    /**
     * A function that filters user facilities to be displayed by the nearest waypoints layer based on their scopes. If
     * not defined, then user facilities will not be filtered based on scope.
     * @param scope A user facility scope.
     * @returns Whether to display the user facility with the specified scope.
     */
    userFacilityScopeFilter?: (scope: string) => boolean;
    /** Whether to display airspaces. Defaults to `true`. */
    includeAirspaces?: boolean;
    /** The URI of the player airplane icon's image asset */
    airplaneIconSrc: string | Subscribable<string>;
    /** The size of the player airplane icon, in pixels. */
    airplaneIconSize: number;
    /**
     * The point on the player airplane icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the top
     * left and [1, 1] at the bottom right.
     */
    airplaneIconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The orientation of the player airplane icon. Defaults to `MapOwnAirplaneIconOrientation.HeadingUp`. */
    airplaneIconOrientation?: MapOwnAirplaneIconOrientation | Subscribable<MapOwnAirplaneIconOrientation>;
    /** The flight planner containing the active flight plan. Required to display the active flight plan. */
    flightPlanner?: FlightPlanner;
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
    /**
     * Whether to always draw the entire active flight plan, or a subscribable which provides it. Defaults to `false`.
     * Ignored if the active flight plan is not displayed.
     */
    drawEntirePlan?: boolean | Subscribable<boolean>;
    /** Whether to support flight plan focus. Defaults to `false`. Ignored if the active flight plan is not displayed. */
    supportFlightPlanFocus?: boolean;
    /**
     * A subscribable which provides the nominal focus margins, as `[left, top, right, bottom]` in pixels. The nominal
     * margins define the offset of the boundaries of the focus region relative to the map's projected window,
     * *excluding* the dead zone. Positive values represent offsets toward the center of the window. When the flight plan
     * is focused, the focused elements of the plan are guaranteed to be contained within the focus region. Defaults to
     * `[0, 0, 0, 0]`.
     */
    nominalFocusMargins?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The default map range index to apply when the procedure focus consists of only a single point in space. Defaults
     * to `17` (25 NM/50 KM with standard range arrays).
     */
    defaultFocusRangeIndex?: number;
    /** The traffic system from which to retrieve traffic intruder data. Required to display traffic. */
    trafficSystem?: TrafficSystem;
    /** Configuration options for traffic icons. Required to display traffic. */
    trafficIconOptions?: NextGenNavMapTrafficIconOptions;
    /** Whether to include the track vector display. Defaults to `true`. */
    includeTrackVector?: boolean;
    /** Whether to include the altitude intercept arc display. Defaults to `true`. */
    includeAltitudeArc?: boolean;
    /** Whether to include the wind vector display. Defaults to `true`. Ignored if `windDataProvider` is not defined. */
    includeWindVector?: boolean;
    /** A provider of wind data for the wind vector. Required to display the wind vector. */
    windDataProvider?: WindDataProvider;
    /**
     * The offset of the boundary surrounding the area in which the pointer can freely move, from the edge of the
     * projected map, excluding the dead zone, or a subscribable which provides it. Expressed as
     * `[left, top, right, bottom]`, relative to the width and height, as appropriate, of the projected map window. A
     * positive offset is directed toward the center of the map. Required to support the map pointer.
     */
    pointerBoundsOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The size of the pointer information box. Required to display the pointer information box. Ignored if the map
     * pointer is not supported.
     */
    pointerInfoSize?: MapPointerInfoLayerSize;
    /** The URI of the mini-compass's image asset. Required to display the mini-compass. */
    miniCompassImgSrc?: string;
    /** Whether to include an orientation indicator. Defaults to `true`. */
    includeOrientationIndicator?: boolean;
    /** Whether to include a map range indicator. Defaults to `false`. */
    includeRangeIndicator?: boolean;
    /** Whether to include a detail indicator. Defaults to `true`. */
    includeDetailIndicator?: boolean;
    /** Whether to show the detail indicator title. Defaults to `true`. Ignored if `includeDetailIndicator` is `false`. */
    showDetailIndicatorTitle?: boolean;
    /** Whether to include a traffic off-scale status indicator. Defaults to `true`. */
    includeTrafficOffScaleIndicator?: boolean;
    /** Whether to include a traffic failed mode indicator. Defaults to `true`. */
    includeTrafficFailedIndicator?: boolean;
    /** Whether to include a terrain scale indicator. Defaults to `true`. */
    includeTerrainScale?: boolean;
    /**
     * The path to the relative terrain mode status indicator icon's image file. Required to include the relative terrain
     * mode status indicator.
     */
    relativeTerrainStatusIndicatorIconPath?: string;
    /** Whether to include a traffic status indicator. Defaults to `true`. */
    includeTrafficStatusIndicator?: boolean;
    /**
     * Whether to show the traffic altitude restriction mode on the traffic status indicator. Defaults to `true`. Ignored
     * if `includeTrafficStatusIndicator` is `false`.
     */
    showTrafficAltRestriction?: boolean;
    /**
     * A user setting manager containing map settings. If not defined, map options will not be controlled by user
     * settings.
     */
    settingManager?: UserSettingManager<Partial<MapUserSettingTypes>>;
    /**
     * A user setting manager containing settings controlling the operation of the traffic system. If not defined,
     * certain traffic display options will not be controlled by user settings.
     */
    trafficSettingManager?: UserSettingManager<Partial<TrafficUserSettingTypes>>;
    /** A display units user setting manager. If not defined, map display units will not be controlled by user settings. */
    unitsSettingManager?: UnitsUserSettingManager;
    /** Whether the map's range should be controlled by user setting by default. Defaults to `true`. */
    useRangeUserSettingByDefault?: boolean;
    /** Whether to bind map orientation to user settings. Defaults to `true`. Ignored if `settingManager` is not defined. */
    useOrientationUserSettings?: boolean;
    /** Whether to bind terrain colors to user settings. Defaults to `true`. Ignored if `settingManager` is not defined. */
    useTerrainUserSettings?: boolean;
    /**
     * Whether to allow relative terrain mode. Defaults to `true`. Ignored if `useTerrainUserSettings` is `false` or
     * `settingManager` is not defined.
     */
    allowRelativeTerrainMode?: boolean;
    /**
     * The amount of time, in milliseconds, over which to blend the on-ground and relative terrain mode colors when
     * transitioning between the two. Defaults to 10000 milliseconds.
     */
    groundRelativeTerrainBlendDuration?: number;
    /**
     * The minimum range index, inclusive, at which NEXRAD is visible.
     */
    nexradMinRangeIndex?: number;
    /**
     * Whether to bind the display of NEXRAD to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useNexradUserSettings?: boolean;
    /**
     * Whether to bind the global declutter function to user settings. Defaults to `true`. Ignored if `settingManager` is
     * not defined.
     */
    useDeclutterUserSetting?: boolean;
    /**
     * Whether to bind waypoint visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useWaypointVisUserSettings?: boolean;
    /**
     * Whether to bind airspace visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useAirspaceVisUserSettings?: boolean;
    /**
     * Whether to bind track vector options to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useTrackVectorUserSettings?: boolean;
    /**
     * Whether to bind altitude intercept arc options to user settings. Defaults to `true`. Ignored if `settingManager`
     * is not defined.
     */
    useAltitudeArcUserSettings?: boolean;
    /**
     * Whether to bind wind vector options to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useWindVectorUserSettings?: boolean;
};
/**
 * Builds next-generation (NXi, G3000, etc) Garmin navigation maps.
 */
declare class NextGenNavMapBuilder {
    /**
     * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin navigation map.
     *
     * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
     * the range of the map.
     *
     * If flight plan focus is supported, the module `[GarminMapKeys.FlightPlanFocus]: MapFlightPlanFocusModule` is added
     * to the map model and can be used to control the focus.
     *
     * If the map pointer is supported, the controller `[GarminMapKeys.Pointer]: MapPointerController` is added to the
     * map context and can be used to control the pointer.
     *
     * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
     * the map.
     * @param mapBuilder The map builder to configure.
     * @param options Options for configuring the map.
     * @returns The builder, after it has been configured.
     */
    static build<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, options: NextGenNavMapOptions): MapBuilder;
}

/**
 * Configurations for traffic intruder icons for next-generation (NXi, G3000, etc) nearest waypoint maps.
 */
type NextGenNearestMapTrafficIconOptions = Pick<TrafficIconOptions, 'iconSize' | 'font' | 'fontSize'> & Partial<Pick<TrafficIconOptions, 'supportAdsbVector'>>;
/**
 * Options for creating a next-generation (NXi, G3000, etc) Garmin nearest waypoint map.
 */
type NextGenNearestMapOptions = {
    /** The ID to assign to the map's bound Bing Map instance. */
    bingId: string;
    /** The amount of time, in milliseconds, to delay binding the map's Bing Map instance. Defaults to 0. */
    bingDelay?: number;
    /** The frequency, in hertz, with which player airplane and autopilot properties are updated from event bus data. */
    dataUpdateFreq: number | Subscribable<number>;
    /** Styling options for the waypoint highlight line. */
    lineOptions?: Readonly<WaypointHighlightLineOptions>;
    /**
     * The default map range index to apply when there is no highlighted waypoint, or `null` if no range index should be
     * applied. Defaults to `null`.
     */
    defaultNoTargetRangeIndex?: number | Subscribable<number> | null;
    /** The image cache from which to retrieve waypoint icon images. */
    waypointIconImageCache: WaypointIconImageCache;
    /** The font type to use for waypoint labels. */
    waypointStyleFontType: 'Roboto' | 'DejaVu';
    /** The scaling factor of waypoint icons and labels. Defaults to `1`. */
    waypointStyleScale?: number;
    /**
     * The nominal projected target offset of the map for each orientation mode, as `[x, y]`, where each component is
     * expressed relative to the width or height of the map's projected window, *excluding* the dead zone. Defaults to
     * the following:
     * ```
     * {
     *   [MapOrientation.NorthUp]: [0, 0],
     *   [MapOrientation.HeadingUp]: [0, 0.17],
     *   [MapOrientation.TrackUp]: [0, 0.17]
     * }
     * ```
     */
    targetOffsets?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>;
    /**
     * The range endpoints of the map for each orientation mode, as `[x1, y1, x2, y2]`, where each component is expressed
     * relative to the width or height of the map's projected window, *excluding* the dead zone. Defaults to the
     * following:
     * ```
     * {
     *   [MapOrientation.NorthUp]: [0.5, 0.5, 0.5, 0.25],
     *   [MapOrientation.HeadingUp]: [0.5, 0.67, 0.5, 0.33],
     *   [MapOrientation.TrackUp]: [0.5, 0.67, 0.5, 0.33]
     * }
     * ```
     */
    rangeEndpoints?: Partial<Record<MapOrientation, ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>>>;
    /** The map range array to use for nautical units mode. Defaults to a standard range array. */
    nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** The map range array to use for metric units mode. Defaults to a standard range array. */
    metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** Whether to support data integrity state. Defaults to `true`. */
    supportDataIntegrity?: boolean;
    /** The URI of the no-heading player airplane icon's image asset, or a subscribable which provides it. */
    noHeadingAirplaneIconSrc?: string | Subscribable<string>;
    /**
     * The point on the no-heading player airplane icon that is anchored to the airplane's position, or a subscribable
     * which provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the
     * top left and [1, 1] at the bottom right.
     */
    noHeadingAirplaneIconAnchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The text of the banner that is displayed when GPS position is not available. Defaults to `'NO GPS POSITION'`. */
    noGpsBannerText?: string;
    /** Styling options for the range ring. */
    rangeRingOptions: RangeRingOptions;
    /** Styling options for the range compass. */
    rangeCompassOptions: RangeCompassOptions;
    /** Whether to display airport runway outlines. Defaults to `false`. */
    includeRunwayOutlines?: boolean;
    /**
     * The image cache from which to retrieve runway designation images. If not defined, runway designations will not be
     * rendered. Ignored if `includeRunwayOutlines` is `false`.
     */
    runwayDesignationImageCache?: MapRunwayDesignationImageCache;
    /**
     * A function that filters user facilities to be displayed by the nearest waypoints layer based on their scopes. If
     * not defined, then user facilities will not be filtered based on scope.
     * @param scope A user facility scope.
     * @returns Whether to display the user facility with the specified scope.
     */
    userFacilityScopeFilter?: (scope: string) => boolean;
    /** Whether to display airspaces. Defaults to `true`. */
    includeAirspaces?: boolean;
    /** The URI of the player airplane icon's image asset */
    airplaneIconSrc: string | Subscribable<string>;
    /** The size of the player airplane icon, in pixels. */
    airplaneIconSize: number;
    /**
     * The point on the player airplane icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the top
     * left and [1, 1] at the bottom right.
     */
    airplaneIconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The orientation of the player airplane icon. Defaults to `MapOwnAirplaneIconOrientation.HeadingUp`. */
    airplaneIconOrientation?: MapOwnAirplaneIconOrientation | Subscribable<MapOwnAirplaneIconOrientation>;
    /** The flight planner containing the active flight plan. Required to display the active flight plan. */
    flightPlanner?: FlightPlanner;
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
    /** The traffic system from which to retrieve traffic intruder data. Required to display traffic. */
    trafficSystem?: TrafficSystem;
    /** Configuration options for traffic icons. Required to display traffic. */
    trafficIconOptions?: NextGenNearestMapTrafficIconOptions;
    /** Whether to include the track vector display. Defaults to `true`. */
    includeTrackVector?: boolean;
    /** Whether to include the altitude intercept arc display. Defaults to `true`. */
    includeAltitudeArc?: boolean;
    /** Whether to include the wind vector display. Defaults to `true`. Ignored if `windDataProvider` is not defined. */
    includeWindVector?: boolean;
    /** A provider of wind data for the wind vector. Required to display the wind vector. */
    windDataProvider?: WindDataProvider;
    /**
     * The offset of the boundary surrounding the area in which the pointer can freely move, from the edge of the
     * projected map, excluding the dead zone, or a subscribable which provides it. Expressed as
     * `[left, top, right, bottom]`, relative to the width and height, as appropriate, of the projected map window. A
     * positive offset is directed toward the center of the map. Required to support the map pointer.
     */
    pointerBoundsOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The size of the pointer information box. Required to display the pointer information box. Ignored if the map
     * pointer is not supported.
     */
    pointerInfoSize?: MapPointerInfoLayerSize;
    /** The URI of the mini-compass's image asset. Required to display the mini-compass. */
    miniCompassImgSrc?: string;
    /** Whether to include an orientation indicator. Defaults to `true`. */
    includeOrientationIndicator?: boolean;
    /** Whether to include a map range indicator. Defaults to `false`. */
    includeRangeIndicator?: boolean;
    /** Whether to include a detail indicator. Defaults to `true`. */
    includeDetailIndicator?: boolean;
    /** Whether to show the detail indicator title. Defaults to `true`. Ignored if `includeDetailIndicator` is `false`. */
    showDetailIndicatorTitle?: boolean;
    /** Whether to include a traffic off-scale status indicator. Defaults to `true`. */
    includeTrafficOffScaleIndicator?: boolean;
    /** Whether to include a traffic failed mode indicator. Defaults to `true`. */
    includeTrafficFailedIndicator?: boolean;
    /** Whether to include a terrain scale indicator. Defaults to `true`. */
    includeTerrainScale?: boolean;
    /**
     * The path to the relative terrain mode status indicator icon's image file. Required to include the relative terrain
     * mode status indicator.
     */
    relativeTerrainStatusIndicatorIconPath?: string;
    /** Whether to include a traffic status indicator. Defaults to `true`. */
    includeTrafficStatusIndicator?: boolean;
    /**
     * Whether to show the traffic altitude restriction mode on the traffic status indicator. Defaults to `true`. Ignored
     * if `includeTrafficStatusIndicator` is `false`.
     */
    showTrafficAltRestriction?: boolean;
    /**
     * A user setting manager containing map settings. If not defined, map options will not be controlled by user
     * settings.
     */
    settingManager?: UserSettingManager<Partial<MapUserSettingTypes>>;
    /**
     * A user setting manager containing settings controlling the operation of the traffic system. If not defined,
     * certain traffic display options will not be controlled by user settings.
     */
    trafficSettingManager?: UserSettingManager<Partial<TrafficUserSettingTypes>>;
    /** A display units user setting manager. If not defined, map display units will not be controlled by user settings. */
    unitsSettingManager?: UnitsUserSettingManager;
    /** Whether the map's range should be controlled by user setting by default. Defaults to `true`. */
    useRangeUserSettingByDefault?: boolean;
    /** Whether to bind map orientation to user settings. Defaults to `true`. Ignored if `settingManager` is not defined. */
    useOrientationUserSettings?: boolean;
    /** Whether to bind terrain colors to user settings. Defaults to `true`. Ignored if `settingManager` is not defined. */
    useTerrainUserSettings?: boolean;
    /**
     * Whether to allow relative terrain mode. Defaults to `false`. Ignored if `useTerrainUserSettings` is `false` or
     * `settingManager` is not defined.
     */
    allowRelativeTerrainMode?: boolean;
    /**
     * The amount of time, in milliseconds, over which to blend the on-ground and relative terrain mode colors when
     * transitioning between the two. Defaults to 10000 milliseconds.
     */
    groundRelativeTerrainBlendDuration?: number;
    /**
     * The minimum range index, inclusive, at which NEXRAD is visible.
     */
    nexradMinRangeIndex?: number;
    /**
     * Whether to bind the display of NEXRAD to user settings. Defaults to `false`. Ignored if `settingManager` is not
     * defined.
     */
    useNexradUserSettings?: boolean;
    /**
     * Whether to bind the global declutter function to user settings. Defaults to `true`. Ignored if `settingManager` is
     * not defined.
     */
    useDeclutterUserSetting?: boolean;
    /**
     * Whether to bind waypoint visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useWaypointVisUserSettings?: boolean;
    /**
     * Whether to bind airspace visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useAirspaceVisUserSettings?: boolean;
    /**
     * Whether to bind track vector options to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useTrackVectorUserSettings?: boolean;
    /**
     * Whether to bind altitude intercept arc options to user settings. Defaults to `true`. Ignored if `settingManager`
     * is not defined.
     */
    useAltitudeArcUserSettings?: boolean;
    /**
     * Whether to bind wind vector options to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useWindVectorUserSettings?: boolean;
};
declare class NextGenNearestMapBuilder {
    /**
     * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin nearest waypoint map.
     *
     * The module `[GarminMapKeys.WaypointHighlight]: MapWaypointHighlightModule` is added to the map model and can be
     * used to control the highlighted waypoint.
     *
     * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
     * the range of the map.
     *
     * If the map pointer is supported, the controller `[GarminMapKeys.Pointer]: MapPointerController` is added to the
     * map context and can be used to control the pointer.
     *
     * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
     * the map.
     * @param mapBuilder The map builder to configure.
     * @param options Options for configuring the map.
     * @returns The builder, after it has been configured.
     */
    static build<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, options: NextGenNearestMapOptions): MapBuilder;
}

/**
 * Options for creating a next-generation (NXi, G3000, etc) Garmin procedure map.
 */
type NextGenProcMapOptions = {
    /** The ID to assign to the map's bound Bing Map instance. */
    bingId: string;
    /** The amount of time, in milliseconds, to delay binding the map's Bing Map instance. Defaults to 0. */
    bingDelay?: number;
    /** The frequency, in hertz, with which the player airplane's properties are updated from event bus data. */
    dataUpdateFreq: number | Subscribable<number>;
    /** The image cache from which to retrieve waypoint icon images. */
    waypointIconImageCache: WaypointIconImageCache;
    /** The font type to use for waypoint labels. */
    waypointStyleFontType: 'Roboto' | 'DejaVu';
    /** The scaling factor of waypoint icons and labels. Defaults to `1`. */
    waypointStyleScale?: number;
    /**
     * The nominal projected target offset of the map, as `[x, y]`, where each component is expressed relative to the
     * width or height of the map's projected window, *excluding* the dead zone. Defaults to `[0, 0]`.
     */
    targetOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The range endpoints of the map, as `[x1, y1, x2, y2]`, where each component is expressed relative to the width or
     * height of the map's projected window, *excluding* the dead zone. Defaults to `[0.5, 0.5, 0.5, 0.25]`.
     */
    rangeEndpoints?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The map range array to use for nautical units mode. Defaults to a standard range array. */
    nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** The map range array to use for metric units mode. Defaults to a standard range array. */
    metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** Whether to support data integrity state. Defaults to `true`. */
    supportDataIntegrity?: boolean;
    /** The URI of the no-heading player airplane icon's image asset, or a subscribable which provides it. */
    noHeadingAirplaneIconSrc?: string | Subscribable<string>;
    /**
     * The point on the no-heading player airplane icon that is anchored to the airplane's position, or a subscribable
     * which provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the
     * top left and [1, 1] at the bottom right.
     */
    noHeadingAirplaneIconAnchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The text of the banner that is displayed when GPS position is not available. Defaults to `'NO GPS POSITION'`. */
    noGpsBannerText?: string;
    /**
     * A subscribable which provides the nominal focus margins, as `[left, top, right, bottom]` in pixels. The nominal
     * margins define the offset of the boundaries of the focus region relative to the map's projected window,
     * *excluding* the dead zone. Positive values represent offsets toward the center of the window. When the flight plan
     * is focused, the focused elements of the plan are guaranteed to be contained within the focus region. Defaults to
     * `[0, 0, 0, 0]`.
     */
    nominalFocusMargins?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The default map range index to apply when the procedure focus consists of only a single point in space. Defaults
     * to `17` (25 NM/50 KM with standard range arrays).
     */
    defaultFocusRangeIndex?: number;
    /** Styling options for the range ring. */
    rangeRingOptions: RangeRingOptions;
    /** The URI of the player airplane icon's image asset */
    airplaneIconSrc: string | Subscribable<string>;
    /** The size of the player airplane icon, in pixels. */
    airplaneIconSize: number;
    /**
     * The point on the player airplane icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the top
     * left and [1, 1] at the bottom right.
     */
    airplaneIconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The orientation of the player airplane icon. Defaults to `MapOwnAirplaneIconOrientation.HeadingUp`. */
    airplaneIconOrientation?: MapOwnAirplaneIconOrientation | Subscribable<MapOwnAirplaneIconOrientation>;
    /**
     * The offset of the boundary surrounding the area in which the pointer can freely move, from the edge of the
     * projected map, excluding the dead zone, or a subscribable which provides it. Expressed as
     * `[left, top, right, bottom]`, relative to the width and height, as appropriate, of the projected map window. A
     * positive offset is directed toward the center of the map. Required to support the map pointer.
     */
    pointerBoundsOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The size of the pointer information box. Required to display the pointer information box. Ignored if the map
     * pointer is not supported.
     */
    pointerInfoSize?: MapPointerInfoLayerSize;
    /** The URI of the mini-compass's image asset. Required to display the mini-compass. */
    miniCompassImgSrc?: string;
    /** Whether to include an orientation indicator. Defaults to `true`. */
    includeOrientationIndicator?: boolean;
    /**
     * A user setting manager containing map settings. If not defined, map options will not be controlled by user
     * settings.
     */
    settingManager?: UserSettingManager<Partial<MapUserSettingTypes>>;
    /** A display units user setting manager. If not defined, map display units will not be controlled by user settings. */
    unitsSettingManager?: UnitsUserSettingManager;
    /** Whether to bind terrain colors to user settings. Defaults to `false`. Ignored if `settingManager` is not defined. */
    useTerrainUserSettings?: boolean;
    /**
     * Whether to allow relative terrain mode. Defaults to `true`. Ignored if `useTerrainUserSettings` is `false` or
     * `settingManager` is not defined.
     */
    allowRelativeTerrainMode?: boolean;
    /**
     * Whether to bind the global declutter function to user settings. Defaults to `true`. Ignored if `settingManager` is
     * not defined.
     */
    useDeclutterUserSetting?: boolean;
};
/**
 * Builds next-generation (NXi, G3000, etc) Garmin procedure maps.
 */
declare class NextGenProcMapBuilder {
    /**
     * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin procedure map. The map displays a
     * flight plan procedure (departure, arrival, approach) and its transitions, and is always focused on the displayed
     * procedure. The map is also locked to a North Up orientation.
     *
     * The module `[GarminMapKeys.ProcedurePreview]: MapProcedurePreviewModule` is added to the map model and can be
     * used to control the displayed procedure.
     *
     * The module `[GarminMapKeys.FlightPlanFocus]: MapFlightPlanFocusModule` is added to the map model and can be used
     * to control the procedure focus.
     *
     * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
     * the range of the map.
     *
     * If the map pointer is supported, the controller `[GarminMapKeys.Pointer]: MapPointerController` is added to the
     * map context and can be used to control the pointer.
     *
     * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
     * the map.
     * @param mapBuilder The map builder to configure.
     * @param options Options for configuring the map.
     * @returns The builder, after it has been configured.
     */
    static build<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, options: NextGenProcMapOptions): MapBuilder;
}

/**
 * Options for creating a next-generation (NXi, G3000, etc) Garmin waypoint map.
 */
type NextGenWaypointMapOptions = {
    /** The ID to assign to the map's bound Bing Map instance. */
    bingId: string;
    /** The amount of time, in milliseconds, to delay binding the map's Bing Map instance. Defaults to 0. */
    bingDelay?: number;
    /** The frequency, in hertz, with which the player airplane's properties are updated from event bus data. */
    dataUpdateFreq: number | Subscribable<number>;
    /** Whether the map draws a line from the highlighted waypoint to the player airplane. Defaults to `false`. */
    includeLine?: boolean;
    /** Styling options for the waypoint highlight line. Ignored if `includeLine` is `false`. */
    lineOptions?: WaypointHighlightLineOptions;
    /**
     * Whether the map should automatically adjust its range when the selected waypoint is an airport to give an
     * appropriate view of the selected runway, or all runways if there is no selected runway. Defaults to `false`.
     */
    supportAirportAutoRange?: boolean;
    /**
     * The default map range index to apply when a range cannot be automatically selected for an airport. Ignored if
     * `supportAirportAutoRange` is `false`. If not defined, the map range will not be reset when targeting an airport
     * and a range cannot be automatically selected.
     */
    defaultAirportRangeIndex?: number | Subscribable<number>;
    /**
     * The nominal margins (relative to the map's dead zone boundaries), to respect when calculating the map range for
     * airports, as `[left, top, right, bottom]` in pixels. Ignored if `supportAirportAutoRange` is `false`. Defaults to
     * `[0, 0, 0, 0]`.
     */
    airportAutoRangeMargins?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The image cache from which to retrieve waypoint icon images. */
    waypointIconImageCache: WaypointIconImageCache;
    /** The font type to use for waypoint labels. */
    waypointStyleFontType: 'Roboto' | 'DejaVu';
    /** The scaling factor of waypoint icons and labels. Defaults to `1`. */
    waypointStyleScale?: number;
    /**
     * The nominal projected target offset of the map, as `[x, y]`, where each component is expressed relative to the
     * width or height of the map's projected window, *excluding* the dead zone. Defaults to `[0, 0]`.
     */
    targetOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The range endpoints of the map, as `[x1, y1, x2, y2]`, where each component is expressed relative to the width or
     * height of the map's projected window, *excluding* the dead zone. Defaults to `[0.5, 0.5, 0.5, 0.25]`.
     */
    rangeEndpoints?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The map range array to use for nautical units mode. Defaults to a standard range array. */
    nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** The map range array to use for metric units mode. Defaults to a standard range array. */
    metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** Whether to support data integrity state. Defaults to `true`. */
    supportDataIntegrity?: boolean;
    /** The URI of the no-heading player airplane icon's image asset, or a subscribable which provides it. */
    noHeadingAirplaneIconSrc?: string | Subscribable<string>;
    /**
     * The point on the no-heading player airplane icon that is anchored to the airplane's position, or a subscribable
     * which provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the
     * top left and [1, 1] at the bottom right.
     */
    noHeadingAirplaneIconAnchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The text of the banner that is displayed when GPS position is not available. Defaults to `'NO GPS POSITION'`. */
    noGpsBannerText?: string;
    /** Styling options for the range ring. */
    rangeRingOptions: RangeRingOptions;
    /** Whether to display airport runway outlines. Defaults to `false`. */
    includeRunwayOutlines?: boolean;
    /**
     * The image cache from which to retrieve runway designation images. If not defined, runway designations will not be
     * rendered. Ignored if `includeRunwayOutlines` is `false`.
     */
    runwayDesignationImageCache?: MapRunwayDesignationImageCache;
    /**
     * A function that filters user facilities to be displayed by the nearest waypoints layer based on their scopes. If
     * not defined, then user facilities will not be filtered based on scope.
     * @param scope A user facility scope.
     * @returns Whether to display the user facility with the specified scope.
     */
    userFacilityScopeFilter?: (scope: string) => boolean;
    /** Whether to display airspaces. Defaults to `false`. */
    includeAirspaces?: boolean;
    /** The URI of the player airplane icon's image asset, or a subscribable which provides it */
    airplaneIconSrc: string | Subscribable<string>;
    /** The size of the player airplane icon, in pixels. */
    airplaneIconSize: number;
    /**
     * The point on the player airplane icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the top
     * left and [1, 1] at the bottom right.
     */
    airplaneIconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The orientation of the player airplane icon. Defaults to `MapOwnAirplaneIconOrientation.HeadingUp`. */
    airplaneIconOrientation?: MapOwnAirplaneIconOrientation | Subscribable<MapOwnAirplaneIconOrientation>;
    /**
     * The offset of the boundary surrounding the area in which the pointer can freely move, from the edge of the
     * projected map, excluding the dead zone, or a subscribable which provides it. Expressed as
     * `[left, top, right, bottom]`, relative to the width and height, as appropriate, of the projected map window. A
     * positive offset is directed toward the center of the map. Required to support the map pointer.
     */
    pointerBoundsOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The size of the pointer information box. Required to display the pointer information box. Ignored if the map
     * pointer is not supported.
     */
    pointerInfoSize?: MapPointerInfoLayerSize;
    /** The flight planner containing the active flight plan. Required to display the active flight plan. */
    flightPlanner?: FlightPlanner;
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
    /** The URI of the mini-compass's image asset. Required to display the mini-compass. */
    miniCompassImgSrc?: string;
    /** Whether to include an orientation indicator. Defaults to `true`. */
    includeOrientationIndicator?: boolean;
    /** Whether to include a detail indicator. Defaults to `false`. */
    includeDetailIndicator?: boolean;
    /** Whether to show the detail indicator title. Defaults to `false`. Ignored if `includeDetailIndicator` is `false`. */
    showDetailIndicatorTitle?: boolean;
    /**
     * A user setting manager containing map settings. If not defined, map options will not be controlled by user
     * settings.
     */
    settingManager?: UserSettingManager<Partial<MapUserSettingTypes>>;
    /** A display units user setting manager. If not defined, map display units will not be controlled by user settings. */
    unitsSettingManager?: UnitsUserSettingManager;
    /** Whether to bind terrain colors to user settings. Defaults to `true`. Ignored if `settingManager` is not defined. */
    useTerrainUserSettings?: boolean;
    /**
     * Whether to allow relative terrain mode. Defaults to `false`. Ignored if `useTerrainUserSettings` is `false` or
     * `settingManager` is not defined.
     */
    allowRelativeTerrainMode?: boolean;
    /**
     * The amount of time, in milliseconds, over which to blend the on-ground and relative terrain mode colors when
     * transitioning between the two. Defaults to 2000 milliseconds.
     */
    groundRelativeTerrainBlendDuration?: number;
    /**
     * The minimum range index, inclusive, at which NEXRAD is visible.
     */
    nexradMinRangeIndex?: number;
    /**
     * Whether to bind the display of NEXRAD to user settings. Defaults to `false`. Ignored if `settingManager` is not
     * defined.
     */
    useNexradUserSettings?: boolean;
    /**
     * Whether to bind the global declutter function to user settings. Defaults to `true`. Ignored if `settingManager` is
     * not defined.
     */
    useDeclutterUserSetting?: boolean;
    /**
     * Whether to bind waypoint visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useWaypointVisUserSettings?: boolean;
    /**
     * Whether to bind airspace visibility to user settings. Defaults to `true`. Ignored if `settingManager` is not
     * defined.
     */
    useAirspaceVisUserSettings?: boolean;
};
/**
 * Builds next-generation (NXi, G3000, etc) Garmin waypoint maps.
 */
declare class NextGenWaypointMapBuilder {
    /**
     * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin waypoint map. The map is locked to
     * a North Up orientation, targets a highlighted waypoint, and follows the player airplane when there is no
     * highlighted waypoint.
     *
     * The module `[GarminMapKeys.WaypointHighlight]: MapWaypointHighlightModule` is added to the map model and can be
     * used to control the highlighted waypoint.
     *
     * The controller `[GarminMapKeys.Range]: MapRangeController` is added to the map context and can be used to control
     * the range of the waypoint map.
     *
     * If the map pointer is supported, the controller `[GarminMapKeys.Pointer]: MapPointerController` is added to the
     * map context and can be used to control the pointer.
     *
     * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
     * the map.
     * @param mapBuilder The map builder to configure.
     * @param options Options for configuring the map.
     * @returns The builder, after it has been configured.
     */
    static build<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, options: NextGenWaypointMapOptions): MapBuilder;
}

/**
 * Options for creating a Garmin traffic map.
 */
type TrafficMapOptions = {
    /** The traffic system from which to retrieve intruder data. */
    trafficSystem: TrafficSystem;
    /** The frequency, in hertz, with which the player airplane's properties are updated from event bus data. */
    dataUpdateFreq: number | Subscribable<number>;
    /**
     * The nominal projected target offset of the map, as `[x, y]`, where each component is expressed relative to the
     * width or height of the map's projected window, *excluding* the dead zone. Defaults to `[0, 0]`.
     */
    targetOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The nominal range endpoints of the map, as `[x1, y1, x2, y2]`, where each component is expressed relative to the
     * width or height of the map's projected window, *excluding* the dead zone. Defaults to `[0.5, 0.5, 0.5, 0]`.
     */
    rangeEndpoints?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The map range array to use for nautical units mode. If not defined, a range array will not automatically be set
     * when entering nautical units mode.
     */
    nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /**
     * The map range array to use for metric units mode. If not defined, a range array will not automatically be set
     * when entering metric units mode.
     */
    metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** Whether to support data integrity state. Defaults to `true`. */
    supportDataIntegrity?: boolean;
    /** Configuration options for traffic icons. */
    trafficIconOptions: TrafficIconOptions;
    /** A mutable subscribable to update with the traffic layer's off-scale intruder status. */
    offScaleStatus?: MutableSubscribable<MapTrafficOffScaleStatus>;
    /**
     * A function which creates intruder icons for the traffic display. If not defined, a default icon of type
     * {@link MapTrafficIntruderIcon} is created for each intruder.
     */
    iconFactory?: MapTrafficIntruderIconFactory;
    /** A function which initializes global canvas styles for the traffic display. */
    initCanvasStyles?: (context: CanvasRenderingContext2D) => void;
    /** Whether to include range rings. */
    includeRangeRings: boolean;
    /**
     * Styling options for the range rings. If not defined, both the outer and inner label radial values are set to 135
     * degrees. Ignored if `includeRangeRings` is `false`.
     */
    rangeRingOptions?: TrafficRangeRingOptions;
    /** The URI of the player airplane icon's image asset */
    airplaneIconSrc: string | Subscribable<string>;
    /** The size of the player airplane icon, in pixels. */
    airplaneIconSize: number;
    /**
     * The point on the player airplane icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with [0, 0] at the top
     * left and [1, 1] at the bottom right.
     */
    airplaneIconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The flight planner containing the active flight plan. Required to display the active flight plan. */
    flightPlanner?: FlightPlanner | Subscribable<FlightPlanner>;
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
    /**
     * A function that creates a flight plan waypoint record manager to use to manage the waypoints to draw for the
     * flight plan. Required to display the active flight plan.
     * @param context The map system context.
     * @param waypointRenderer The waypoint renderer used to draw the flight plan waypoints.
     * @returns A flight plan waypoint record manager to use to manage the waypoints to draw for the flight plan.
     */
    flightPlanWaypointRecordManagerFactory?: (context: MapSystemContext<any, any, any, any>, waypointRenderer: MapWaypointRenderer) => MapFlightPlanWaypointRecordManager;
    /**
     * A function that creates a flight path renderer to use to draw the flight plan. Required to display the active
     * flight plan.
     * @param context The map system context.
     * @returns A flight path renderer to use to draw the flight plan.
     */
    flightPathRendererFactory?: (context: MapSystemContext<any, any, any, any>) => MapFlightPathPlanRenderer;
    /** A function which configures the display of flight plan waypoints. Required to display the active flight plan. */
    configureFlightPlan?: (builder: MapWaypointDisplayBuilder) => void;
    /** The URI of the mini-compass's image asset. Required to display the mini-compass. */
    miniCompassImgSrc?: string;
    /** The orientation of the map. */
    orientation: MapOrientation | Subscribable<MapOrientation>;
    /** Whether to include an orientation indicator. Defaults to `true`. */
    includeOrientationIndicator?: boolean;
    /**
     * The text to display in the orientation indicator for each orientation mode. Ignored if
     * `includeOrientationIndicator` is `false`.
     */
    orientationText?: Partial<Record<MapOrientation, string>>;
    /** Whether to include a traffic system operating mode indicator. Defaults to `true`. */
    includeOperatingModeIndicator?: boolean;
    /**
     * The text to display in the traffic system operating mode indicator for each operating mode. Ignored if
     * `includeOperatingModeIndicator` is `false`.
     */
    operatingModeText?: Partial<Record<TcasOperatingMode, string>>;
    /** Whether to include an ADS-B operating mode indicator. Defaults to `true`. Ignored if ADS-B is not supported. */
    includeAdsbModeIndicator?: boolean;
    /**
     * The text to display in the ADS-B operating mode indicator for each operating mode. Ignored if ADS-B is not
     * supported.
     */
    adsbModeText?: Partial<Record<AdsbOperatingMode, string>>;
    /** Whether to include an altitude restriction mode indicator. Defaults to `true`. */
    includeAltitudeModeIndicator?: boolean;
    /**
     * The text to display in the altitude restriction mode indicator for each operating mode. Ignored if
     * `includeAltitudeModeIndicator` is `false`.
     */
    altitudeModeText?: Partial<Record<MapTrafficAltitudeRestrictionMode, string>>;
    /** Whether to include a traffic system standby mode warning banner. Defaults to `true`. */
    includeStandbyBanner?: boolean;
    /** Whether to include an ADS-B standby mode warning banner. Defaults to `true`. Ignored if ADS-B is not supported. */
    includeAdsbOffBanner?: boolean;
    /** Whether to include a traffic system failed mode warning banner. Defaults to `true`. */
    includeFailedBanner?: boolean;
    /**
     * A user setting manager containing settings controlling the operation of the traffic system.
     */
    trafficSettingManager?: UserSettingManager<Partial<TrafficUserSettingTypes>>;
    /**
     * A user setting manager containing the map range setting. If not defined, map range will not be controlled by
     * user setting.
     */
    mapRangeSettingManager?: UserSettingManager<TrafficMapRangeControllerSettings>;
    /** A display units user setting manager. If not defined, map display units will not be controlled by user settings. */
    unitsSettingManager?: UnitsUserSettingManager;
    /**
     * Whether to use the map range user setting to control map range by default. Defaults to `true`. Ignored if
     * `mapRangeSettingManager` is not defined.
     */
    useRangeSettingByDefault?: boolean;
};
/**
 * Configurations for traffic intruder icons for next-generation (NXi, G3000, etc) Garmin traffic maps.
 */
type NextGenTrafficMapIconOptions = Pick<TrafficIconOptions, 'iconSize' | 'font' | 'fontSize'> & Partial<Pick<TrafficIconOptions, 'drawOffScale' | 'supportAdsbVector'>>;
/**
 * Options for creating a next-generation (NXi, G3000, etc) Garmin traffic map.
 */
type NextGenTrafficMapOptions = Omit<TrafficMapOptions, 'nauticalRangeArray' | 'metricRangeArray' | 'trafficIconOptions' | 'includeRangeRings' | 'flightPlanWaypointRecordManagerFactory' | 'flightPathRendererFactory' | 'configureFlightPlan' | 'orientation' | 'orientationText' | 'operatingModeText' | 'adsbModeText' | 'altitudeModeText' | 'standbyText'> & {
    /** Configuration options for traffic icons. */
    trafficIconOptions: NextGenTrafficMapIconOptions;
    /** The image cache from which to retrieve waypoint icon images. */
    waypointIconImageCache: WaypointIconImageCache;
    /** The font type to use for waypoint labels. */
    waypointStyleFontType: 'Roboto' | 'DejaVu';
    /** The scaling factor of waypoint icons and labels. Defaults to `1`. */
    waypointStyleScale?: number;
    /** The map range array to use for nautical units mode. Defaults to a standard range array. */
    nauticalRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** The map range array to use for metric units mode. Defaults to a standard range array. */
    metricRangeArray?: readonly NumberUnitInterface<UnitFamily.Distance>[];
    /** Whether to include range rings. Defaults to `true`. */
    includeRangeRings?: boolean;
};
/**
 * Builds Garmin traffic maps.
 */
declare class TrafficMapBuilder {
    /**
     * Configures a map builder to generate a Garmin traffic map. The map consists of an optional active flight plan
     * layer, an optional traffic range ring layer, a traffic intruder layer, an airplane icon layer, and an optional
     * mini-compass layer. The map is centered on the player airplane and is locked to a Heading Up orientation.
     *
     * The controller `[GarminMapKeys.TrafficRange]: TrafficMapRangeController` is added to the map context and can be
     * used to control the range of the traffic map.
     *
     * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
     * the map.
     * @param mapBuilder The map builder to configure.
     * @param options Options for configuring the map.
     * @returns The builder, after it has been configured.
     */
    static build<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, options: TrafficMapOptions): MapBuilder;
    /**
     * Configures a map builder to generate a next-generation (NXi, G3000, etc) Garmin traffic map. The map consists of
     * an optional active flight plan layer, an optional traffic range ring layer, a traffic intruder layer, an airplane
     * icon layer, and an optional mini-compass layer. The map is centered on the player airplane and is locked in
     * Heading Up orientation.
     *
     * The controller `[GarminMapKeys.TrafficRange]: TrafficMapRangeController` is added to the map context and can be
     * used to control the range of the traffic map.
     *
     * The map builder will **not** be configured to apply a custom projected size, dead zone, or to automatically update
     * the map.
     * @param mapBuilder The map builder to configure.
     * @param options Options for configuring the map.
     * @returns The builder, after it has been configured.
     */
    static buildNextGen<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, options: NextGenTrafficMapOptions): MapBuilder;
}

/**
 * Component props for MapBannerIndicator.
 */
interface MapBannerIndicatorProps extends ComponentProps {
    /** A subscribable which provides the declutter mode. */
    show: Subscribable<boolean>;
    /** CSS class(es) to apply to the root of the banner. */
    class?: string | SubscribableSet<string>;
}
/**
 * Displays a map banner message.
 */
declare class MapBannerIndicator extends DisplayComponent<MapBannerIndicatorProps> {
    private static readonly RESERVED_CLASSES;
    private readonly cssClassSet;
    private showSub?;
    private classSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapDetailIndicator.
 */
interface MapDetailIndicatorProps extends ComponentProps {
    /** A subscribable which provides the declutter mode. */
    declutterMode: Subscribable<MapDeclutterMode>;
    /** Whether to show the title. */
    showTitle: boolean;
}
/**
 * Displays a map detail level indication.
 */
declare class MapDetailIndicator extends DisplayComponent<MapDetailIndicatorProps> {
    private static readonly MODE_CLASSES;
    private readonly rootRef;
    private modeSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * A callback which is called when the declutter mode setting value changes.
     * @param mode The new declutter mode setting value.
     */
    private onDeclutterModeChanged;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapOrientationIndicator.
 */
interface MapOrientationIndicatorProps extends ComponentProps {
    /** A subscribable which provides the orientation mode. */
    orientation: Subscribable<MapOrientation>;
    /** The text to display for each orientation mode. */
    text: Partial<Record<MapOrientation, string>>;
    /** A subscribable which provides whether the indicator should be visible. */
    isVisible: Subscribable<boolean>;
}
/**
 * Displays a map orientation indication.
 */
declare class MapOrientationIndicator extends DisplayComponent<MapOrientationIndicatorProps> {
    private readonly text;
    private readonly rootStyle;
    private isVisibleSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapRelativeTerrainStatusIndicator.
 */
interface MapRelativeTerrainStatusIndicatorProps extends ComponentProps {
    /** The path to the indicator icon's image file. */
    iconFilePath: string;
    /** Whether to show the indicator. */
    show: Subscribable<boolean>;
    /** Whether relative terrain mode is in a failed state. */
    isFailed: Subscribable<boolean>;
}
/**
 * Displays a relative terrain mode status indication.
 */
declare class MapRelativeTerrainStatusIndicator extends DisplayComponent<MapRelativeTerrainStatusIndicatorProps> {
    private readonly rootStyle;
    private readonly failedStyle;
    private showSub?;
    private isFailedSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapTerrainScaleIndicator.
 */
interface MapTerrainScaleIndicatorProps extends ComponentProps {
    /** Whether to show the indicator. */
    show: Subscribable<boolean>;
    /** The current map terrain mode. */
    terrainMode: Subscribable<MapTerrainMode>;
    /** The altitude display units mode. */
    altitudeUnitsMode: Subscribable<UnitsAltitudeSettingMode>;
}
/**
 * Displays a terrain color scale.
 */
declare class MapTerrainScaleIndicator extends DisplayComponent<MapTerrainScaleIndicatorProps> {
    private static readonly LABEL_TEXT_FT;
    private static readonly LABEL_TEXT_MT;
    private readonly rootRef;
    private readonly absLabelText;
    private readonly relLabelText;
    private readonly groundLabelText;
    private readonly unitText;
    private readonly unitTextShown;
    private showSub?;
    private terrainModeSub?;
    private altitudeUnitsModeSub?;
    private unitTextPipe?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Updates the display of this indicator.
     */
    private updateDisplay;
    /**
     * Updates this indicator's display units.
     * @param mode The current altitude display units mode.
     */
    private updateUnits;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapTrafficFailedIndicator.
 */
interface MapTrafficFailedIndicatorProps extends ComponentProps {
    /** Whether to show the indicator. */
    show: Subscribable<boolean>;
    /** The traffic system operating mode. */
    operatingMode: Subscribable<TcasOperatingMode>;
}
/**
 * Displays a traffic failed indication.
 */
declare class MapTrafficFailedIndicator extends DisplayComponent<MapTrafficFailedIndicatorProps> {
    private readonly ref;
    private readonly text;
    private operatingModeSub?;
    private showSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * A callback which is called when the traffic system operating mode changes.
     * @param mode The new mode.
     */
    private onModeChanged;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapTrafficIntruderOffScaleIndicator.
 */
interface MapTrafficOffScaleIndicatorProps extends ComponentProps {
    /** A subscribable which provides the indicator mode. */
    status: Subscribable<MapTrafficOffScaleStatus>;
}
/**
 * Displays a traffic off-scale indication.
 */
declare class MapTrafficOffScaleIndicator extends DisplayComponent<MapTrafficOffScaleIndicatorProps> {
    private static readonly CLASSES;
    private static readonly TEXT;
    private readonly ref;
    private readonly text;
    private statusSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * A callback which is called when the indicator mode changes.
     * @param mode The new mode.
     */
    private onModeChanged;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapTrafficStatusIndicator.
 */
interface MapTrafficStatusIndicatorProps extends ComponentProps {
    /** A subscribable which provides whether to show the indicator. */
    show: Subscribable<boolean>;
    /** A subscribable which provides the current traffic system operating mode. */
    operatingMode: Subscribable<TcasOperatingMode>;
    /**
     * A subscribable which provides the current map traffic altitude restriction mode. If not defined, the altitude
     * restriction mode will not be displayed on the indicator.
     */
    altitudeRestrictionMode?: Subscribable<MapTrafficAltitudeRestrictionMode>;
}
/**
 * Displays a traffic operating status and optional altitude restriction mode indications.
 */
declare class MapTrafficStatusIndicator extends DisplayComponent<MapTrafficStatusIndicatorProps> {
    private static readonly DISABLED_MODES;
    private static readonly ALT_RESTRICTION_TEXT;
    private readonly rootStyle;
    private readonly disabledStyle;
    private readonly altModeStyle;
    private readonly altitudeRestrictionText;
    private showSub?;
    private operatingModeSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for TrafficMapBdsbModeIndicator.
 */
interface TrafficMapAdsbModeIndicatorProps extends ComponentProps {
    /** A subscribable which provides the current ADS-B operating mode. */
    operatingMode: Subscribable<AdsbOperatingMode>;
    /** The text to display for each operating mode. */
    text: Partial<Record<AdsbOperatingMode, string>>;
}
/**
 * Displays an ADS-B operating mode indication.
 */
declare class TrafficMapAdsbModeIndicator extends DisplayComponent<TrafficMapAdsbModeIndicatorProps> {
    private readonly text;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for TrafficMapAdsbOffBannerIndicator.
 */
interface TrafficMapAdsbOffBannerIndicatorProps extends ComponentProps {
    /** A subscribable which provides the current ADS-B operating mode. */
    adsbOperatingMode: Subscribable<AdsbOperatingMode>;
    /** A subscribable which provides the current traffic system operating mode. */
    trafficOperatingMode: Subscribable<TcasOperatingMode>;
}
/**
 * Displays an ADS-B Off banner indicator.
 */
declare class TrafficMapAdsbOffBannerIndicator extends DisplayComponent<TrafficMapAdsbOffBannerIndicatorProps> {
    private readonly show;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for TrafficMapAltitudeModeIndicator.
 */
interface TrafficMapAltitudeModeIndicatorProps extends ComponentProps {
    /** A subscribable which provides the current traffic altitude restriction mode. */
    altitudeRestrictionMode: Subscribable<MapTrafficAltitudeRestrictionMode>;
    /** The text to display for each altitude restriction mode. */
    text: Partial<Record<MapTrafficAltitudeRestrictionMode, string>>;
}
/**
 * Displays a traffic system altitude restriction mode indication.
 */
declare class TrafficMapAltitudeModeIndicator extends DisplayComponent<TrafficMapAltitudeModeIndicatorProps> {
    private readonly text;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for TrafficMapFailedBannerIndicator.
 */
interface TrafficMapFailedBannerIndicatorProps extends ComponentProps {
    /** A subscribable which provides the current traffic system operating mode. */
    operatingMode: Subscribable<TcasOperatingMode>;
}
/**
 * Displays a traffic system failed mode banner indicator.
 */
declare class TrafficMapFailedBannerIndicator extends DisplayComponent<TrafficMapFailedBannerIndicatorProps> {
    private readonly show;
    private readonly text;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for TrafficMapOperatingModeIndicator.
 */
interface TrafficMapOperatingModeIndicatorProps extends ComponentProps {
    /** A subscribable which provides the current traffic system operating mode. */
    operatingMode: Subscribable<TcasOperatingMode>;
    /** The text to display for each operating mode. */
    text: Partial<Record<TcasOperatingMode, string>>;
}
/**
 * Displays a traffic system operating mode indication.
 */
declare class TrafficMapOperatingModeIndicator extends DisplayComponent<TrafficMapOperatingModeIndicatorProps> {
    private readonly text;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for TrafficMapStandbyBannerIndicator.
 */
interface TrafficMapStandbyBannerIndicatorProps extends ComponentProps {
    /** A subscribable which provides the current traffic system operating mode. */
    operatingMode: Subscribable<TcasOperatingMode>;
    /** A subscribable which provides whether the airplane is on the ground. */
    isOnGround: Subscribable<boolean>;
}
/**
 * Displays a traffic system standby mode banner indicator.
 */
declare class TrafficMapStandbyBannerIndicator extends DisplayComponent<TrafficMapStandbyBannerIndicatorProps> {
    private readonly show;
    private readonly cssClassSet;
    private isOnGroundSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Utility class containing functions defining the rendering behavior of airspaces for Garmin maps.
 */
declare class MapAirspaceRendering {
    private static readonly RENDERERS;
    /**
     * Determines the rendering order of airspaces for Garmin maps.
     * @returns The relative rendering order of two airspaces for Garmin maps.
     */
    static renderOrder(): number;
    /**
     * Selects airspace renderers for Garmin maps.
     * @param airspace The airspace to render.
     * @returns The renderer to use to render the specified airspace.
     */
    static selectRenderer(airspace: LodBoundary): MapAirspaceRenderer;
}

/**
 * Component props for MapRangeDisplay
 */
interface MapRangeDisplayProps extends ComponentProps {
    /** A subscribable which provides the range. */
    range: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** A subscribable which provides a display unit type. */
    displayUnit: Subscribable<Unit<UnitFamily.Distance> | null>;
    /** The class name of the display component root. */
    class?: string;
}
/**
 * A display which renders a map range value with units. Automatically switches between nautical miles/feet and
 * kilometers/meters at predefined thresholds.
 */
declare class MapRangeDisplay extends DisplayComponent<MapRangeDisplayProps> {
    private readonly displayUnitSub;
    private readonly autoSubject;
    private readonly autoOverrideSubject;
    private readonly displayUnitHandler;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Updates this component's display unit.
     */
    private updateDisplayUnit;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Utility class defining the priority values for common resource consumers.
 */
declare class MapResourcePriority {
    /** Default follow player airplane behavior. */
    static readonly FOLLOW_AIRPLANE = 0;
    /** Orientation mode. */
    static readonly ORIENTATION = 0;
    /** Desired orientation mode. */
    static readonly DESIRED_ORIENTATION = 0;
    /** Rotation behavior from orientation mode. */
    static readonly ORIENTATION_ROTATION = 0;
    /** Panning. */
    static readonly PANNING = 100;
    /** Pointer. */
    static readonly POINTER = 100;
    /** Waypoint highlight. */
    static readonly WAYPOINT_HIGHLIGHT = 75;
    /** Flight plan focus. */
    static readonly FLIGHT_PLAN_FOCUS = 50;
    /** Data integrity. */
    static readonly DATA_INTEGRITY = 25;
}

/**
 * A waypoint for a map runway label.
 */
declare class MapRunwayLabelWaypoint extends AbstractWaypoint {
    readonly runway: OneWayRunway;
    private static readonly TYPE;
    private readonly _uid;
    private readonly _location;
    /**
     * Constructor.
     * @param airport The parent airport of the runway associated with this waypoint.
     * @param runway The runway associated with this waypoint.
     */
    constructor(airport: AirportFacility, runway: OneWayRunway);
    /** @inheritdoc */
    get type(): string;
    /** @inheritdoc */
    get uid(): string;
    /** @inheritdoc */
    get location(): Subscribable<GeoPointInterface>;
    /**
     * Gets the unique ID for a MapRunwayLabelWaypoint associated with a given airport and runway.
     * @param airport The parent airport of the runway associated with the waypoint.
     * @param runway The runway associated with the waypoint.
     * @returns The unique ID for the waypoint associated with the specified airport and runway.
     */
    static getUid(airport: AirportFacility, runway: OneWayRunway): string;
}

/**
 * A cache for map runway label waypoints.
 */
declare class MapRunwayLabelWaypointCache {
    readonly size: number;
    private static INSTANCE;
    private readonly cache;
    /**
     * Constructor.
     * @param size The maximum size of this cache.
     */
    private constructor();
    /**
     * Gets a waypoint from this cache for a specific runway. If one does not exist, a new waypoint will be created.
     * @param airport The parent airport of the runway for which to get a waypoint.
     * @param runway The runway for which to get a waypoint.
     * @returns A waypoint.
     */
    get(airport: AirportFacility, runway: OneWayRunway): MapRunwayLabelWaypoint;
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param waypoint The waypoint to add.
     */
    private addToCache;
    /**
     * Gets a MapRunwayOutlineWaypointCache instance.
     * @returns A MapRunwayOutlineWaypointCache instance.
     */
    static getCache(): MapRunwayLabelWaypointCache;
}

/**
 * A cache for map runway outline waypoints.
 */
declare class MapRunwayOutlineWaypointCache {
    readonly size: number;
    private static INSTANCE;
    private readonly cache;
    /**
     * Constructor.
     * @param size The maximum size of this cache.
     */
    private constructor();
    /**
     * Gets a waypoint from this cache for a specific runway. If one does not exist, a new waypoint will be created.
     * @param airport The parent airport of the runway for which to get a waypoint.
     * @param runway The runway for which to get a waypoint.
     * @returns A waypoint.
     */
    get(airport: AirportFacility, runway: AirportRunway): MapRunwayOutlineWaypoint;
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param waypoint The waypoint to add.
     */
    private addToCache;
    /**
     * Gets a MapRunwayOutlineWaypointCache instance.
     * @returns A MapRunwayOutlineWaypointCache instance.
     */
    static getCache(): MapRunwayOutlineWaypointCache;
}

/**
 * User settings controlling the display of map terrain and weather overlays.
 */
type MapTerrainWxUserSettings = Pick<MapUserSettingTypes, 'mapTerrainMode' | 'mapNexradShow'>;
/**
 * Manages settings controlling the display of map relative terrain and weather (datalink and/or weather radar)
 * overlays such that the two are never active at the same time.
 */
declare class MapTerrainWxSettingCompatManager {
    private readonly terrainModeSetting?;
    private readonly nexradShowSetting?;
    private isInit;
    private isAlive;
    private terrainModeSub?;
    private nexradShowSub?;
    /**
     * Constructor.
     * @param settingManager A setting manager containing the user settings controlling the display of relative terrain
     * and weather overlays for this manager to manage.
     */
    constructor(settingManager: UserSettingManager<Partial<MapTerrainWxUserSettings>>);
    /**
     * Initializes this manager. Once initialized, this manager will automatically control its managed settings such that
     * the relative terrain and weather overlays are never active at the same time.
     * @throws Error if this manager has been destroyed.
     */
    init(): void;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * Provides utility functions for working with Garmin maps.
 */
declare class MapUtils {
    private static readonly NEXT_GEN_MAP_RANGES;
    private static readonly NEXT_GEN_TRAFFIC_MAP_RANGES;
    /**
     * Gets the standard map range array for next-generation (NXi, G3000, etc) avionics units.
     * @param units The distance units mode for which to get the array.
     * @returns The standard map range array for next-generation (NXi, G3000, etc) avionics units.
     */
    static nextGenMapRanges(units: UnitsDistanceSettingMode): readonly NumberUnitReadOnly<UnitFamily.Distance>[];
    /**
     * Gets the standard traffic map range array for next-generation (NXi, G3000, etc) avionics units.
     * @returns The standard traffic map range array for next-generation (NXi, G3000, etc) avionics units.
     */
    static nextGenTrafficMapRanges(): readonly NumberUnitReadOnly<UnitFamily.Distance>[];
    private static readonly NO_TERRAIN_EARTH_COLORS;
    private static readonly ABSOLUTE_TERRAIN_EARTH_COLORS;
    private static readonly RELATIVE_TERRAIN_EARTH_COLORS;
    private static readonly GROUND_TERRAIN_EARTH_COLORS;
    /**
     * Gets the earth colors definition for no terrain colors.
     * @returns The earth colors definition for no terrain colors.
     */
    static noTerrainEarthColors(): Readonly<MapTerrainColorsDefinition>;
    /**
     * Gets the earth colors definition for absolute terrain colors.
     * @returns The earth colors definition for absolute terrain colors.
     */
    static absoluteTerrainEarthColors(): Readonly<MapTerrainColorsDefinition>;
    /**
     * Gets the earth colors definition for relative terrain colors.
     * @returns The earth colors definition for relative terrain colors.
     */
    static relativeTerrainEarthColors(): Readonly<MapTerrainColorsDefinition>;
    /**
     * Gets the earth colors definition for on ground relative terrain colors.
     * @returns The earth colors definition for on ground relative terrain colors.
     */
    static groundTerrainEarthColors(): Readonly<MapTerrainColorsDefinition>;
    private static readonly CONNEXT_PRECIP_RADAR_COLORS;
    /**
     * Gets the weather color array for the Connext precipitation radar overlay.
     * @returns The weather color array for the Connext precipitation radar overlay.
     */
    static connextPrecipRadarColors(): readonly (readonly [number, number])[];
}

/**
 * A utility class for generating next-generation (NXi, G3000, etc) Garmin map waypoint styles.
 */
declare class NextGenMapWaypointStyles {
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for normal waypoints.
     * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for normal waypoints.
     */
    static normalIconStyles(basePriority: number, scale?: number): (waypoint: Waypoint) => MapWaypointIconStyles;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for normal waypoints.
     * @param basePriority The base label render priority. Label priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param fontType The type of font to use for the labels.
     * @param scale The scaling factor for the labels. The larger the value, the larger the rendered labels. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for normal waypoints.
     */
    static normalLabelStyles(basePriority: number, fontType: 'Roboto' | 'DejaVu', scale?: number): (waypoint: Waypoint) => MapWaypointLabelStyles;
    /**
     * Creates initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in a normal
     * role.
     * @param offset The label offset, in pixels.
     * @param font The name of the label font.
     * @param fontSize The font size of the label, in pixels.
     * @returns Initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in a normal
     * role.
     */
    private static createNormalLabelOptions;
    /**
     * Creates initialization options for next-generation (NXi, G3000, etc) style runway labels.
     * @param offset The label offset, in pixels.
     * @param font The name of the label font.
     * @param fontSize The font size of the label, in pixels.
     * @param borderRadius The border radius of the label, in pixels.
     * @returns Initialization options for next-generation (NXi, G3000, etc) style runway labels rendered in a normal
     * role.
     */
    private static createRunwayLabelOptions;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for runway outline waypoints.
     * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for normal waypoints.
     */
    static runwayOutlineIconStyles(basePriority: number): (waypoint: MapRunwayOutlineWaypoint) => MapRunwayOutlineIconStyles;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for flight plan waypoints.
     * @param active Whether to retrieve styles for active flight plan waypoints.
     * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for flight plan waypoints.
     */
    static flightPlanIconStyles(active: boolean, basePriority: number, scale?: number): (waypoint: Waypoint) => MapWaypointIconStyles;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for flight plan waypoints.
     * @param active Whether to retrieve styles for active flight plan waypoints.
     * @param basePriority The base label render priority. Label priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param fontType The type of font to use for the labels.
     * @param scale The scaling factor for the labels. The larger the value, the larger the rendered labels. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for flight plan waypoints.
     */
    static flightPlanLabelStyles(active: boolean, basePriority: number, fontType: 'Roboto' | 'DejaVu', scale?: number): (waypoint: Waypoint) => MapWaypointLabelStyles;
    /**
     * Creates initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in an inactive
     * flight plan role.
     * @param offset The label offset, in pixels.
     * @param font The name of the label font.
     * @param fontSize The font size of the label, in pixels.
     * @returns Initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in an
     * inactive flight plan role.
     */
    private static createFplInactiveLabelOptions;
    /**
     * Creates initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in an active
     * flight plan role.
     * @param offset The label offset, in pixels.
     * @param font The name of the label font.
     * @param fontSize The font size of the label, in pixels.
     * @returns Initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in an active
     * flight plan role.
     */
    private static createFplActiveLabelOptions;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for highlighted waypoints.
     * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for highlighted waypoints.
     */
    static highlightIconStyles(basePriority: number, scale?: number): (waypoint: Waypoint) => MapWaypointIconHighlightStyles;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for highlighted waypoints.
     * @param basePriority The base label render priority. Label priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param fontType The type of font to use for the labels.
     * @param scale The scaling factor for the labels. The larger the value, the larger the rendered label. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for highlighted waypoints.
     */
    static highlightLabelStyles(basePriority: number, fontType: 'Roboto' | 'DejaVu', scale?: number): (waypoint: Waypoint) => MapWaypointLabelStyles;
    /**
     * Creates initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in a highlight
     * role.
     * @param offset The label offset, in pixels.
     * @param font The name of the label font.
     * @param fontSize The font size of the label, in pixels.
     * @returns Initialization options for next-generation (NXi, G3000, etc) style waypoint labels rendered in a highlight
     * role.
     */
    private static createHighlightLabelOptions;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for VNAV waypoints.
     * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for VNAV waypoints.
     */
    static vnavIconStyles(basePriority: number, scale?: number): (waypoint: Waypoint) => MapWaypointIconStyles;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for VNAV waypoints.
     * @param basePriority The base label render priority. Label priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param fontType The type of font to use for the labels.
     * @param scale The scaling factor for the labels. The larger the value, the larger the rendered labels. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for VNAV waypoints.
     */
    static vnavLabelStyles(basePriority: number, fontType: 'Roboto' | 'DejaVu', scale?: number): (waypoint: Waypoint) => MapWaypointLabelStyles;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for procedure preview waypoints.
     * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for procedure preview waypoints.
     */
    static procPreviewIconStyles(basePriority: number, scale?: number): (waypoint: Waypoint) => MapWaypointIconStyles;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for procedure preview waypoints.
     * @param basePriority The base label render priority. Label priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param fontType The type of font to use for the labels.
     * @param scale The scaling factor for the labels. The larger the value, the larger the rendered labels. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for procedure preview waypoints.
     */
    static procPreviewLabelStyles(basePriority: number, fontType: 'Roboto' | 'DejaVu', scale?: number): (waypoint: Waypoint) => MapWaypointLabelStyles;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) icon styles for procedure transition preview
     * waypoints.
     * @param basePriority The base icon render priority. Icon priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param scale The scaling factor for the icons. The larger the value, the larger the rendered icons. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) icon styles for procedure transition
     * preview waypoints.
     */
    static procTransitionPreviewIconStyles(basePriority: number, scale?: number): (waypoint: Waypoint) => MapWaypointIconStyles;
    /**
     * Creates a function which retrieves next-generation (NXi, G3000, etc) label styles for procedure transition preview
     * waypoints.
     * @param basePriority The base label render priority. Label priorities are guaranteed to fall in the range
     * `[basePriority, basePriority + 1)`.
     * @param fontType The type of font to use for the labels.
     * @param scale The scaling factor for the labels. The larger the value, the larger the rendered labels. Defaults to
     * `1`.
     * @returns A function which retrieves next-generation (NXi, G3000, etc) label styles for procedure preview transition
     * waypoints.
     */
    static procTransitionPreviewLabelStyles(basePriority: number, fontType: 'Roboto' | 'DejaVu', scale?: number): (waypoint: Waypoint) => MapWaypointLabelStyles;
}

/**
 * A builder for next-generation (NXi, G3000, etc) Garmin maps.
 */
declare class NextGenGarminMapBuilder {
    /**
     * Configures a map builder to generate a map which supports the display of waypoints located within the boundaries
     * of the map's projected window. Waypoints displayed in this manner are rendered by a {@link MapWaypointRenderer}
     * under the role {@link MapWaypointRenderRole.Normal}. Optionally binds the visibility of waypoints to user
     * settings.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.WaypointRenderer]: MapWaypointRenderer`
     * * `[GarminMapKeys.WaypointDisplayBuilder]: MapWaypointDisplayBuilder`
     *
     * Modules:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointsModule`
     * * `[GarminMapKeys.Range]: MapIndexedRangeModule` (only if user settings are supported)
     *
     * Layers:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointsLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.WaypointRenderer]: MapSystemCustomController` (handles initialization and updating of the
     * waypoint renderer)
     * * `[GarminMapKeys.WaypointsVisibility]: MapWaypointsVisController` (only if user settings are supported)
     * * `[GarminMapKeys.RunwayVisibility]: MapSymbolVisController` (only if runway outlines are supported)
     * * `[GarminMapKeys.RunwayLabelVisibility]: MapSymbolVisController` (only if runway outlines are supported)
     * @param mapBuilder The map builder to configure.
     * @param configure A function used to configure the display and styling of waypoint icons and labels.
     * @param settingManager A setting manager containing the user settings controlling waypoint visibility. If not
     * defined, waypoint visibility will not be bound to user settings.
     * @param options Options with which to configure the layer.
     * @param order The order to assign to the waypoint layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @returns The map builder, after it has been configured.
     */
    static waypoints<MapBuilder extends MapSystemBuilder>(mapBuilder: MapBuilder, configure: (builder: MapWaypointDisplayBuilder, context: MapSystemContext<any, any, any, any>) => void, settingManager?: UserSettingManager<Partial<MapWaypointVisUserSettings>>, options?: Readonly<GarminMapBuilderWaypointsLayerOptions>, order?: number): MapBuilder;
}

/**
 * Provides utility functions for working with next-generation (NXi, G3000, etc) Garmin maps.
 */
declare class NextGenGarminMapUtils {
    /** Bitflags describing the data required to be loaded in airport facilities used in maps. */
    static readonly AIRPORT_DATA_FLAGS: number;
}

/**
 * A data model for a navigation data field.
 */
interface NavDataFieldModel<T> {
    /** A subscribable which provides this model's value. */
    readonly value: Subscribable<T>;
}
/**
 * Utility type to get the value type from a NavDataFieldModel type.
 */
type TypeOfNavDataFieldModel<M extends NavDataFieldModel<any>> = M extends NavDataFieldModel<infer T> ? T : never;
/**
 * An enum describing the validity of the GPS data being provided to nav data field models.
 */
declare enum NavDataFieldGpsValidity {
    Invalid = 0,
    DeadReckoning = 1,
    Valid = 2
}

/**
 * The different types of navigation data fields.
 */
declare enum NavDataFieldType {
    AboveGroundLevel = "AGL",
    BearingToWaypoint = "BRG",
    CabinAltitude = "CAB",
    ClimbGradient = "CLG",
    ClimbGradientPerDistance = "CLM",
    CarbonMonoxide = "CO",
    DensityAltitude = "DA",
    Destination = "DEST",
    DistanceToWaypoint = "DIS",
    DistanceToDestination = "DTG",
    DesiredTrack = "DTK",
    FuelEconomy = "ECO",
    Endurance = "END",
    TimeToDestination = "ENR",
    TimeOfWaypointArrival = "ETA",
    TimeToWaypoint = "ETE",
    EstimatedTimeToVnav = "ETV",
    FuelFlow = "FF",
    FlightLevel = "FL",
    FuelOnBoard = "FOB",
    FuelOverDestination = "FOD",
    GMeter = "G",
    GpsAltitude = "GPSA",
    GlideRatio = "GR",
    GroundSpeed = "GS",
    ISA = "ISA",
    LocalTime = "LCL",
    TimeOfDestinationArrival = "LDG",
    MachNumber = "MACH",
    OutsideTemperature = "OAT",
    RamAirTemperature = "RAT",
    TrueAirspeed = "TAS",
    TrackAngleError = "TKE",
    GroundTrack = "TRK",
    FuelUsed = "USD",
    UtcTime = "UTC",
    VerticalSpeedRequired = "VSR",
    Waypoint = "WPT",
    CrossTrack = "XTK"
}
/**
 * A map from navigation data field type to data model type.
 */
type NavDataFieldTypeModelMap = {
    /** Altitude above ground level. */
    [NavDataFieldType.AboveGroundLevel]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
    /** Bearing to next waypoint. */
    [NavDataFieldType.BearingToWaypoint]: NavDataFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
    /** Cabin altitude. */
    [NavDataFieldType.CabinAltitude]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
    /** Climb gradient. */
    [NavDataFieldType.ClimbGradient]: NavDataFieldModel<number>;
    /** Climb gradient (height per distance). */
    [NavDataFieldType.ClimbGradientPerDistance]: NavDataFieldModel<NumberUnitInterface<UnitFamily.DistanceRatio>>;
    /** Carbon monoxide sensor value. */
    [NavDataFieldType.CarbonMonoxide]: NavDataFieldModel<number>;
    /** Density altitude. */
    [NavDataFieldType.DensityAltitude]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
    /** Destination ident. */
    [NavDataFieldType.Destination]: NavDataFieldModel<string>;
    /** Distance to next waypoint. */
    [NavDataFieldType.DistanceToWaypoint]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
    /** Distance to destination. */
    [NavDataFieldType.DistanceToDestination]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
    /** Desired track. */
    [NavDataFieldType.DesiredTrack]: NavDataFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
    /** Fuel economy. */
    [NavDataFieldType.FuelEconomy]: NavDataFieldModel<NumberUnitInterface<UnitFamily.DistancePerWeight>>;
    /** Endurance (time to zero fuel). */
    [NavDataFieldType.Endurance]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Duration>>;
    /** Estimated time enroute to destination. */
    [NavDataFieldType.TimeToDestination]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Duration>>;
    /** Estimated time of arrival at next waypoint. */
    [NavDataFieldType.TimeOfWaypointArrival]: NavDataFieldModel<number>;
    /** Estimated time enroute to next waypoint. */
    [NavDataFieldType.TimeToWaypoint]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Duration>>;
    /** Estimated time to VNAV intercept. */
    [NavDataFieldType.EstimatedTimeToVnav]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Duration>>;
    /** Fuel flow. */
    [NavDataFieldType.FuelFlow]: NavDataFieldModel<NumberUnitInterface<UnitFamily.WeightFlux>>;
    /** Flight level. */
    [NavDataFieldType.FlightLevel]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
    /** Total fuel remaining. */
    [NavDataFieldType.FuelOnBoard]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Weight>>;
    /** Estimated fuel remaining at destination. */
    [NavDataFieldType.FuelOverDestination]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Weight>>;
    /** G meter. */
    [NavDataFieldType.GMeter]: NavDataFieldModel<number>;
    /** GPS Altitude. */
    [NavDataFieldType.GpsAltitude]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
    /** Glide ratio. */
    [NavDataFieldType.GlideRatio]: NavDataFieldModel<number>;
    /** Ground speed. */
    [NavDataFieldType.GroundSpeed]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Speed>>;
    /** International standard atmosphere. */
    [NavDataFieldType.ISA]: NavDataFieldModel<NumberUnitInterface<UnitFamily.TemperatureDelta>>;
    /** Local time. */
    [NavDataFieldType.LocalTime]: NavDataFieldModel<number>;
    /** Estimated time of arrival at destination. */
    [NavDataFieldType.TimeOfDestinationArrival]: NavDataFieldModel<number>;
    /** Mach number. */
    [NavDataFieldType.MachNumber]: NavDataFieldModel<number>;
    /** Outside air temperature. */
    [NavDataFieldType.OutsideTemperature]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Temperature>>;
    /** Ram air temperature. */
    [NavDataFieldType.RamAirTemperature]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Temperature>>;
    /** True airspeed. */
    [NavDataFieldType.TrueAirspeed]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Speed>>;
    /** Track angle error. */
    [NavDataFieldType.TrackAngleError]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Angle>>;
    /** Ground track. */
    [NavDataFieldType.GroundTrack]: NavDataFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
    /** Fuel used. */
    [NavDataFieldType.FuelUsed]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Weight>>;
    /** UTC time. */
    [NavDataFieldType.UtcTime]: NavDataFieldModel<number>;
    /** Vertical speed required to meet next VNAV restriction. */
    [NavDataFieldType.VerticalSpeedRequired]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Speed>>;
    /** Next waypoint ident. */
    [NavDataFieldType.Waypoint]: NavDataFieldModel<string>;
    /** Cross-track error. */
    [NavDataFieldType.CrossTrack]: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
};

/**
 * A data model for a navigation data bar field.
 */
interface NavDataBarFieldModel<T> extends NavDataFieldModel<T> {
    /**
     * Updates this model.
     */
    update(): void;
    /**
     * Destroys this model.
     */
    destroy(): void;
}
/** A map from navigation data field type to navigation data bar field data model type. */
type NavDataBarFieldTypeModelMap = {
    [Type in keyof NavDataFieldTypeModelMap]: NavDataBarFieldModel<NavDataFieldTypeModelMap[Type] extends NavDataFieldModel<infer T> ? T : never>;
};
/**
 * A factory for navigation data bar field data models.
 */
interface NavDataBarFieldModelFactory {
    /**
     * Creates a navigation data bar field data model for a given type of field.
     * @param type A data field type.
     * @returns A navigation data bar field data model for the given field type.
     */
    create<T extends NavDataFieldType>(type: T): NavDataBarFieldTypeModelMap[T];
}
/**
 * A factory which creates data models for a single type of navigation data bar field.
 */
interface NavDataBarFieldTypeModelFactory<T extends NavDataFieldType> {
    /**
     * Creates a navigation data bar field data model for this factory's data field type.
     * @param gpsValidity The subscribable that provides the validity of the GPS data for the models.
     * @returns A navigation data bar field data model for this factory's data field type.
     */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldTypeModelMap[T];
}
/**
 * A navigation data bar field data model which uses an arbitrary subscribable to provide its value and function to
 * update the value.
 */
declare class NavDataBarFieldGenericModel<S extends Subscribable<any>, U extends (sub: S, gpsValidity: Subscribable<NavDataFieldGpsValidity>, ...args: any[]) => void = (sub: S) => void> implements NavDataBarFieldModel<SubscribableType<S>> {
    readonly gpsValidity: Subscribable<NavDataFieldGpsValidity>;
    protected readonly updateFunc: U;
    protected readonly destroyFunc?: (() => void) | undefined;
    readonly value: Subscribable<SubscribableType<S>>;
    /**
     * Constructor.
     * @param sub The subscribable used to provide this model's value.
     * @param gpsValidity The current validity state of the GPS data for this model.
     * @param updateFunc The function used to update this model's value. Can take an arbitrary number of arguments, but
     * the first must be the subscribable used to provide this model's value, and the second the model's GPS validity.
     * @param destroyFunc A function which is executed when this model is destroyed.
     */
    constructor(sub: S, gpsValidity: Subscribable<NavDataFieldGpsValidity>, updateFunc: U, destroyFunc?: (() => void) | undefined);
    /** @inheritdoc */
    update(): void;
    /** @inheritdoc */
    destroy(): void;
}
/**
 * Extracts the length property from a tuple.
 */
type TupleLength<T extends readonly [...any[]]> = {
    length: T['length'];
};
/**
 * Maps a tuple of types to a tuple of Consumers of the same types.
 */
type ConsumerTypeMap<Types extends readonly [...any[]]> = {
    readonly [Index in keyof Types]: Consumer<Types[Index]>;
} & TupleLength<Types>;
/**
 * Maps a tuple of types to a tuple of Consumers of the same types or Subscribables of Consumers of the same types.
 */
type OptionalSubscribableConsumerTypeMap<Types extends readonly [...any[]]> = {
    readonly [Index in keyof Types]: Consumer<Types[Index]> | Subscribable<Consumer<Types[Index]> | null>;
} & TupleLength<Types>;
/**
 * Maps a tuple of types to a tuple of ConsumerSubjects providing the same types.
 */
type ConsumerSubjectTypeMap<Types extends readonly [...any[]]> = {
    readonly [Index in keyof Types]: ConsumerSubject<Types[Index]>;
} & TupleLength<Types>;
/**
 * Maps a tuple of types to a tuple of Subscribables providing the same types.
 */
type SubscribableTypeMap<Types extends readonly [...any[]]> = {
    readonly [Index in keyof Types]: Subscribable<Types[Index]>;
} & TupleLength<Types>;
/**
 * A navigation data bar field data model which uses an arbitrary subscribable to provide its value and function to
 * update the value using data cached from one or more event bus consumers.
 * @deprecated Please use {@link NavDataBarFieldConsumerValueModel} instead.
 */
declare class NavDataBarFieldConsumerModel<S extends Subscribable<any>, C extends [...any[]]> extends NavDataBarFieldGenericModel<S, (sub: S, gpsValidity: Subscribable<NavDataFieldGpsValidity>, consumerSubs: SubscribableTypeMap<C>) => void> {
    protected readonly consumerSubs: ConsumerSubjectTypeMap<C>;
    /**
     * Constructor.
     * @param sub The subscribable used to provide this model's value.
     * @param gpsValidity The current validity state of the GPS data for this model.
     * @param consumers The event bus consumers used by this model.
     * @param initialValues The initial consumer values with which to initialize this model. These values will be used
     * until they are replaced by consumed values from the event bus.
     * @param updateFunc The function used to update this model's value. The first argument taken by the function is the
     * subscribable used to provide this model's value. The second argument is a tuple of Subscribables providing the
     * cached values from this model's consumers.
     */
    constructor(sub: S, gpsValidity: Subscribable<NavDataFieldGpsValidity>, consumers: ConsumerTypeMap<C>, initialValues: C, updateFunc: (sub: S, gpsValidity: Subscribable<NavDataFieldGpsValidity>, consumerSubs: SubscribableTypeMap<C>) => void);
    /** @inheritdoc */
    update(): void;
}
/**
 * A navigation data bar field data model which provides a {@link NumberUnitInterface} value that is derived directly
 * from an event bus consumer.
 * @deprecated Please use {@link NavDataBarFieldConsumerValueNumberUnitModel} instead.
 */
declare class NavDataBarFieldConsumerNumberUnitModel<F extends string, U extends Unit<F> = Unit<F>> extends NavDataBarFieldConsumerModel<NumberUnitSubject<F, U>, [number]> {
    /**
     * Constructor.
     * @param gpsValidity The current validity state of the GPS data for this model.
     * @param consumer The event bus consumer used to derive this model's value.
     * @param initialVal The initial consumer value with which to initialize this model. This value will be used until it
     * is replaced by a consumed value from the event bus.
     * @param consumerUnit The unit type of the values consumed from the event bus.
     */
    constructor(gpsValidity: Subscribable<NavDataFieldGpsValidity>, consumer: Consumer<number>, initialVal: number, consumerUnit: U);
}
/**
 * Maps a tuple of types to a tuple of ConsumerValues providing the same types.
 */
type ConsumerValueTypeMap<Types extends readonly [...any[]]> = {
    readonly [Index in keyof Types]: ConsumerValue<Types[Index]>;
} & TupleLength<Types>;
/**
 * Maps a tuple of types to a tuple of ReadonlyConsumerValues providing the same types.
 */
type ReadonlyConsumerValueTypeMap<Types extends readonly [...any[]]> = {
    readonly [Index in keyof Types]: ReadonlyConsumerValue<Types[Index]>;
} & TupleLength<Types>;
/**
 * A navigation data bar field data model which uses an arbitrary subscribable to provide its value and function to
 * update the value using data cached from one or more event bus consumers.
 */
declare class NavDataBarFieldConsumerValueModel<S extends Subscribable<any>, C extends readonly [...any[]]> extends NavDataBarFieldGenericModel<S, (sub: S, gpsValidity: Subscribable<NavDataFieldGpsValidity>, consumerValues: ReadonlyConsumerValueTypeMap<C>) => void> {
    protected readonly consumerValues: ConsumerValueTypeMap<C>;
    protected readonly consumerSubs: Subscription[];
    /**
     * Creates a new instance of NavDataBarFieldConsumerValueModel.
     * @param sub The subscribable used to provide this model's value.
     * @param gpsValidity The current validity state of the GPS data for this model.
     * @param consumers The event bus consumers used by this model.
     * @param initialValues The initial consumer values with which to initialize this model. These values will be used
     * until they are replaced by consumed values from the event bus.
     * @param updateFunc The function used to update this model's value. The first argument taken by the function is the
     * subscribable used to provide this model's value. The second argument is a tuple of {@link ReadonlyConsumerValue}
     * objects providing the cached values from this model's consumers.
     * @param onDestroy A function which will be called when the model is destroyed.
     */
    constructor(sub: S, gpsValidity: Subscribable<NavDataFieldGpsValidity>, consumers: OptionalSubscribableConsumerTypeMap<C>, initialValues: C, updateFunc: (sub: S, gpsValidity: Subscribable<NavDataFieldGpsValidity>, consumerSubs: ReadonlyConsumerValueTypeMap<C>) => void, onDestroy?: () => void);
    /** @inheritdoc */
    update(): void;
}
/**
 * A navigation data bar field data model which provides a {@link NumberUnitInterface} value that is derived directly
 * from an event bus consumer.
 */
declare class NavDataBarFieldConsumerValueNumberUnitModel<F extends string, U extends Unit<F> = Unit<F>> extends NavDataBarFieldConsumerValueModel<NumberUnitSubject<F, U>, [number]> {
    /**
     * Creates a new instance of NavDataBarFieldConsumerValueNumberUnitModel.
     * @param gpsValidity The current validity state of the GPS data for this model.
     * @param consumer The event bus consumer used to derive this model's value.
     * @param initialVal The initial consumer value with which to initialize this model. This value will be used until it
     * is replaced by a consumed value from the event bus.
     * @param consumerUnit The unit type of the values consumed from the event bus.
     * @param onDestroy A function which will be called when the model is destroyed.
     */
    constructor(gpsValidity: Subscribable<NavDataFieldGpsValidity>, consumer: Consumer<number> | Subscribable<Consumer<number> | null>, initialVal: number, consumerUnit: U, onDestroy?: () => void);
}

/**
 * A generic implementation of a factory for navigation data bar field data models. For each data field type, a
 * single-type model factory can be registered. Once registered, the single-type model factory is used to create data
 * models for its assigned data field type.
 */
declare class GenericNavDataBarFieldModelFactory implements NavDataBarFieldModelFactory {
    private readonly gpsValidity;
    private readonly factories;
    /**
     * Creates an instance of aGenericNavDataBarFieldModelFactory.
     * @param gpsValidity The subscribable that provides the validity of the GPS data for the models.
     */
    constructor(gpsValidity: Subscribable<NavDataFieldGpsValidity>);
    /**
     * Registers a single-type model factory with this factory.
     * @param type The data field type of the single-type model factory to register.
     * @param factory The single-type model factory to register.
     */
    register<T extends NavDataFieldType>(type: T, factory: NavDataBarFieldTypeModelFactory<T>): void;
    /**
     * Deregisters a single-type model factory from this factory.
     * @param type The data field type of the single-type model factory to deregister.
     * @returns Whether a single-type model factory was deregistered.
     */
    deregister<T extends NavDataFieldType>(type: T): boolean;
    /**
     * Creates a navigation data bar field data model for a given type of field.
     * @param type A data bar field type.
     * @returns A navigation data bar field data model for the given field type.
     * @throws Error if an unsupported field type is specified.
     */
    create<T extends NavDataFieldType>(type: T): NavDataBarFieldTypeModelMap[T];
}

/**
 * Configuration options for {@link DefaultNavDataBarFieldModelFactory}.
 */
type DefaultNavDataBarFieldModelFactoryOptions = {
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
};
/**
 * A default implementation of NavDataBarFieldModelFactory.
 */
declare class DefaultNavDataBarFieldModelFactory implements NavDataBarFieldModelFactory {
    protected readonly factory: GenericNavDataBarFieldModelFactory;
    /**
     * Creates a new instance of DefaultNavDataBarFieldModelFactory.
     * @param bus The event bus.
     * @param gpsValidity The subscribable that provides the validity of the GPS data for the models.
     * @param options Options with which to configure the factory.
     */
    constructor(bus: EventBus, gpsValidity: Subscribable<NavDataFieldGpsValidity>, options?: Readonly<DefaultNavDataBarFieldModelFactoryOptions>);
    /**
     * Creates a new instance of DefaultNavDataBarFieldModelFactory.
     * @param bus The event bus.
     * @param fms The flight management system.
     * @param gpsValidity The subscribable that provides the validity of the GPS data for the models.
     * @param options Options with which to configure the factory.
     * @deprecated Please use the constructor overload without the `fms` parameter, since that parameter is no longer
     * used.
     */
    constructor(bus: EventBus, fms: Fms, gpsValidity: Subscribable<NavDataFieldGpsValidity>, options?: Readonly<DefaultNavDataBarFieldModelFactoryOptions>);
    /**
     * Creates a navigation data bar field data model for a given type of field.
     * @param type A data bar field type.
     * @returns A navigation data bar field data model for the given field type.
     * @throws Error if an unsupported field type is specified.
     */
    create<T extends NavDataFieldType>(type: T): NavDataBarFieldTypeModelMap[T];
}

/**
 * An abstract implementation of {@link NavDataBarFieldTypeModelFactory} which accesses data from the event bus to use
 * to create its data models.
 */
declare abstract class EventBusNavDataBarFieldTypeModelFactory<T extends NavDataFieldType, E> implements NavDataBarFieldTypeModelFactory<T> {
    private readonly bus;
    protected readonly sub: _microsoft_msfs_sdk.EventSubscriber<E>;
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /** @inheritDoc */
    abstract create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldTypeModelMap[T];
}

/**
 * A navigation data bar user setting name.
 */
type NavDataBarSettingName = `navDataBarField${number}`;
/**
 * Type descriptions for navigation data bar user settings.
 */
type NavDataBarSettingTypes = Record<NavDataBarSettingName, NavDataFieldType>;
/**
 * Utility class for retrieving navigation data bar user setting managers.
 */
declare class NavDataBarUserSettings {
    /**
     * Creates a manager for navigation data bar user settings.
     * @param bus The event bus.
     * @param defaultValues The default values for the settings. One indexed setting will be created for each default
     * value, in order.
     * @returns A new manager for navigation data bar user settings.
     */
    static createManager(bus: EventBus, defaultValues: NavDataFieldType[]): DefaultUserSettingManager<NavDataBarSettingTypes>;
}

/**
 * Renders navigation data fields.
 */
interface NavDataFieldRenderer {
    /**
     * Renders a navigation data field of a given type.
     * @param type A navigation data field type.
     * @param model The data model for the field.
     * @returns A navigation data field of the given type, as a VNode.
     * @throws Error if an unsupported field type is specified.
     */
    render<T extends NavDataFieldType>(type: T, model: NavDataFieldTypeModelMap[T]): VNode;
}
/**
 * Renders data field components for a single type of navigation data field.
 */
interface NavDataFieldTypeRenderer<T extends NavDataFieldType> {
    /**
     * Renders a navigation data field of this renderer's data field type.
     * @param model The data model to use for the data field.
     * @returns A navigation data field of this renderer's data field type, as a VNode.
     */
    render(model: NavDataFieldTypeModelMap[T]): VNode;
}

/**
 * Component props for NavDataBar.
 */
interface NavDataBarProps extends ComponentProps {
    /** The event bus. */
    bus: EventBus;
    /** The number of navigation data fields displayed. */
    fieldCount: number;
    /** A navigation data bar field model factory. */
    modelFactory: NavDataBarFieldModelFactory;
    /** A navigation data field renderer. */
    fieldRenderer: NavDataFieldRenderer;
    /** A user setting manager for the settings that control the data bar's field types. */
    dataBarSettingManager: UserSettingManager<NavDataBarSettingTypes>;
    /** The update frequency of the data fields, in hertz. */
    updateFreq: number;
    /** CSS class(es) to add to the data bar's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * A navigation data bar. Displays zero or more navigation data fields.
 *
 * The root element of the status bar contains the `nav-data-bar` CSS class by default.
 */
declare class NavDataBar extends DisplayComponent<NavDataBarProps> {
    private static readonly RESERVED_CSS_CLASSES;
    private readonly fieldCount;
    private readonly fieldSlots;
    private readonly fields;
    private readonly models;
    private readonly settingSubs;
    private clockSub?;
    private cssClassSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Responds to changes in field settings.
     * @param index The index of the field whose setting changed.
     * @param type The new setting.
     */
    private onFieldSettingChanged;
    /**
     * Responds to update events.
     */
    private onUpdated;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Creates data models for Above Ground Level navigation data bar fields.
 */
declare class NavDataBarFieldAglModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.AboveGroundLevel, GNSSEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
}
/**
 * Creates data models for Bearing to Waypoint navigation data bar fields.
 */
declare class NavDataBarFieldBrgModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.BearingToWaypoint, GNSSEvents & LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldBrgModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
}
/**
 * Creates data models for Cabin Altitude navigation data bar fields.
 */
declare class NavDataBarFieldCabinAltitudeModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.CabinAltitude, PressurizationEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
}
/**
 * Creates data models for Climb Gradient navigation data bar fields.
 */
declare class NavDataBarFieldClgModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.ClimbGradient, AdcEvents & GNSSEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<number>;
}
/**
 * Creates data models for Climb Gradient (height per distance) navigation data bar fields.
 */
declare class NavDataBarFieldClmModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.ClimbGradientPerDistance, AdcEvents & GNSSEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.DistanceRatio>>;
}
/**
 * Creates data models for Density Altitude navigation data bar fields.
 */
declare class NavDataBarFieldDensityAltitudeModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.DensityAltitude, AdcEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
}
/**
 * Creates data models for Destination navigation data bar fields.
 */
declare class NavDataBarFieldDestModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.Destination, LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldDestModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<string>;
}
/**
 * Creates data models for Distance to Waypoint navigation data bar fields.
 */
declare class NavDataBarFieldDisModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.DistanceToWaypoint, LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldDisModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
}
/**
 * Creates data models for Distance to Destination navigation data bar fields.
 */
declare class NavDataBarFieldDtgModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.DistanceToDestination, LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldDtgModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
}
/**
 * Creates data models for Desired Track navigation data bar fields.
 */
declare class NavDataBarFieldDtkModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.DesiredTrack, GNSSEvents & LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldDtkModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
}
/**
 * Creates data models for Fuel Economy navigation data bar fields.
 */
declare class NavDataBarFieldEcoModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.FuelEconomy, GNSSEvents & EngineEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.DistancePerWeight>>;
}
/**
 * Creates data models for Endurance navigation data bar fields.
 */
declare class NavDataBarFieldEndModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.Endurance, EngineEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Duration>>;
}
/**
 * Creates data models for Time To Destination navigation data bar fields.
 */
declare class NavDataBarFieldEnrModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.TimeToDestination, GNSSEvents & LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldEnrModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Duration>>;
}
/**
 * Creates data models for Estimated Time of Arrival navigation data bar fields.
 */
declare class NavDataBarFieldEtaModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.TimeOfWaypointArrival, GNSSEvents & LNavEvents & LNavDataEvents & ClockEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldEtaModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<number>;
}
/**
 * Creates data models for Time To Waypoint navigation data bar fields.
 */
declare class NavDataBarFieldEteModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.TimeToWaypoint, GNSSEvents & LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldEteModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Duration>>;
}
/**
 * Creates data models for Fuel Flow navigation data bar fields.
 */
declare class NavDataBarFieldFuelFlowModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.FuelFlow, EngineEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.WeightFlux>>;
}
/**
 * Creates data models for Flight Level navigation data bar fields.
 */
declare class NavDataBarFieldFlightLevelModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.FlightLevel, GNSSEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
}
/**
 * Creates data models for Fuel on Board navigation data bar fields.
 */
declare class NavDataBarFieldFobModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.FuelOnBoard, EngineEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Weight>>;
}
/**
 * Creates data models for Fuel Over Destination navigation data bar fields.
 */
declare class NavDataBarFieldFodModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.FuelOverDestination, GNSSEvents & LNavEvents & LNavDataEvents & EngineEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldFodModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Weight>>;
}
/**
 * Creates data models for G-Meter navigation data bar fields.
 */
declare class NavDataBarFieldGMeterModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.GMeter, AccelerometerEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<number>;
}
/**
 * Creates data models for GPS Altitude navigation data bar fields.
 */
declare class NavDataBarFieldGpsAltitudeModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.GpsAltitude, GNSSEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
}
/**
 * Creates data models for Ground Speed navigation data bar fields.
 */
declare class NavDataBarFieldGsModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.GroundSpeed, GNSSEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Speed>>;
}
/**
 * Creates data models for ISA navigation data bar fields.
 */
declare class NavDataBarFieldIsaModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.ISA, AdcEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.TemperatureDelta>>;
}
/**
 * Creates data models for Estimated Time of Arrival at Destination navigation data bar fields.
 */
declare class NavDataBarFieldLdgModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.TimeOfDestinationArrival, GNSSEvents & LNavEvents & LNavDataEvents & ClockEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldLdgModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<number>;
}
/**
 * Creates data models for Mach Number navigation data bar fields.
 */
declare class NavDataBarFieldMachModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.MachNumber, AdcEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<number>;
}
/**
 * Creates data models for Outside Air Temperature navigation data bar fields.
 */
declare class NavDataBarFieldOatModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.OutsideTemperature, AdcEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Temperature>>;
}
/**
 * Creates data models for Ram Air Temperature navigation data bar fields.
 */
declare class NavDataBarFieldRatModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.RamAirTemperature, AdcEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Temperature>>;
}
/**
 * Creates data models for True Airspeed navigation data bar fields.
 */
declare class NavDataBarFieldTasModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.TrueAirspeed, AdcEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Speed>>;
}
/**
 * Creates data models for Track Angle Error navigation data bar fields.
 */
declare class NavDataBarFieldTkeModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.TrackAngleError, GNSSEvents & LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldTkeModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Angle>>;
}
/**
 * Creates data models for Ground Track navigation data bar fields.
 */
declare class NavDataBarFieldTrkModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.GroundTrack, GNSSEvents & AhrsEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
}
/**
 * Creates data models for UTC Time navigation data bar fields.
 */
declare class NavDataBarFieldUtcModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.UtcTime, ClockEvents> {
    /** @inheritdoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<number>;
}
/**
 * Creates data models for Vertical Speed Required navigation data bar fields.
 */
declare class NavDataBarFieldVsrModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.VerticalSpeedRequired, GarminVNavEvents & GarminVNavDataEvents> {
    protected readonly vnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldVsrModelFactory.
     * @param bus The event bus.
     * @param vnavIndex The index of the VNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, vnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Speed>>;
}
/**
 * Creates data models for Active Waypoint navigation data bar fields.
 */
declare class NavDataBarFieldWptModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.Waypoint, LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldWptModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<string>;
}
/**
 * Creates data models for Cross Track navigation data bar fields.
 */
declare class NavDataBarFieldXtkModelFactory extends EventBusNavDataBarFieldTypeModelFactory<NavDataFieldType.CrossTrack, LNavEvents & LNavDataEvents> {
    protected readonly lnavIndex: number | Subscribable<number>;
    /**
     * Creates a new instance of NavDataBarFieldXtkModelFactory.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavDataBarFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
}

/**
 * Setting modes for date/time format.
 */
declare enum DateTimeFormatSettingMode {
    UTC = "UTC",
    Local24 = "Local24",
    Local12 = "Local12"
}
/**
 * Garmin date/time user settings.
 */
type DateTimeUserSettingTypes = {
    /** Date/time format. */
    dateTimeFormat: DateTimeFormatSettingMode;
    /** Local time offset, in milliseconds. */
    dateTimeLocalOffset: number;
};
/**
 * Instrument-local versions of Garmin date/time user settings.
 */
type LocalDateTimeUserSettingTypes = {
    [P in keyof DateTimeUserSettingTypes as `${P}_local`]: DateTimeUserSettingTypes[P];
};
/**
 * Utility class for retrieving date/time user setting managers.
 */
declare class DateTimeUserSettings {
    private static INSTANCE;
    private static LOCAL_INSTANCE;
    /**
     * Retrieves a manager for date/time user settings.
     * @param bus The event bus.
     * @returns A manager for date/time user settings.
     */
    static getManager(bus: EventBus): UserSettingManager<DateTimeUserSettingTypes>;
    /**
     * Retrieves a manager for instrument-local date/time user settings.
     * @param bus The event bus.
     * @returns A manager for instrument-local date/time user settings.
     */
    static getLocalManager(bus: EventBus): UserSettingManager<DateTimeUserSettingTypes>;
    /**
     * Gets the default values for a full set of standard display units user settings.
     * @returns The default values for a full set of standard display units user settings.
     */
    private static getDefaultValues;
}

/**
 * A generic implementation of a navigation data field renderer. For each data field type, a single-type renderer
 * can be registered. Once registered, the single-type renderer is used to create render data fields for its assigned
 * data field type.
 */
declare class GenericNavDataFieldRenderer implements NavDataFieldRenderer {
    private readonly renderers;
    /**
     * Registers a single-type renderer.
     * @param type The data field type of the single-type renderer to register.
     * @param renderer The single-type renderer to register.
     */
    register<T extends NavDataFieldType>(type: T, renderer: NavDataFieldTypeRenderer<T>): void;
    /**
     * Deregisters a single-type renderer.
     * @param type The data field type of the single-type renderer to deregister.
     * @returns Whether a single-type renderer was deregistered.
     */
    deregister<T extends NavDataFieldType>(type: T): boolean;
    /** @inheritdoc */
    render<T extends NavDataFieldType>(type: T, model: NavDataFieldTypeModelMap[T]): VNode;
}

/**
 * A next-generation (NXi, G3000, etc) implementation of {@link NavDataFieldRenderer} which supports all navigation
 * data bar field types.
 */
declare class NextGenNavDataBarFieldRenderer implements NavDataFieldRenderer {
    protected readonly renderer: GenericNavDataFieldRenderer;
    /**
     * Constructor.
     * @param unitsSettingManager A display units user setting manager.
     * @param dateTimeSettingManager A date/time user setting manager.
     */
    constructor(unitsSettingManager: UnitsUserSettingManager, dateTimeSettingManager: UserSettingManager<DateTimeUserSettingTypes>);
    /** @inheritdoc */
    render<T extends NavDataFieldType>(type: T, model: NavDataFieldTypeModelMap[T]): VNode;
}

/**
 * Component props for NavDataField.
 */
interface NavDataFieldProps<T> extends ComponentProps {
    /** The title of the data field. */
    title: string;
    /** The model data field's data model. */
    model: NavDataFieldModel<T>;
    /** CSS class(es) to apply to the root of the component. */
    class?: string;
}
/**
 * A navigation data field, consisting of a title and a value.
 *
 * The root element of the field contains the `nav-data-field` CSS class by default.
 *
 * The root element contains a child title element with the CSS class `nav-data-field-title`.
 */
declare abstract class NavDataField<T, P extends NavDataFieldProps<T> = NavDataFieldProps<T>> extends DisplayComponent<P> {
    /** @inheritDoc */
    render(): VNode;
    /**
     * Renders this data field's value component.
     * @returns This data field's value component, as a VNode.
     */
    protected abstract renderValue(): VNode;
}
/**
 * Component props for NavDataGenericField.
 */
interface NavDataGenericFieldProps<T> extends NavDataFieldProps<T> {
    /** A function to execute when the component is destroyed. */
    onDestroy?: () => void;
}
/**
 * A generic navigation data field which renders its children as its value.
 *
 * The root element of the field contains the `nav-data-field` CSS class by default.
 *
 * The root element contains a child title element with the CSS class `nav-data-field-title`.
 */
declare class NavDataGenericField<T, P extends NavDataGenericFieldProps<T> = NavDataGenericFieldProps<T>> extends NavDataField<T, P> {
    /**
     * Renders this data field's value component.
     * @returns This data field's value component, as a VNode.
     */
    protected renderValue(): VNode;
    /** @inheritDoc */
    destroy(): void;
}
/**
 * Component props for NavDataNumberUnitField.
 */
interface NavDataNumberUnitFieldProps<T extends NumberUnitInterface<string>> extends NavDataFieldProps<T> {
    /** A subscribable which provides the display unit type. */
    displayUnit: Unit<FamilyOfUnit<UnitOfNumber<T>>> | null | Subscribable<Unit<FamilyOfUnit<UnitOfNumber<T>>> | null>;
    /** A function which formats numbers. */
    formatter: (number: number) => string;
    /**
     * A function which formats units. The formatted unit text should be written to the 2-tuple passed to the `out`
     * parameter, as `[bigText, smallText]`. `bigText` and `smallText` will be rendered into separate `<span>` elements
     * representing the big and small components of the rendered unit text, respectively. If not defined, then units
     * will be formatted based on the text generated by the `UnitFormatter` class.
     */
    unitFormatter?: (out: [string, string], unit: Unit<FamilyOfUnit<UnitOfNumber<T>>>, number: number) => void;
    /** Whether to hide the unit text when the displayed value is equal to `NaN`. Defaults to `false`. */
    hideUnitWhenNaN?: boolean;
}
/**
 * A navigation data field which displays a value consisting of a number with unit type.
 *
 * The root element of the field contains the `nav-data-field` CSS class by default.
 *
 * The root element contains a child title element with the CSS class `nav-data-field-title`.
 */
declare class NavDataNumberUnitField<T extends NumberUnitInterface<string>> extends NavDataField<T, NavDataNumberUnitFieldProps<T>> {
    private readonly numberUnitRef;
    /** @inheritDoc */
    renderValue(): VNode;
    /** @inheritDoc */
    destroy(): void;
}
/**
 * Component props for `NavDataNumberField`.
 */
interface NavDataNumberFieldProps<T extends number> extends NavDataFieldProps<T> {
    /** A function which formats numbers. */
    formatter: (number: number) => string;
}
/**
 * Component props for NavDataDurationField.
 */
interface NavDataDurationFieldProps<T extends NumberUnitInterface<UnitFamily.Duration>> extends NavDataFieldProps<T> {
    /** Formatting options. */
    options?: Partial<DurationDisplayOptions>;
}
/**
 * A navigation data field which displays a value consisting of a formatted duration.
 *
 * The root element of the field contains the `nav-data-field` CSS class by default.
 *
 * The root element contains a child title element with the CSS class `nav-data-field-title`.
 */
declare class NavDataDurationField<T extends NumberUnitInterface<UnitFamily.Duration>> extends NavDataField<T, NavDataDurationFieldProps<T>> {
    private readonly durationRef;
    /** @inheritDoc */
    renderValue(): VNode;
    /** @inheritDoc */
    destroy(): void;
}
/**
 * Component props for NavDataTimeField.
 */
interface NavDataTimeFieldProps extends NavDataFieldProps<number> {
    /** The display format. */
    format: TimeDisplayFormat | Subscribable<TimeDisplayFormat>;
    /** The local time offset, in milliseconds. */
    localOffset: number | Subscribable<number>;
    /** Whether to the pad the hour text with leading zeroes (up to two digits). Defaults to `true`. */
    padHour?: boolean | Subscribable<boolean>;
    /**
     * A function which formats suffixes to append to the displayed time. If not defined, then the suffix will be
     * will be formatted as `'UTC'` if the display format is {@link TimeDisplayFormat.UTC}, `'LCL'` if the display format
     * is {@link TimeDisplayFormat.Local24}, and either `'AM'` or `'PM'` if the display format is
     * {@link TimeDisplayFormat.Local12}.
     */
    suffixFormatter?: (format: TimeDisplayFormat, isAm: boolean) => string;
    /** Whether to hide the suffix when the displayed time is equal to `NaN`. Defaults to `false`. */
    hideSuffixWhenNaN?: boolean;
}
/**
 * A navigation data field which displays a value consisting of a formatted time.
 *
 * The root element of the field contains the `nav-data-field` CSS class by default.
 *
 * The root element contains a child title element with the CSS class `nav-data-field-title`.
 */
declare class NavDataTimeField extends NavDataField<number, NavDataTimeFieldProps> {
    private readonly timeRef;
    /** @inheritDoc */
    renderValue(): VNode;
    /** @inheritDoc */
    destroy(): void;
}
/**
 * Component props for NavDataBearingField.
 */
interface NavDataBearingFieldProps<T extends NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>> extends NavDataFieldProps<T> {
    /** A subscribable which provides the display unit type. */
    displayUnit: NavAngleUnit | null | Subscribable<NavAngleUnit | null>;
    /** A function which formats numbers. */
    formatter: (number: number) => string;
    /**
     * A function which formats units. The formatted unit text should be written to the 2-tuple passed to the `out`
     * parameter, as `[bigText, smallText]`. `bigText` and `smallText` will be rendered into separate `<span>` elements
     * representing the big and small components of the rendered unit text, respectively. If not defined, then units
     * will be formatted such that `bigText` is always the degree symbol () and `smallText` is empty for magnetic
     * bearing or `'T'` for true bearing.
     */
    unitFormatter?: (out: [string, string], unit: NavAngleUnit, number: number) => void;
    /** Whether to display 360 in place of 0. True by default. */
    use360?: boolean;
}
/**
 * A navigation data field which displays a bearing value.
 *
 * The root element of the field contains the `nav-data-field` CSS class by default.
 *
 * The root element contains a child title element with the CSS class `nav-data-field-title`.
 */
declare class NavDataBearingField<T extends NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>> extends NavDataField<T, NavDataBearingFieldProps<T>> {
    private readonly bearingRef;
    /** @inheritDoc */
    renderValue(): VNode;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * Basic configuration options for navigation data field renderers.
 */
type BaseNavDataFieldTypeRendererOptions = {
    /** The title to display for the field. */
    title: string;
    /** CSS class(es) to apply to the field's root element. */
    class?: string;
};
/**
 * NavDataField types that have models whose values extend {@link NumberUnitInterface}.
 */
type NumberUnitNavDataFieldTypes = keyof {
    [P in NavDataFieldType as NavDataFieldTypeModelMap[P] extends NavDataFieldModel<NumberUnitInterface<string>> ? P : never]: P;
};
/**
 * Configuration options for {@link NavDataFieldNumberUnitRenderer}.
 */
type NavDataFieldNumberUnitRendererOptions<T extends NumberUnitInterface<string>> = Pick<NavDataNumberUnitFieldProps<T>, 'displayUnit' | 'formatter' | 'unitFormatter' | 'hideUnitWhenNaN'> & BaseNavDataFieldTypeRendererOptions;
/**
 * Renders Distance to Waypoint navigation data fields.
 */
declare class NavDataFieldNumberUnitRenderer<T extends NumberUnitNavDataFieldTypes> implements NavDataFieldTypeRenderer<T> {
    protected readonly options: Readonly<NavDataFieldNumberUnitRendererOptions<TypeOfNavDataFieldModel<NavDataFieldTypeModelMap[T]>>>;
    /**
     * Creates a new instance of NavDataFieldNumberUnitRenderer.
     * @param options Options with which to configure the renderer.
     */
    constructor(options: Readonly<NavDataFieldNumberUnitRendererOptions<TypeOfNavDataFieldModel<NavDataFieldTypeModelMap[T]>>>);
    /** @inheritDoc */
    render(model: NavDataFieldTypeModelMap[T]): VNode;
}
/**
 * NavDataField types that have models whose values are {@link NumberUnitInterface|NumberUnitInterfaces} with a
 * navigation angle unit family.
 */
type BearingNavDataFieldTypes = keyof {
    [P in NavDataFieldType as NavDataFieldTypeModelMap[P] extends NavDataFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>> ? P : never]: P;
};
/**
 * Configuration options for {@link NavDataFieldBearingRenderer}.
 */
type NavDataFieldBearingRendererOptions<T extends NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>> = Pick<NavDataBearingFieldProps<T>, 'displayUnit' | 'formatter' | 'unitFormatter' | 'use360'> & BaseNavDataFieldTypeRendererOptions;
/**
 * Renders navigation data fields which display a bearing value.
 */
declare class NavDataFieldBearingRenderer<T extends BearingNavDataFieldTypes> implements NavDataFieldTypeRenderer<T> {
    protected readonly options: Readonly<NavDataFieldBearingRendererOptions<TypeOfNavDataFieldModel<NavDataFieldTypeModelMap[T]>>>;
    /**
     * Creates a new instance of NavDataFieldBearingRenderer.
     * @param options Options with which to configure the renderer.
     */
    constructor(options: Readonly<NavDataFieldBearingRendererOptions<TypeOfNavDataFieldModel<NavDataFieldTypeModelMap[T]>>>);
    /** @inheritDoc */
    render(model: NavDataFieldTypeModelMap[T]): VNode;
}
/**
 * NavDataField types that have models whose values are {@link NumberUnitInterface|NumberUnitInterfaces} with a
 * duration unit family.
 */
type DurationNavDataFieldTypes = keyof {
    [P in NavDataFieldType as NavDataFieldTypeModelMap[P] extends NavDataFieldModel<NumberUnitInterface<UnitFamily.Duration>> ? P : never]: P;
};
/**
 * Configuration options for {@link NavDataFieldDurationRenderer}.
 */
type NavDataFieldDurationRendererOptions<T extends NumberUnitInterface<UnitFamily.Duration>> = Pick<NavDataDurationFieldProps<T>, 'options'> & BaseNavDataFieldTypeRendererOptions;
/**
 * Renders navigation data fields which display a duration value.
 */
declare class NavDataFieldDurationRenderer<T extends DurationNavDataFieldTypes> implements NavDataFieldTypeRenderer<T> {
    protected readonly options: Readonly<NavDataFieldDurationRendererOptions<TypeOfNavDataFieldModel<NavDataFieldTypeModelMap[T]>>>;
    /**
     * Creates a new instance of NavDataFieldDurationRenderer.
     * @param options Options with which to configure the renderer.
     */
    constructor(options: Readonly<NavDataFieldDurationRendererOptions<TypeOfNavDataFieldModel<NavDataFieldTypeModelMap[T]>>>);
    /** @inheritDoc */
    render(model: NavDataFieldTypeModelMap[T]): VNode;
}
/**
 * NavDataField types that have models whose values are numbers.
 */
type TimeNavDataFieldTypes = keyof {
    [P in NavDataFieldType as NavDataFieldTypeModelMap[P] extends NavDataFieldModel<number> ? P : never]: P;
};
/**
 * Configuration options for {@link NavDataFieldTimeRenderer}.
 */
type NavDataFieldTimeRendererOptions = Pick<NavDataTimeFieldProps, 'format' | 'localOffset' | 'padHour' | 'suffixFormatter' | 'hideSuffixWhenNaN'> & BaseNavDataFieldTypeRendererOptions;
/**
 * Renders navigation data fields which display a time value.
 */
declare class NavDataFieldTimeRenderer<T extends TimeNavDataFieldTypes> implements NavDataFieldTypeRenderer<T> {
    protected readonly options: Readonly<NavDataFieldTimeRendererOptions>;
    /**
     * Creates a new instance of NavDataFieldTimeRenderer.
     * @param options Options with which to configure the renderer.
     */
    constructor(options: Readonly<NavDataFieldTimeRendererOptions>);
    /** @inheritDoc */
    render(model: NavDataFieldTypeModelMap[T]): VNode;
}
/**
 * Configuration options for {@link NavDataFieldTextRenderer}.
 */
type NavDataFieldTextRendererOptions<T> = {
    /**
     * A function which formats model values to displayed text. If not defined, then model values will be formatted using
     * Javascript's built-in `toString()` function.
     */
    formatter?: (value: T) => string;
} & BaseNavDataFieldTypeRendererOptions;
/**
 * Renders navigation data fields which display a text value.
 */
declare class NavDataFieldTextRenderer<T extends NavDataFieldType> implements NavDataFieldTypeRenderer<T> {
    protected readonly options: Readonly<NavDataFieldTextRendererOptions<TypeOfNavDataFieldModel<NavDataFieldTypeModelMap[T]>>>;
    protected readonly formatter: (value: TypeOfNavDataFieldModel<NavDataFieldTypeModelMap[T]>) => string;
    /**
     * Creates a new instance of NavDataFieldDestRenderer.
     * @param options Options with which to configure the renderer.
     */
    constructor(options: Readonly<NavDataFieldTextRendererOptions<TypeOfNavDataFieldModel<NavDataFieldTypeModelMap[T]>>>);
    /** @inheritDoc */
    render(model: NavDataFieldTypeModelMap[T]): VNode;
}

/**
 * An abstract next-generation (NXi, G3000, etc) implementation of {@link NavDataFieldTypeRenderer} which supports
 * display unit settings.
 */
declare abstract class NextGenDisplayUnitNavDataFieldTypeRenderer<T extends NavDataFieldType> implements NavDataFieldTypeRenderer<T> {
    protected readonly unitsSettingManager: UnitsUserSettingManager;
    protected static readonly ALTITUDE_FORMATTER: (number: number) => string;
    protected static readonly ANGLE_FORMATTER: (number: number) => string;
    protected static readonly BEARING_FORMATTER: (number: number) => string;
    protected static readonly DISTANCE_FORMATTER: (number: number) => string;
    protected static readonly FUEL_FORMATTER: (number: number) => string;
    protected static readonly ISA_FORMATTER: (number: number) => string;
    protected static readonly SPEED_FORMATTER: (number: number) => string;
    protected static readonly TEMPERATURE_FORMATTER: (number: number) => string;
    protected static readonly DURATION_OPTIONS: {
        pad: number;
        format: DurationDisplayFormat;
        delim: DurationDisplayDelim;
        nanString: string;
    };
    /**
     * Constructor.
     * @param unitsSettingManager A user setting manager for measurement units.
     */
    constructor(unitsSettingManager: UnitsUserSettingManager);
    /** @inheritdoc */
    abstract render(model: NavDataFieldTypeModelMap[T]): VNode;
}
/**
 * An abstract next-generation (NXi, G3000, etc) implementation of {@link NavDataFieldTypeRenderer} which supports
 * date/time settings.
 */
declare abstract class NextGenDateTimeNavDataFieldTypeRenderer<T extends NavDataFieldType> implements NavDataFieldTypeRenderer<T> {
    protected readonly dateTimeSettingManager: UserSettingManager<DateTimeUserSettingTypes>;
    protected static readonly FORMAT_SETTING_MAP: {
        Local12: TimeDisplayFormat;
        Local24: TimeDisplayFormat;
        UTC: TimeDisplayFormat;
    };
    protected readonly timeFormat: _microsoft_msfs_sdk.UserSetting<DateTimeFormatSettingMode>;
    protected readonly localOffset: _microsoft_msfs_sdk.UserSetting<number>;
    protected readonly timeFormatMapped: _microsoft_msfs_sdk.MappedSubscribable<TimeDisplayFormat>;
    /**
     * Constructor.
     * @param dateTimeSettingManager A date/time user setting manager.
     */
    constructor(dateTimeSettingManager: UserSettingManager<DateTimeUserSettingTypes>);
    /** @inheritdoc */
    abstract render(model: NavDataFieldTypeModelMap[T]): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Bearing to Waypoint navigation data fields.
 */
declare class NextGenNavDataFieldBrgRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.BearingToWaypoint> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Destination navigation data fields.
 */
declare class NextGenNavDataFieldDestRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.Destination> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<string>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Distance to Waypoint navigation data fields.
 */
declare class NextGenNavDataFieldDisRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.DistanceToWaypoint> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Distance to Destination navigation data fields.
 */
declare class NextGenNavDataFieldDtgRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.DistanceToDestination> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Desired Track navigation data fields.
 */
declare class NextGenNavDataFieldDtkRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.DesiredTrack> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Endurance navigation data fields.
 */
declare class NextGenNavDataFieldEndRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.Endurance> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Duration>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Time to Destination navigation data fields.
 */
declare class NextGenNavDataFieldEnrRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.TimeToDestination> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Duration>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Estimated Time of Arrival navigation data fields.
 */
declare class NextGenNavDataFieldEtaRenderer extends NextGenDateTimeNavDataFieldTypeRenderer<NavDataFieldType.TimeOfWaypointArrival> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<number>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Time to Waypoint navigation data fields.
 */
declare class NextGenNavDataFieldEteRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.TimeToWaypoint> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Duration>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Fuel on Board navigation data fields.
 */
declare class NextGenNavDataFieldFobRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.FuelOnBoard> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Weight>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Fuel Over Destination navigation data fields.
 */
declare class NextGenNavDataFieldFodRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.FuelOverDestination> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Weight>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Ground Speed navigation data fields.
 */
declare class NextGenNavDataFieldGsRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.GroundSpeed> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Speed>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) ISA navigation data fields.
 */
declare class NextGenNavDataFieldIsaRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.ISA> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.TemperatureDelta>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Estimated Time of Arrival at Destination navigation data fields.
 */
declare class NavDataFieldLdgRenderer extends NextGenDateTimeNavDataFieldTypeRenderer<NavDataFieldType.TimeOfDestinationArrival> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<number>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) True Airspeed navigation data fields.
 */
declare class NextGenNavDataFieldTasRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.TrueAirspeed> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Speed>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Track Angle Error navigation data fields.
 */
declare class NextGenNavDataFieldTkeRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.TrackAngleError> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Angle>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Ground Track navigation data fields.
 */
declare class NextGenNavDataFieldTrkRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.GroundTrack> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Vertical Speed Required navigation data fields.
 */
declare class NextGenNavDataFieldVsrRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.VerticalSpeedRequired> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Speed>>): VNode;
}
/**
 * Renders next-generation (NXi, G3000, etc) Cross Track navigation data fields.
 */
declare class NextGenNavDataFieldXtkRenderer extends NextGenDisplayUnitNavDataFieldTypeRenderer<NavDataFieldType.CrossTrack> {
    private readonly renderer;
    /** @inheritdoc */
    render(model: NavDataFieldModel<NumberUnitInterface<UnitFamily.Distance>>): VNode;
}

/**
 * A provider of angle of attack data for an airspeed indicator.
 */
interface AirspeedAoaDataProvider {
    /**
     * The correlation coefficient between a given normalized angle of attack and the estimated indicated airspeed in
     * knots required to maintain level flight at that angle of attack for the current aircraft configuration and
     * environment, or `null` if such a value cannot be calculated.
     */
    readonly normAoaIasCoef: Subscribable<number | null>;
    /**
     * Estimates the indicated airspeed, in knots, required to maintain level flight at a given normalized angle of
     * attack value for the current aircraft configuration and environment. Normalized angle of attack is defined such
     * that `0` equals zero-lift AoA, and `1` equals stall AoA.
     * @param normAoa A normalized angle of attack value.
     * @returns The estimated indicated airspeed, in knots, required to maintain level flight at the specified angle of
     * attack, or `NaN` if an estimate cannot be made.
     */
    estimateIasFromNormAoa(normAoa: number): number;
}

/**
 * A definition for an indicated airspeed value.
 */
interface AirspeedDefinition {
    /** This definition's airspeed value, in knots. */
    readonly value: number | Subscribable<number>;
    /**
     * Destroys this definition, freeing up any resources it is using and allowing it to be garbage collected if no
     * external references to it exist.
     */
    destroy?(): void;
}

/**
 * A context for a {@link AirspeedDefinitionFactory}.
 */
type AirspeedDefinitionContext = {
    /** The event bus. */
    readonly bus: EventBus;
    /** The current pressure altitude, in feet. */
    readonly pressureAlt: Subscribable<number>;
    /** The current conversion factor from mach number to knots indicated airspeed. */
    readonly machToKias: Subscribable<number>;
    /** The current conversion factor from true airspeed to indicated airspeed. */
    readonly tasToIas: Subscribable<number>;
    /**
     * The correlation coefficient between a given normalized angle of attack and the estimated indicated airspeed in
     * knots required to maintain level flight at that angle of attack for the current aircraft configuration and
     * environment, or `null` if such a value cannot be calculated.
     */
    readonly normAoaIasCoef: Subscribable<number | null>;
    /**
     * Estimates the indicated airspeed, in knots, required to maintain level flight at a given normalized angle of
     * attack value for the current aircraft configuration and environment. Normalized angle of attack is defined such
     * that `0` equals zero-lift AoA, and `1` equals stall AoA.
     * @param normAoa A normalized angle of attack value.
     * @returns The estimated indicated airspeed, in knots, required to maintain level flight at the specified angle of
     * attack, or `NaN` if an estimate cannot be made.
     */
    estimateIasFromNormAoa(normAoa: number): number;
};
/**
 * A function that creates a definition of an indicated airspeed value.
 */
type AirspeedDefinitionFactory = (context: AirspeedDefinitionContext) => AirspeedDefinition;

/**
 * Type descriptions for reference V-speed user settings.
 */
type VSpeedUserSettingTypes = {
    /** The default value of a V-speed reference, in knots, or -1 if no such value exists. */
    [defaultValue: `vSpeedDefaultValue_${string}`]: number;
    /** The current user-defined value of a V-speed reference, in knots, or -1 if no such value exists. */
    [userValue: `vSpeedUserValue_${string}`]: number;
    /** The current FMS-defined value of a V-speed reference, in knots, or -1 if no such value exists. */
    [fmsValue: `vSpeedFmsValue_${string}`]: number;
    /** Whether the aircraft configuration does not match the one used by the FMS to calculate the value of a V-speed reference. */
    [fmsConfigMiscompare: `vSpeedFmsConfigMiscompare_${string}`]: boolean;
    /** Whether to show a V-speed reference on the PFD airspeed indicator. */
    [show: `vSpeedShow_${string}`]: boolean;
};
/**
 * A utility class for working with reference V-speed user settings.
 */
declare class VSpeedUserSettingUtils {
    /**
     * Creates a mapped subscribable which provides the active value of a reference V-speed, in knots. The active value
     * is derived from the following values (in order of decreasing precedence):
     *
     * 1. User-defined value.
     * 2. FMS-defined value.
     * 3. Default value.
     * @param name The name of the reference V-speed.
     * @param settingManager A manager for reference V-speed user settings.
     * @param useFmsValue Whether to support the V-speed's FMS-defined value.
     * @param allowZeroValue Whether to allow the active value to be equal to zero. If `false`, a value of zero is
     * treated as an undefined value (similar to negative values). Defaults to `false`.
     * @returns A mapped subscribable which provides the active value of the specified reference V-speed, in knots.
     */
    static activeValue(name: string, settingManager: UserSettingManager<Omit<VSpeedUserSettingTypes, `vSpeedShow_${string}`>>, useFmsValue: true, allowZeroValue?: boolean): MappedSubscribable<number>;
    /**
     * Creates a mapped subscribable which provides the active value of a reference V-speed, in knots. The active value
     * is derived from the following values (in order of decreasing precedence):
     *
     * 1. User-defined value.
     * 2. Default value.
     * @param name The name of the reference V-speed.
     * @param settingManager A manager for reference V-speed user settings.
     * @param useFmsValue Whether to support the V-speed's FMS-defined value.
     * @param allowZeroValue Whether to allow the active value to be equal to zero. If `false`, a value of zero is
     * treated as an undefined value (similar to negative values). Defaults to `false`.
     * @returns A mapped subscribable which provides the active value of the specified reference V-speed, in knots.
     */
    static activeValue(name: string, settingManager: UserSettingManager<Omit<VSpeedUserSettingTypes, `vSpeedShow_${string}` | `vSpeedFmsValue_${string}`>>, useFmsValue: false, allowZeroValue?: boolean): MappedSubscribable<number>;
    /**
     * Creates a mapped subscribable which provides whether a reference V-speed is using its user-defined value as its
     * active value.
     * @param name The name of the reference V-speed.
     * @param settingManager A manager for reference V-speed user settings.
     * @param useFmsValue Whether to support the V-speed's FMS-defined value.
     * @returns A mapped subscribable which provides whether the specified reference V-speed is using its user-defined
     * value as its active value.
     */
    static isUserValueActive(name: string, settingManager: UserSettingManager<Omit<VSpeedUserSettingTypes, `vSpeedShow_${string}`>>, useFmsValue: true): MappedSubscribable<boolean>;
    /**
     * Creates a mapped subscribable which provides whether a reference V-speed is using its user-defined value as its
     * active value.
     * @param name The name of the reference V-speed.
     * @param settingManager A manager for reference V-speed user settings.
     * @param useFmsValue Whether to support the V-speed's FMS-defined value.
     * @returns A mapped subscribable which provides whether the specified reference V-speed is using its user-defined
     * value as its active value.
     */
    static isUserValueActive(name: string, settingManager: UserSettingManager<Omit<VSpeedUserSettingTypes, `vSpeedShow_${string}` | `vSpeedFmsValue_${string}`>>, useFmsValue: false): MappedSubscribable<boolean>;
    /**
     * Creates a mapped subscribable which provides whether a reference V-speed is using its FMS-defined value as its
     * active value.
     * @param name The name of the reference V-speed.
     * @param settingManager A manager for reference V-speed user settings.
     * @returns A mapped subscribable which provides whether the specified reference V-speed is using its FMS-defined
     * value as its active value.
     */
    static isFmsValueActive(name: string, settingManager: UserSettingManager<Omit<VSpeedUserSettingTypes, `vSpeedShow_${string}`>>): MappedSubscribable<boolean>;
}

/**
 * Width options for airspeed indicator color ranges.
 */
declare enum AirspeedIndicatorColorRangeWidth {
    Full = "Full",
    Half = "Half"
}
/**
 * Color options for airspeed indicator color ranges.
 */
declare enum AirspeedIndicatorColorRangeColor {
    Red = "Red",
    Yellow = "Yellow",
    White = "White",
    Green = "Green",
    BarberPole = "BarberPole"
}
/**
 * An airspeed indicator color range.
 */
type AirspeedIndicatorColorRange = {
    /** The width of this color range. */
    readonly width: AirspeedIndicatorColorRangeWidth;
    /** The color of this color range. */
    readonly color: AirspeedIndicatorColorRangeColor;
    /** A factory which generates the minimum speed of this color range, in knots. */
    readonly minimum: AirspeedDefinitionFactory;
    /** A factory which generates the maximum speed of this color range, in knots. */
    readonly maximum: AirspeedDefinitionFactory;
};

/**
 * Types of airspeed alerts.
 */
declare enum AirspeedAlert {
    None = 0,
    Overspeed = 1,
    TrendOverspeed = 2,
    Underspeed = 4,
    TrendUnderspeed = 8
}
/**
 * A data provider for an airspeed indicator.
 */
interface AirspeedIndicatorDataProvider {
    /** The event bus. */
    readonly bus: EventBus;
    /** The current indicated airspeed, in knots. */
    readonly iasKnots: Subscribable<number>;
    /** The current true airspeed, in knots. */
    readonly tasKnots: Subscribable<number>;
    /** The current mach number. */
    readonly mach: Subscribable<number>;
    /** The current conversion factor from mach number to knots indicated airspeed. */
    readonly machToKias: Subscribable<number>;
    /** The current conversion factor from true airspeed to indicated airspeed. */
    readonly tasToIas: Subscribable<number>;
    /** The current pressure altitude, in feet. */
    readonly pressureAlt: Subscribable<number>;
    /** The current airspeed trend, in knots. */
    readonly iasTrend: Subscribable<number>;
    /** The current reference indicated airspeed, or `null` if no such value exists. */
    readonly referenceIas: Subscribable<number | null>;
    /** The current reference mach number, or `null` if no such value exists. */
    readonly referenceMach: Subscribable<number | null>;
    /** Whether the current reference airspeed was set manually. */
    readonly referenceIsManual: Subscribable<boolean>;
    /** Whether an airspeed hold mode is active on the flight director. */
    readonly isAirspeedHoldActive: Subscribable<boolean>;
    /** The current active airspeed alerts, as bitflags. */
    readonly airspeedAlerts: Subscribable<number>;
    /** The current threshold for an overspeed condition. */
    readonly overspeedThreshold: Subscribable<number>;
    /** The current threshold for an underspeed condition. */
    readonly underspeedThreshold: Subscribable<number>;
    /** Whether autopilot overspeed protection is active. */
    readonly isOverspeedProtectionActive: Subscribable<boolean>;
    /** Whether autopilot underspeed protection is active. */
    readonly isUnderspeedProtectionActive: Subscribable<boolean>;
    /**
     * The correlation coefficient between a given normalized angle of attack and the estimated indicated airspeed in
     * knots required to maintain level flight at that angle of attack for the current aircraft configuration and
     * environment, or `null` if such a value cannot be calculated.
     */
    readonly normAoaIasCoef: Subscribable<number | null>;
    /** Whether airspeed data is in a failure state. */
    readonly isDataFailed: Subscribable<boolean>;
    /**
     * Estimates the indicated airspeed, in knots, required to maintain level flight at a given normalized angle of
     * attack value for the current aircraft configuration and environment. Normalized angle of attack is defined such
     * that `0` equals zero-lift AoA, and `1` equals stall AoA.
     * @param normAoa A normalized angle of attack value.
     * @returns The estimated indicated airspeed, in knots, required to maintain level flight at the specified angle of
     * attack, or `NaN` if an estimate cannot be made.
     */
    estimateIasFromNormAoa(normAoa: number): number;
}

/**
 * V-speed annunciation types.
 */
declare enum VSpeedAnnunciation {
    None = "None",
    Takeoff = "Takeoff",
    Landing = "Landing"
}
/**
 * A provider of PFD V-speed annunciation data.
 */
interface VSpeedAnnunciationDataProvider {
    /** The currently active V-speed annunciation. */
    readonly annunciation: Subscribable<VSpeedAnnunciation>;
}
/**
 * Configuration options for {@link DefaultVSpeedAnnunciationDataProvider}.
 */
type DefaultVSpeedAnnunciationDataProviderOptions = {
    /** The ID of the FMS from which to source flight phase data. Defaults to the empty ID (`''`). */
    fmsId?: string | Subscribable<string>;
};
/**
 * A default implementation of {@link VSpeedAnnunciationDataProvider}.
 */
declare class DefaultVSpeedAnnunciationDataProvider implements VSpeedAnnunciationDataProvider {
    private readonly bus;
    private static readonly COUNT_TRUE_FUNC;
    private readonly fmsId;
    private readonly _annunciation;
    /** @inheritdoc */
    readonly annunciation: Subscribable<VSpeedAnnunciation>;
    private readonly isOnGround;
    private readonly flightPhase;
    private readonly takeoffVSpeedShowSettings;
    private readonly landingVSpeedShowSettings;
    private readonly takeoffVSpeedShowCount;
    private readonly landingVSpeedShowCount;
    private isInit;
    private isAlive;
    private isPaused;
    private fmsIdSub?;
    private isOnGroundSub?;
    private takeoffAnnuncPipe?;
    private landingAnnuncPipe?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param vSpeedSettingManager A manager for V-speed user settings.
     * @param takeoffVSpeedNames The names of every takeoff V-speed.
     * @param landingVSpeedNames The names of every landing V-speed.
     * @param options Options with which to configure the data provider.
     */
    constructor(bus: EventBus, vSpeedSettingManager: UserSettingManager<VSpeedUserSettingTypes>, takeoffVSpeedNames: Iterable<string>, landingVSpeedNames: Iterable<string>, options?: Readonly<DefaultVSpeedAnnunciationDataProviderOptions>);
    /**
     * Initializes this data provider. Once initialized
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Resets this data provider to provide an annunciation type of `VSpeedAnnunciation.None`.
     */
    reset(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Airspeed indicator V-speed bug colors.
 */
declare enum VSpeedBugColor {
    Cyan = "Cyan",
    White = "White",
    Green = "Green",
    Red = "Red"
}
/**
 * A definition for an airspeed indicator reference V-speed bug.
 */
type VSpeedBugDefinition = {
    /** The name of the bug's reference V-speed. */
    readonly name: string;
    /** The bug's label text. */
    readonly label: string;
    /** The color of the bug's label text. Defaults to `VSpeedBugColor.Cyan`. */
    readonly labelColor?: VSpeedBugColor;
    /**
     * Whether the bug's displayed label color should ignore whether the bug's reference V-speed has been set by FMS. If
     * `true`, then the bug's label text will not change color when the bug's reference V-speed has been set by FMS.
     * Defaults to `false`.
     */
    readonly labelColorIgnoreFms?: boolean;
    /** Whether to show an off-scale label for the bug when the airspeed is off-scale. */
    readonly showOffscale: boolean;
    /** Whether to show a legend for the bug at the bottom of the airspeed tape. */
    readonly showLegend: boolean;
};

/**
 * Scale options for an airspeed tape.
 */
type AirspeedTapeScaleOptions = Pick<AirspeedTapeProps, 'minimum' | 'maximum' | 'window' | 'majorTickInterval' | 'minorTickFactor'>;
/**
 * Options for an airspeed trend vector.
 */
type AirspeedTrendVectorOptions = Pick<AirspeedTapeProps, 'trendThreshold'>;
/**
 * Options for airspeed alerts.
 */
type AirspeedAlertOptions = {
    /** Whether to support the overspeed alert. */
    supportOverspeed: boolean;
    /** Whether to support the trend overspeed alert. */
    supportTrendOverspeed: boolean;
    /** Whether to support the underspeed alert. */
    supportUnderspeed: boolean;
    /** Whether to suppor the trend underspeed alert. */
    supportTrendUnderspeed: boolean;
};
/**
 * Modes for an airspeed indicator's bottom display box.
 */
declare enum AirspeedIndicatorBottomDisplayMode {
    TrueAirspeed = "Tas",
    Mach = "Mach"
}
/**
 * Options for an airspeed indicator's bottom display box.
 */
type AirspeedIndicatorBottomDisplayOptions = {
    /** The display mode. */
    mode: AirspeedIndicatorBottomDisplayMode;
    /** The minimum mach number required to display the box, if it is in mach display mode. Defaults to `0`. */
    machThreshold?: number | Subscribable<number>;
};
/**
 * Options for an airspeed indicator's displayed reference V-speed bugs.
 */
type VSpeedBugOptions = {
    /** A user setting manager containing reference V-speed settings. */
    vSpeedSettingManager: UserSettingManager<VSpeedUserSettingTypes>;
    /** An iterable of definitions for each displayed reference V-speed bug. */
    vSpeedBugDefinitions: Iterable<VSpeedBugDefinition>;
    /** Whether to allow V-speed bugs to be displayed with a speed value of zero. */
    allowZeroValue?: boolean;
};
/**
 * Options for an airspeed indicator's approach cue bug.
 */
type AirspeedApproachCueBugOptions = {
    /**
     * A factory that generates the speed value of the bug, in knots. If the speed value is `NaN`, then the bug will be
     * hidden.
     */
    speed: AirspeedDefinitionFactory;
};
/**
 * Component props for {@link AirspeedIndicator}.
 */
interface AirspeedIndicatorProps extends ComponentProps {
    /** A data provider for the indicator. */
    dataProvider: AirspeedIndicatorDataProvider;
    /** A provider of V-speed annunciation data. If not defined, the indicator will not display V-speed annunciations. */
    vSpeedAnnunciationDataProvider?: VSpeedAnnunciationDataProvider;
    /**
     * Whether the indicator should be decluttered due to unusual attitudes. When decluttered, the following features are
     * hidden:
     * * Airspeed reference display
     * * Airspeed protection annunciations
     */
    declutter: Subscribable<boolean>;
    /**
     * Whether the indicator should be shown in simplified mode. In simplified mode, the airspeed reference display is
     * replaced by an 'Speed' label, and the following features are hidden:
     * * Airspeed protection annunciations
     * * Airspeed alert (overspeed/underspeed) indications
     * * Color ranges
     * * Reference airspeed bug
     * * V-speed bugs
     * * Approach cue bug
     * * Trend vector
     * * Bottom display box
     *
     * Defaults to `false`.
     */
    simplified?: boolean | Subscribable<boolean>;
    /** Scale options for the airspeed tape. */
    tapeScaleOptions: Readonly<AirspeedTapeScaleOptions>;
    /** Definitions for color ranges to include on the airspeed tape. */
    colorRanges: Iterable<AirspeedIndicatorColorRange>;
    /** Options for the trend vector. */
    trendVectorOptions: Readonly<AirspeedTrendVectorOptions>;
    /** Options for airspeed alerts. If not defined, then airspeed alert indications will not be displayed. */
    airspeedAlertOptions?: Readonly<AirspeedAlertOptions>;
    /** Options for the bottom display box. */
    bottomDisplayOptions: Readonly<AirspeedIndicatorBottomDisplayOptions>;
    /** Options for reference V-speed bugs. If not defined, then V-speed bugs will not be displayed. */
    vSpeedBugOptions?: Readonly<VSpeedBugOptions>;
    /** Options for the approach cue bug. If not defined, then the approach cue bug will not be displayed. */
    approachCueBugOptions?: Readonly<AirspeedApproachCueBugOptions>;
    /** CSS class(es) to apply to the indicator's root element. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin PFD airspeed indicator.
 */
declare class AirspeedIndicator extends DisplayComponent<AirspeedIndicatorProps> {
    private static readonly RESERVED_CLASSES;
    private readonly referenceRef;
    private readonly alertRef;
    private readonly tapeRef;
    private readonly rootCssClass;
    private readonly simplified;
    private readonly airspeedAlertOptions;
    private readonly activeAlert;
    private readonly showDefaultTopBottomDisplays;
    private readonly topAltitudeLabelDisplay;
    private readonly isAirspeedReferenceDisplayVisible;
    private readonly isTopDisplayVisible;
    private readonly isBottomDisplayVisible;
    private isAlive;
    private isAwake;
    private readonly subscriptions;
    private isDataFailedSub?;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Wakes this indicator. While awake, this indicator will automatically update its appearance.
     * @throws Error if this indicator is dead.
     */
    wake(): void;
    /**
     * Puts this indicator to sleep. While asleep, this indicator will not automatically update its appearance.
     * @throws Error if this indicator is dead.
     */
    sleep(): void;
    /**
     * Responds to when whether airspeed data is in a failed state changes.
     * @param isDataFailed Whether airspeed data is in a failed state.
     */
    private onDataFailedChanged;
    /**
     * Updates this indicator's root CSS class list in response to the current active airspeed alert.
     * @param alert The current active airspeed alert.
     */
    private updateAlertClass;
    /** @inheritDoc */
    render(): VNode;
    /** @inheritDoc */
    destroy(): void;
}
/**
 * Component props for AirspeedTape.
 */
interface AirspeedTapeProps extends ComponentProps {
    /** A data provider for the indicator. */
    dataProvider: AirspeedIndicatorDataProvider;
    /** Whether the tape should be shown in simplified mode. */
    simplified: Subscribable<boolean>;
    /** The minimum airspeed representable on the tape, in knots. */
    minimum: number | Subscribable<number>;
    /** The maximum airspeed representable on the tape, in knots. */
    maximum: number | Subscribable<number>;
    /**
     * The size of the airspeed tape window, in knots (i.e. the difference between the highest and lowest airspeeds
     * visible on the tape at any given time).
     */
    window: number | Subscribable<number>;
    /** The interval between major ticks, in knots. */
    majorTickInterval: number | Subscribable<number>;
    /** The number of minor ticks for each major tick. */
    minorTickFactor: number | Subscribable<number>;
    /** Definitions for color ranges to include on the tape. */
    colorRanges: Iterable<AirspeedIndicatorColorRange>;
    /** The minimum absolute value of the airspeed trend, in knots, required to display the trend vector. */
    trendThreshold: number | Subscribable<number>;
    /** Options for reference V-speed bugs. If not defined, then V-speed bugs will not be displayed. */
    vSpeedBugOptions?: Readonly<VSpeedBugOptions>;
    /** Options for the approach cue bug. If not defined, then the approach cue bug will not be displayed. */
    approachCueBugOptions?: Readonly<AirspeedApproachCueBugOptions>;
}

/**
 * Configuration options for {@link AirspeedIndicatorDataProvider}.
 */
type AirspeedIndicatorDataProviderOptions = {
    /**
     * Whether airspeed hold is active. If not defined, airspeed hold is considered active if and only if the flight
     * director is in FLC mode.
     */
    isAirspeedHoldActive?: boolean | Subscribable<boolean>;
    /** The lookahead time for the airspeed trend, in seconds. */
    trendLookahead: number | Subscribable<number>;
    /** A factory which generates the overspeed threshold in knots. */
    overspeedThreshold: AirspeedDefinitionFactory;
    /** A factory which generates the underspeed threshold in knots. */
    underspeedThreshold: AirspeedDefinitionFactory;
};
/**
 * A default implementation of {@link AirspeedIndicatorDataProvider}.
 */
declare class DefaultAirspeedIndicatorDataProvider implements AirspeedIndicatorDataProvider {
    readonly bus: EventBus;
    private readonly aoaDataProvider?;
    private static readonly SPEED_CONVERSION_SMOOTHING_TAU;
    private static readonly DEFAULT_IAS_TREND_INPUT_SMOOTHING_TAU;
    private static readonly DEFAULT_IAS_TREND_TREND_SMOOTHING_TAU;
    private readonly _iasKnots;
    /** @inheritDoc */
    readonly iasKnots: Subscribable<number>;
    private readonly _tasKnots;
    /** @inheritDoc */
    readonly tasKnots: Subscribable<number>;
    private readonly _mach;
    /** @inheritDoc */
    readonly mach: Subscribable<number>;
    private readonly _machToKias;
    /** @inheritDoc */
    readonly machToKias: Subscribable<number>;
    private readonly _tasToIas;
    /** @inheritDoc */
    readonly tasToIas: Subscribable<number>;
    private readonly _pressureAlt;
    /** @inheritDoc */
    readonly pressureAlt: Subscribable<number>;
    private readonly _iasTrend;
    /** @inheritDoc */
    readonly iasTrend: Subscribable<number>;
    private readonly _referenceIas;
    /** @inheritDoc */
    readonly referenceIas: Subscribable<number | null>;
    private readonly _referenceMach;
    /** @inheritDoc */
    readonly referenceMach: Subscribable<number | null>;
    private readonly _referenceIsManual;
    /** @inheritDoc */
    readonly referenceIsManual: Subscribable<boolean>;
    /** @inheritDoc */
    readonly isAirspeedHoldActive: Subscribable<boolean>;
    private readonly _airspeedAlerts;
    /** @inheritDoc */
    readonly airspeedAlerts: Subscribable<number>;
    private readonly _isOverspeedProtectionActive;
    /** @inheritDoc */
    readonly isOverspeedProtectionActive: Subscribable<boolean>;
    private readonly _isUnderspeedProtectionActive;
    /** @inheritDoc */
    readonly isUnderspeedProtectionActive: Subscribable<boolean>;
    /** @inheritDoc */
    readonly normAoaIasCoef: Subscribable<number | null>;
    private readonly isAirspeedDataValid;
    /** @inheritDoc */
    readonly isDataFailed: Subscribable<boolean>;
    private readonly adcIndex;
    private readonly machToKiasSmoother;
    private lastMachToKiasTime;
    private readonly tasToIasSmoother;
    private lastTasToIasTime;
    private readonly simTime;
    private readonly isOnGround;
    private readonly referenceIasSource;
    private readonly referenceMachSource;
    private readonly referenceIsMach;
    private readonly referenceIasPipe;
    private readonly referenceMachPipe;
    private readonly isFlcActive?;
    private readonly trendLookahead;
    private readonly iasLookahead;
    private lastTrendTime?;
    private readonly overspeedThresholdDef;
    /** @inheritDoc */
    readonly overspeedThreshold: Subscribable<number>;
    private readonly underspeedThresholdDef;
    /** @inheritDoc */
    readonly underspeedThreshold: Subscribable<number>;
    private readonly isOverspeed;
    private readonly isTrendOverspeed;
    private readonly isUnderspeed;
    private readonly isTrendUnderspeed;
    private isInit;
    private isAlive;
    private isPaused;
    private adcIndexSub?;
    private machToKiasSub?;
    private tasToIasSub?;
    private trendLookaheadSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param adcIndex The index of the ADC that is the source of this provider's data.
     * @param options Configuration options for this provider.
     * @param aoaDataProvider A provider of angle of attack data.
     * @param trendInputSmoothingTau The smoothing time constant, in milliseconds, to apply to the IAS lookahead trend's
     * input values. Defaults to `2000 / ln(2)`.
     * @param trendTrendSmoothingTau The smoothing time constant, in milliseconds, to apply to the IAS lookahead trend
     * values. Defaults to `1000 / ln(2)`.
     */
    constructor(bus: EventBus, adcIndex: number | Subscribable<number>, options: Readonly<AirspeedIndicatorDataProviderOptions>, aoaDataProvider?: AirspeedAoaDataProvider | undefined, trendInputSmoothingTau?: number, trendTrendSmoothingTau?: number);
    /**
     * Initializes this data provider. Once initialized
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /** @inheritdoc */
    estimateIasFromNormAoa(normAoa: number): number;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * A data provider for an altimeter.
 */
interface AltimeterDataProvider {
    /** The current indicated altitude, in feet. */
    readonly indicatedAlt: Subscribable<number>;
    /** The current indicated altitude trend, in feet. */
    readonly altitudeTrend: Subscribable<number>;
    /** The current barometric pressure setting, in inches of mercury. */
    readonly baroSetting: Subscribable<number>;
    /** Whether STD BARO mode is active. */
    readonly baroIsStdActive: Subscribable<boolean>;
    /** The current preselected barometric pressure setting, in inches of mercury. */
    readonly baroPreselect: Subscribable<number>;
    /** The current selected altitude, or `null` if no such value exists. */
    readonly selectedAlt: Subscribable<number | null>;
    /** The current active minimums, in feet indicated altitude, or `null` if no such value exists. */
    readonly minimums: Subscribable<number | null>;
    /** The current radar altitude, in feet, or `null` if there is no valid radar altitude. */
    readonly radarAlt: Subscribable<number | null>;
    /** Whether altitude data is in a failure state. */
    readonly isDataFailed: Subscribable<boolean>;
}

/**
 * Events used to control altitude alerters.
 */
interface AltitudeAlerterControlEvents {
    /** Resets an alerter's state to Disabled. */
    [alt_alert_disable: `alt_alert_disable_${number}`]: void;
}
/**
 * Altitude alert states.
 */
declare enum AltitudeAlertState {
    /** Disabled. */
    Disabled = "Disabled",
    /** Inhibited. */
    Inhibited = "Inhibited",
    /** Armed and outside of 1000 feet of selected altitude prior to capture. */
    Armed = "Armed",
    /** Within 1000 feet of selected altitude prior to capture. */
    Within1000 = "Within1000",
    /** Within 200 feet of selected altitude prior to capture. */
    Within200 = "Within200",
    /** Captured the selected altitude. */
    Captured = "Captured",
    /** Deviation from captured altitude is greater than 200 feet. */
    Deviation = "Deviation"
}
/**
 * Maintains an altitude alert state based on the relationship between indicated altitude and selected altitude.
 */
declare class AltitudeAlerter {
    readonly index: number;
    private readonly bus;
    private static readonly SELECTED_ALT_CHANGE_INHIBIT_DURATION;
    private readonly _state;
    readonly state: Subscribable<AltitudeAlertState>;
    private readonly stateChangeQueue;
    private isChangingState;
    private readonly adcIndex;
    private readonly indicatedAlt;
    private readonly selectedAltSource;
    private readonly selectedAltIsInit;
    private readonly selectedAlt;
    private readonly isOnGround;
    private readonly gpApproachMode;
    private readonly isGsGpActive;
    private readonly isAlertInhibited;
    private targetAltitude;
    private readonly inhibitTimer;
    private adcIndexSub?;
    private apLockSub?;
    private disableSub?;
    private selectedAltSub?;
    private indicatedAltSub?;
    private isInit;
    private isAlive;
    /**
     * Creates an instance of AltitudeAlerter.
     * @param index The index of this alerter.
     * @param bus The event bus.
     * @param adcIndex The index of the ADC from which this alerter sources indicated altitude data.
     */
    constructor(index: number, bus: EventBus, adcIndex: number | Subscribable<number>);
    /**
     * Initializes this alerter. Once initialized, this alerter will continuously update its alert state until destroyed.
     * @throws Error if this alerter is dead.
     */
    init(): void;
    /**
     * Requests a change in the state of this alerter. If no state change is currently in progress, the request will be
     * processed immediately. If a state change is currently in progress, the request will be queued and processed after
     * all pending state change requests are processed if no state change other than the one currently in progress is
     * carried out.
     * @param state The alert state to which to change.
     */
    private changeState;
    /**
     * Processes a state change request.
     * @param state The alert state to which to change.
     */
    private processStateChange;
    /**
     * Processes the next state change request in the queue, if one exists.
     */
    private dequeueStateChange;
    /**
     * Destroys this alerter. Once destroyed, this alerter will no longer update its alert state.
     */
    destroy(): void;
}

/**
 * Minimums alert states.
 */
declare enum MinimumsAlertState {
    /** Inhibited. */
    Inhibited = "Inhibited",
    /** Armed. */
    Armed = "Armed",
    /** Greater than 100 feet above minimums. */
    Above100 = "Above100",
    /** Less than or equal to 100 feet above minimums. */
    Within100 = "Within100",
    /** At or below minimums. */
    AtOrBelow = "AtOrBelow"
}
/**
 * Maintains a minimums alert state based on the relationship between indicated/radar altitude and the appropriate
 * minimums setting.
 */
declare class MinimumsAlerter {
    private readonly bus;
    private readonly supportRadarMins;
    private readonly _minimumsMode;
    readonly minimumsMode: Subscribable<MinimumsMode>;
    private readonly _state;
    readonly state: Subscribable<MinimumsAlertState>;
    private readonly stateChangeQueue;
    private isChangingState;
    private readonly adcIndex;
    private readonly indicatedAlt;
    private readonly radarAlt;
    private readonly baroMinimumsSource;
    private readonly radarMinimumsSource;
    private readonly isAdcOperating;
    private readonly isRadarAltimeterOperating;
    private readonly minimumsDelta;
    private readonly isOnGround;
    private readonly isAlertInhibited;
    private adcIndexSub?;
    private adcSystemStateSub?;
    private radarAltSystemStateSub?;
    private minimumsDeltaSub?;
    private isInit;
    private isAlive;
    /**
     * Creates an instance of AltitudeAlerter.
     * @param bus The event bus.
     * @param adcIndex The index of the ADC from which this alerter sources indicated altitude data.
     * @param supportRadarMins Whether to support radar minimums.
     */
    constructor(bus: EventBus, adcIndex: number | Subscribable<number>, supportRadarMins: boolean);
    /**
     * Initializes this alerter. Once initialized, this alerter will continuously update its alert state until destroyed.
     * @throws Error if this alerter is dead.
     */
    init(): void;
    /**
     * Requests a change in the state of this alerter. If no state change is currently in progress, the request will be
     * processed immediately. If a state change is currently in progress, the request will be queued and processed after
     * all pending state change requests are processed if no state change other than the one currently in progress is
     * carried out.
     * @param state The alert state to which to change.
     */
    private changeState;
    /**
     * Processes a state change request.
     * @param state The alert state to which to change.
     */
    private processStateChange;
    /**
     * Processes the next state change request in the queue, if one exists.
     */
    private dequeueStateChange;
    /**
     * Destroys this alerter. Once destroyed, this alerter will no longer update its alert state.
     */
    destroy(): void;
}

/**
 * Scale options for an altimeter tape.
 */
type AltimeterTapeScaleOptions = Pick<AltimeterTapeProps, 'minimum' | 'maximum' | 'window' | 'majorTickInterval' | 'minorTickFactor'>;
/**
 * Options for an altitude trend vector.
 */
type AltimeterTrendVectorOptions = Pick<AltimeterTapeProps, 'trendThreshold'>;
/**
 * Component props for {@link Altimeter}.
 */
interface AltimeterProps extends ComponentProps {
    /** A data provider for the indicator. */
    dataProvider: AltimeterDataProvider;
    /**
     * The current altitude alert state. If not defined, then the altimeter will not support thye display of altitude
     * alert indications.
     */
    altitudeAlertState?: Subscribable<AltitudeAlertState>;
    /**
     * The current minimums alert state. If not defined, then the altimeter will not support the display of minimums
     * alert indications.
     */
    minimumsAlertState?: Subscribable<MinimumsAlertState>;
    /**
     * Whether the indicator should be decluttered due to unusual attitudes. When decluttered, the following features are
     * hidden:
     * * Selected altitude display
     * * Baro setting display
     */
    declutter: Subscribable<boolean>;
    /**
     * Whether the indicator should be shown in simplified mode. In simplified mode, the selected altitude display is
     * replaced by an 'Altitude' label, and the following features are hidden:
     * * Selected altitude bug
     * * Minimums bug
     * * Trend vector
     * * Ground line
     * * Baro setting display
     *
     * Defaults to `false`.
     */
    simplified?: boolean | Subscribable<boolean>;
    /** Scale options for the airspeed tape. */
    tapeScaleOptions: Readonly<AltimeterTapeScaleOptions>;
    /** Options for the trend vector. */
    trendVectorOptions: Readonly<AltimeterTrendVectorOptions>;
    /** Whether to support the display of the preselected barometric pressure setting. */
    supportBaroPreselect: boolean;
    /** Whether to show metric altitude indications. Defaults to `false`. */
    showMetricAltitude?: boolean | Subscribable<boolean>;
    /** Whether to show metric units for the baro setting instead of imperial units. Defaults to `false`. */
    showMetricBaroSetting?: boolean | Subscribable<boolean>;
    /** CSS class(es) to apply to the altimeter's root element. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin PFD altimeter.
 */
declare class Altimeter extends DisplayComponent<AltimeterProps> {
    private static readonly RESERVED_CLASSES;
    private readonly tapeRef;
    private readonly selectedAltitudeRef;
    private readonly baroSettingRef;
    private readonly rootCssClass;
    private readonly simplified;
    private readonly showMetricAltitude;
    private readonly showMetricBaroSetting;
    private readonly showDefaultTopBottomDisplays;
    private readonly topAltitudeLabelDisplay;
    private readonly isTopDisplayVisible;
    private readonly isBottomDisplayVisible;
    private isAlive;
    private isAwake;
    private readonly subscriptions;
    private minimumsAlertStateSub?;
    private isDataFailedSub?;
    private simplifiedSub?;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Wakes this altimeter. While awake, this altimeter will automatically update its appearance.
     * @throws Error if this altimeter is dead.
     */
    wake(): void;
    /**
     * Puts this altimeter to sleep. While asleep, this altimeter will not automatically update its appearance.
     * @throws Error if this altimeter is dead.
     */
    sleep(): void;
    /**
     * Responds to when whether simplified mode is active changes.
     * @param simplified Whether simplified mode is active.
     */
    private onSimplifiedModeChanged;
    /**
     * Responds to when whether altitude data is in a failed state changes.
     * @param isDataFailed Whether altitude data is in a failed state.
     */
    private onDataFailedChanged;
    /**
     * Responds to when the minimums alert state changes.
     * @param state The new minimums alert state.
     */
    private onMinimumsAlertStateChanged;
    /** @inheritDoc */
    render(): VNode;
    /** @inheritDoc */
    destroy(): void;
}
/**
 * Component props for {@link AltimeterTape}.
 */
interface AltimeterTapeProps extends ComponentProps {
    /** A data provider for the indicator. */
    dataProvider: AltimeterDataProvider;
    /** Whether the tape should be shown in simplified mode. */
    simplified: Subscribable<boolean>;
    /** The minimum altitude representable on the tape, in feet. */
    minimum: number | Subscribable<number>;
    /** The maximum altitude representable on the tape, in feet. */
    maximum: number | Subscribable<number>;
    /**
     * The size of the altimeter tape window, in feet (i.e. the difference between the highest and lowest altitudes
     * visible on the tape at any given time).
     */
    window: number | Subscribable<number>;
    /** The interval between major ticks, in feet. */
    majorTickInterval: number | Subscribable<number>;
    /** The number of minor ticks for each major tick. */
    minorTickFactor: number | Subscribable<number>;
    /** The minimum absolute value of the altitude trend, in feet, required to display the trend vector. */
    trendThreshold: number | Subscribable<number>;
    /** Whether to show the metric indicated altitude and selected altitude displays. */
    showMetric: Subscribable<boolean>;
}

/**
 * A data provider for a radar altimeter.
 */
interface RadarAltimeterDataProvider {
    /** The current radar altitude, in feet, or `NaN` if the radar altitude is above the maximum threshold (2500 feet). */
    readonly radarAlt: Subscribable<number>;
    /** Whether radar altitude data is in a failure state. */
    readonly isDataFailed: Subscribable<boolean>;
}
/**
 * A default implementation of {@link RadarAltimeterDataProvider}.
 */
declare class DefaultRadarAltimeterDataProvider implements RadarAltimeterDataProvider {
    private readonly bus;
    private static readonly ROUND_FUNC;
    private readonly radarAltSource;
    private readonly radarAltRounded;
    private readonly _radarAlt;
    /** @inheritdoc */
    readonly radarAlt: Subscribable<number>;
    private readonly _isDataFailed;
    /** @inheritdoc */
    readonly isDataFailed: Subscribable<boolean>;
    private readonly servo;
    private currentValue;
    private radarAltSystemStateSub?;
    private radarAltRoundedSub?;
    private clockSub?;
    private isInit;
    private isAlive;
    private isPaused;
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Configuration options for {@link DefaultAltimeterDataProvider}.
 */
type DefaultAltimeterDataProviderOptions = {
    /** The lookahead time for the altitude trend, in seconds. */
    trendLookahead: number | Subscribable<number>;
};
/**
 * A default implementation of {@link AltimeterDataProvider}.
 */
declare class DefaultAltimeterDataProvider implements AltimeterDataProvider {
    private readonly bus;
    private readonly radarAltimeterDataProvider?;
    private readonly _indicatedAlt;
    /** @inheritdoc */
    readonly indicatedAlt: Subscribable<number>;
    private readonly verticalSpeed;
    private readonly trendLookahead;
    private readonly _altitudeTrend;
    /** @inheritdoc */
    readonly altitudeTrend: Subscribable<number>;
    private readonly _baroSetting;
    /** @inheritdoc */
    readonly baroSetting: Subscribable<number>;
    private readonly _baroIsStdActive;
    /** @inheritdoc */
    readonly baroIsStdActive: Subscribable<boolean>;
    private readonly _baroPreselect;
    /** @inheritdoc */
    readonly baroPreselect: Subscribable<number>;
    private readonly selectedAltSource;
    private readonly selectedAltIsInit;
    private readonly _selectedAlt;
    /** @inheritdoc */
    readonly selectedAlt: Subscribable<number | null>;
    private readonly minimumsMode;
    private readonly baroMinimumsSource;
    private readonly radarMinimumsSource;
    private readonly _minimums;
    /** @inheritdoc */
    readonly minimums: Subscribable<number | null>;
    private readonly _radarAlt;
    readonly radarAlt: Subscribable<number | null>;
    private readonly isAltitudeDataValid;
    /** @inheritdoc */
    readonly isDataFailed: Subscribable<boolean>;
    private readonly adcIndex;
    private readonly simTime;
    private readonly isOnGround;
    private isInit;
    private isAlive;
    private isPaused;
    private adcIndexSub?;
    private radarAltIsFailedSub?;
    private radarAltPipe?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param adcIndex The index of the ADC that is the source of this provider's data.
     * @param options Configuration options for this provider.
     * @param radarAltimeterDataProvider A radar altimeter data provider. If not defined, this data provider will not
     * support radar altitude or radar minimums.
     */
    constructor(bus: EventBus, adcIndex: number | Subscribable<number>, options: Readonly<DefaultAltimeterDataProviderOptions>, radarAltimeterDataProvider?: RadarAltimeterDataProvider | undefined);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Component props for RadarAltimeter.
 */
interface RadarAltimeterProps extends ComponentProps {
    /** An instance of the event bus. */
    bus: EventBus;
    /** A data provider for the indicator. */
    dataProvider: RadarAltimeterDataProvider;
    /** The current active minimums mode. */
    minimumsMode: Subscribable<MinimumsMode>;
    /** The current minimums alert state. */
    minimumsAlertState: Subscribable<MinimumsAlertState>;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin PFD radar altimeter.
 */
declare class RadarAltimeter extends DisplayComponent<RadarAltimeterProps> {
    private readonly rootStyle;
    private readonly failedStyle;
    private readonly operatingStyle;
    private readonly rootCssClass;
    private readonly valueText;
    private isVisibleSub?;
    private failedSub?;
    private radarAltSub?;
    private minimumsModeSub?;
    private minimumsAlertSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A provider of angle of attack data.
 */
interface AoaDataProvider {
    /** The current angle of attack, in degrees. */
    readonly aoa: Subscribable<number>;
    /** The current normalized angle of attack. A value of `0` is equal to zero-lift AoA, and a value of `1` is equal to stall AoA. */
    readonly normAoa: Subscribable<number>;
    /** The current stall (critical) angle of attack, in degrees. */
    readonly stallAoa: Subscribable<number>;
    /** The current zero-lift angle of attack, in degrees. */
    readonly zeroLiftAoa: Subscribable<number>;
    /**
     * The correlation coefficient between a given normalized angle of attack and the estimated indicated airspeed in
     * knots required to maintain level flight at that angle of attack for the current aircraft configuration and
     * environment, or `null` if such a value cannot be calculated.
     */
    readonly normAoaIasCoef: Subscribable<number | null>;
    /** Whether the airplane is on the ground. */
    readonly isOnGround: Subscribable<boolean>;
    /** Whether this provider's AoA data is in a failed state. */
    readonly isDataFailed: Subscribable<boolean>;
    /**
     * Converts an absolute angle of attack value in degrees to a normalized angle of attack value. Normalized angle of
     * attack is defined such that `0` equals zero-lift AoA, and `1` equals stall AoA.
     * @param aoa An absolute angle of attack value, in degrees.
     * @returns The normalized equivalent of the specified angle of attack.
     */
    aoaToNormAoa(aoa: number): number;
    /**
     * Converts a normalized angle of attack value to an absolute angle of attack value in degrees. Normalized angle of
     * attack is defined such that `0` equals zero-lift AoA, and `1` equals stall AoA.
     * @param normAoa A normalized angle of attack value.
     * @returns The absolute equivalent of the specified normalized angle of attack, in degrees.
     */
    normAoaToAoa(normAoa: number): number;
    /**
     * Estimates the indicated airspeed, in knots, required to maintain level flight at a given angle of attack value
     * for the current aircraft configuration and environment.
     * @param aoa An angle of attack value, in degrees.
     * @returns The estimated indicated airspeed, in knots, required to maintain level flight at the specified angle of
     * attack, or `NaN` if an estimate cannot be made.
     */
    estimateIasFromAoa(aoa: number): number;
    /**
     * Estimates the indicated airspeed, in knots, required to maintain level flight at a given normalized angle of
     * attack value for the current aircraft configuration and environment. Normalized angle of attack is defined such
     * that `0` equals zero-lift AoA, and `1` equals stall AoA.
     * @param normAoa A normalized angle of attack value.
     * @returns The estimated indicated airspeed, in knots, required to maintain level flight at the specified angle of
     * attack, or `NaN` if an estimate cannot be made.
     */
    estimateIasFromNormAoa(normAoa: number): number;
}
/**
 * A default implementation of {@link AoaDataProvider}.
 */
declare class DefaultAoaDataProvider implements AoaDataProvider {
    private readonly bus;
    private static readonly AOA_COEF_SMOOTHING_TAU;
    private readonly _aoa;
    /** @inheritdoc */
    readonly aoa: Subscribable<number>;
    private readonly _normAoa;
    /** @inheritdoc */
    readonly normAoa: Subscribable<number>;
    private readonly _stallAoa;
    /** @inheritdoc */
    readonly stallAoa: Subscribable<number>;
    private readonly _zeroLiftAoa;
    /** @inheritdoc */
    readonly zeroLiftAoa: Subscribable<number>;
    private readonly ias;
    private readonly _isOnGround;
    /** @inheritdoc */
    readonly isOnGround: Subscribable<boolean>;
    private readonly aoaCoefSmoother;
    private lastAoaCoefTime?;
    private readonly _normAoaIasCoef;
    /** @inheritdoc */
    readonly normAoaIasCoef: Subscribable<number | null>;
    private readonly _isDataFailed;
    /** @inheritdoc */
    readonly isDataFailed: Subscribable<boolean>;
    private readonly aoaIndex;
    private readonly aoaSystemState;
    private readonly adcIndex;
    private readonly adcSystemState;
    private isAdcDataFailed;
    private isInit;
    private isAlive;
    private isPaused;
    private aoaIndexSub?;
    private adcIndexSub?;
    private clockSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param aoaIndex The index of the AoA computer that is the source of this provider's data.
     * @param adcIndex The index of the ADC that is the source of this provider's data.
     */
    constructor(bus: EventBus, aoaIndex: number | Subscribable<number>, adcIndex: number | Subscribable<number>);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /** @inheritdoc */
    aoaToNormAoa(aoa: number): number;
    /** @inheritdoc */
    normAoaToAoa(normAoa: number): number;
    /** @inheritdoc */
    estimateIasFromAoa(aoa: number): number;
    /** @inheritdoc */
    estimateIasFromNormAoa(normAoa: number): number;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Updates this data provider.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    private update;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Component props for AoaIndicator.
 */
interface AoAIndicatorProps extends ComponentProps {
    /** Whether to display the advanced version of the indicator. */
    advanced: boolean;
    /** A data provider for the indicator. */
    dataProvider: AoaDataProvider;
    /** Whether to show the digital readout of normalized angle of attack. Defaults to `false`. */
    showDigitalReadout?: boolean;
    /**
     * The normalized angle of attack value at which the donut cue is positioned, or `NaN` if the cue should not be
     * displayed. Defaults to `NaN`.
     */
    donutCueNormAoa?: number | Subscribable<number>;
    /**
     * The normalized angle of attack value at which the reference tick is positioned for the simple version of the
     * indicator. If not defined, then the reference tick will not be displayed. Ignored if `advanced` is `true`.
     */
    referenceTickNormAoa?: number | Subscribable<number>;
    /**
     * Whether to show the minor ticks for the advanced version of the indicator. Ignored if `advanced` is `false`.
     * Defaults to `false`.
     */
    showMinorTicks?: boolean;
    /** The normalized angle of attack threshold for the warning range, or `undefined` if there is no warning range. */
    warningThreshold?: number | Subscribable<number>;
    /** The normalized angle of attack threshold for the caution range, or `undefined` if there is no caution range. */
    cautionThreshold?: number | Subscribable<number>;
    /** Whether to declutter the indicator. */
    declutter: Subscribable<boolean>;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin angle of attack indicator.
 */
declare class AoaIndicator extends DisplayComponent<AoAIndicatorProps> {
    private readonly rootStyle;
    private readonly rootCssClass;
    private readonly minNormAoa;
    private readonly rotationMaxAngle;
    private readonly donutCueNormAoa;
    private readonly warningThreshold;
    private readonly cautionThreshold;
    private readonly alertType;
    private readonly readoutText;
    private readonly needleTransform;
    private readonly donutCueDisplay;
    private readonly donutCueTransform;
    private readonly warningArcTransform;
    private readonly cautionArcTransform;
    private readonly hasReferenceTick;
    private readonly referenceTickTransform;
    private readonly referenceTickNormAoa;
    private readonly referenceTickCssClass;
    private readonly advancedTickNormAoaValues;
    private readonly advancedTickCssClasses;
    private declutterSub?;
    private isDataFailedSub?;
    private aoaSub?;
    private alertTypeSub?;
    private donutCueNormAoaSub?;
    private warningThresholdSub?;
    private cautionThresholdSub?;
    private referenceTickNormAoaSub?;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Responds to when whether to declutter this indicator changes.
     * @param declutter Whether to declutter this indicator.
     */
    private onDeclutterChanged;
    /**
     * Responds to when whether angle of attack data is in a failed state changes.
     * @param isDataFailed Whether angle of attack data is in a failed state.
     */
    private onIsDataFailedChanged;
    /**
     * Responds to when the airplane's normalized angle of attack changes.
     * @param normAoa The new normalized angle of attack.
     */
    private onNormAoaChanged;
    /**
     * Responds to when this indicator's alert type changes.
     * @param alertType The new alert type.
     */
    private onAlertTypeChanged;
    /**
     * Responds to when the normalized angle of attack value at which the donut cue is positioned changes.
     * @param normAoa The new normalized angle of attack value at which the donut cue is positioned.
     */
    private onDonutCueNormAoaChanged;
    /**
     * Responds to when a normalized angle of attack value that is tracked by one of this indicator's rotating elements
     * changes.
     * @param transform The CSS transform subject controlling the indicator element's rotation.
     * @param normAoa The new normalized angle of attack value tracked by the indicator element.
     */
    private onRotatingElementNormAoaChanged;
    /** @inheritDoc */
    render(): VNode;
    /**
     * Renders the advanced gauge version for this indicator.
     * @returns The advanced gauge version for this indicator, as a VNode.
     */
    private renderSimpleGauge;
    /**
     * Renders the advanced gauge version for this indicator.
     * @returns The advanced gauge version for this indicator, as a VNode.
     */
    private renderAdvancedGauge;
    /** @inheritDoc */
    destroy(): void;
    /**
     * Gets the alert type associated with an angle of attack value given warning and caution thresholds.
     * @param aoa The angle of attack value for which to get the alert type.
     * @param warning The warning threshold.
     * @param caution The caution threshold.
     * @returns The alert type associated with the specified angle of attack value.
     */
    private static getAlertType;
    /**
     * Gets a CSS class string to apply to a gauge tick for a given alert type.
     * @param alertType The alert type for which to get the CSS class string.
     * @returns The CSS class string to apply to a gauge tick for the specified alert type.
     */
    private static getTickCssClass;
}

/**
 * Display states for an FMA master display slot.
 */
declare enum FmaMasterSlotState {
    Off = "Off",
    On = "On",
    Failed = "Failed"
}
/**
 * Component props for FmaMasterSlot.
 */
interface FmaMasterSlotProps {
    /** The slot's state. */
    state: Subscribable<FmaMasterSlotState>;
    /** CSS class(es) to apply to the slot's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * An FMA master display slot.
 */
declare class FmaMasterSlot extends DisplayComponent<FmaMasterSlotProps> {
    private static readonly RESERVED_CSS_CLASSES;
    private static readonly ALERT_DURATION;
    private readonly rootStyle;
    private readonly rootCssClass;
    private readonly alertTimer;
    private isStateOn;
    private cssClassSub?;
    private stateSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Responds to changes in this slot's state.
     * @param state The slot's current state.
     */
    private onStateChanged;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Data describing the active autopilot mode for an FMA mode display slot.
 */
type FmaModeSlotActiveData = {
    /** The active mode. */
    active: string;
    /** The armed mode from which the active mode transitioned. */
    armedTransition: string | undefined;
    /** The secondary armed mode from which the active mode transitioned. */
    secondaryArmedTransition: string | undefined;
    /** The failed mode that caused the transition to the current active mode. */
    failed: string | undefined;
};
/**
 * Component props for FmaModeSlot.
 */
interface FmaModeSlotProps {
    /** The slot's current active mode. */
    active: Subscribable<FmaModeSlotActiveData>;
    /** CSS class(es) to apply to the slot's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * An FMA mode display slot.
 */
declare class FmaModeSlot extends DisplayComponent<FmaModeSlotProps> {
    private static readonly ALERT_DURATION;
    private static readonly FAILED_DURATION;
    private readonly rootCssClass;
    private readonly activeModeText;
    private readonly alertTimer;
    private cssClassSub?;
    private activeModeSub?;
    private isFailedSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Responds to changes in this slot's active mode.
     * @param active The active mode.
     * @param armedTransition The armed mode from which the active mode transitioned.
     * @param secondaryArmedTransition The secondary armed mode from which the active mode transitioned.
     * @param failed The failed mode that caused the transition to the current active mode.
     */
    private onActiveModeChanged;
    /**
     * Checks whether the active mode transitioned from a combined dual vertical armed mode.
     * @param active The active mode.
     * @param secondaryArmedTransition The secondary armed mode from which the active mode transitioned.
     * @returns Whether the active mode transitioned from a combined dual vertical armed mode.
     */
    private isDualVerticalTransition;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A color gradient stop for {@link ArtificialHorizon}. The first member (`distance`) defines the distance of the
 * stop from the horizon line, in pixels. The second member (`color`) defines the color of the stop. The optional
 * third member (`step`) defines the distance, in pixels, between adjacent interpolated colors used to draw the
 * gradient. The value of `step` must be at least `2` and defaults to `4`.
 */
type ArtificialHorizonColorStop = [distance: number, color: string, step?: number];
/**
 * A color gradient stop in the artificial horizon sky.
 * @deprecated
 */
type ArtificialHorizonSkyColor = ArtificialHorizonColorStop;
/**
 * Options for {@link ArtificialHorizon}.
 */
interface ArtificialHorizonOptions {
    /** The color of the ground. Overridden by `groundColors`. */
    groundColor?: string;
    /**
     * The color stops of the ground gradient.
     */
    groundColors?: ArtificialHorizonColorStop[];
    /** The color of the sky. Overridden by `skyColors`. */
    skyColor?: string;
    /**
     * The color stops of the sky gradient.
     */
    skyColors?: ArtificialHorizonColorStop[];
}
/**
 * Component props for ArtificialHorizon.
 */
interface ArtificalHorizonProps extends ComponentProps {
    /** Whether to show the artificial horizon. */
    show: Subscribable<boolean>;
    /** Options for the artificial horizon. */
    options: Readonly<ArtificialHorizonOptions>;
}
/**
 * A PFD artificial horizon. Renders sky and ground boxes.
 */
declare class ArtificialHorizon extends HorizonSharedCanvasSubLayer<ArtificalHorizonProps> {
    private static readonly UPDATE_FLAGS;
    private readonly vec2Cache;
    private readonly bgTranslation;
    private bgRotation;
    private readonly windowTransform;
    private readonly groundColors;
    private readonly skyColors;
    private needUpdate;
    private showSub?;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /** @inheritdoc */
    shouldInvalidate(): boolean;
    /** @inheritdoc */
    onUpdated(): void;
    /**
     * Draws the horizon rects.
     * @param context The canvas rendering context to which to draw.
     * @param projection The horizon projection.
     */
    private drawHorizonRects;
    /**
     * Draws a solid rectangle.
     * @param context The canvas rendering context to which to draw.
     * @param color The color of the rectangle.
     * @param x1 The minimum x-coordinate to which to extend the rectangle.
     * @param x2 The maximum x-coordinate to which to extend the rectangle.
     * @param y The y-coordinate to which to extend the rectangle.
     */
    private drawSolidRect;
    /**
     * Draws a gradient rectangle.
     * @param context The canvas rendering context to which to draw.
     * @param stops The interpolated color stops of the rectangle gradient.
     * @param x1 The minimum x-coordinate to which to extend the rectangle.
     * @param x2 The maximum x-coordinate to which to extend the rectangle.
     * @param y The y-coordinate to which to extend the rectangle.
     */
    private drawGradientRect;
    /** @inheritdoc */
    destroy(): void;
    /**
     * Creates an array of interpolated color gradient stops, ordered by increasing distance from the horizon line.
     * @param colors The gradient's defined color stops.
     * @returns An array of interpolated color gradient stops for the specified defined stops.
     */
    private static createColorGradient;
}

/**
 * An attitude indicator aircraft symbol color option.
 */
type AttitudeAircraftSymbolColor = 'yellow' | 'white';
/**
 * Aircraft symbol formats.
 */
declare enum AttitudeAircraftSymbolFormat {
    SingleCue = "SingleCue",
    DualCue = "DualCue"
}
/**
 * Component props for AttitudeAircraftSymbol.
 */
interface AttitudeAircraftSymbolProps extends HorizonLayerProps {
    /** Whether to show the aircraft symbol. */
    show: Subscribable<boolean>;
    /** The symbol format to display. */
    format: AttitudeAircraftSymbolFormat | Subscribable<AttitudeAircraftSymbolFormat>;
    /** The color of the aircraft symbol. */
    color: AttitudeAircraftSymbolColor;
}
/**
 * An aircraft symbol for the PFD attitude indicator.
 */
declare class AttitudeAircraftSymbol extends HorizonLayer<AttitudeAircraftSymbolProps> {
    private readonly style;
    private readonly singleCueDisplay;
    private readonly dualCueDisplay;
    private showSub?;
    private formatSub?;
    /** @inheritdoc */
    protected onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /**
     * Updates the position of this symbol.
     */
    private updatePosition;
    /** @inheritdoc */
    onDetached(): void;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Renders the single-cue aircraft symbol.
     * @returns The single-cue aircraft symbol, as a VNode.
     */
    private renderSingleCue;
    /**
     * Renders the dual-cue aircraft symbol.
     * @returns The dual-cue aircraft symbol, as a VNode.
     */
    private renderDualCue;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for FlightDirectorDualCue.
 */
interface FlightDirectorDualCueProps extends HorizonLayerProps {
    /** Whether to show the flight director. */
    show: Subscribable<boolean>;
    /** The flight director commanded pitch, in degrees. Positive values indicated upward pitch. */
    fdPitch: Subscribable<number>;
    /** The flight director commanded bank, in degrees. Positive values indicate rightward bank. */
    fdBank: Subscribable<number>;
    /**
     * The scaling factor to apply to the pitch command bar's translation. A factor of 1 causes the bar to translate
     * approximately in line with the angular resolution of the horizon projection. Larger factors will result in larger
     * translations for the same pitch error. Defaults to `1`.
     */
    pitchErrorFactor?: number | Subscribable<number>;
    /**
     * The scaling factor to apply to the bank command bar's translation. A factor of 1 causes the bar to translate
     * approximately in line with the angular resolution of the horizon projection. Larger factors will result in larger
     * translations for the same bank error. Defaults to `1`.
     */
    bankErrorFactor?: number | Subscribable<number>;
    /**
     * The translation constant to use for the bank command bar, in pixels per degree of bank error. If this value is
     * defined, it will override `bankErrorFactor`.
     */
    bankErrorConstant?: number | Subscribable<number>;
    /**
     * The bounds within which the flight director remains conformal, as `[left, top, right, bottom]` in pixels relative
     * to the center of the projection.
     */
    conformalBounds: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
}
/**
 * A PFD dual-cue flight director.
 */
declare class FlightDirectorDualCue extends HorizonLayer<FlightDirectorDualCueProps> {
    private readonly pitchErrorFactor;
    private readonly bankErrorFactor;
    private readonly bankErrorConstant;
    private readonly conformalBounds;
    private readonly display;
    private readonly pitchTransform;
    private readonly bankTransform;
    private needUpdate;
    private readonly pauseable;
    private showSub?;
    /** @inheritdoc */
    protected onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onProjectionChanged(): void;
    /** @inheritdoc */
    onUpdated(): void;
    /** @inheritdoc */
    onDetached(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Flight director formats.
 */
declare enum FlightDirectorFormat {
    SingleCue = "SingleCue",
    DualCue = "DualCue"
}

/**
 * Component props for FlightDirectorSingleCue.
 */
interface FlightDirectorSingleCueProps extends HorizonLayerProps {
    /** Whether to show the flight director. */
    show: Subscribable<boolean>;
    /** The flight director commanded pitch, in degrees. Positive values indicated upward pitch. */
    fdPitch: Subscribable<number>;
    /** The flight director commanded bank, in degrees. Positive values indicate rightward bank. */
    fdBank: Subscribable<number>;
    /**
     * The vertical bounds within which the flight director remains conformal, as `[top, bottom]` in pixels relative
     * to the center of the projection.
     */
    conformalBounds: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The maximum bank error at which the flight director's bank remains conformal, in degrees. */
    conformalBankLimit: number | Subscribable<number>;
}
/**
 * A PFD single-cue flight director.
 */
declare class FlightDirectorSingleCue extends HorizonLayer<FlightDirectorSingleCueProps> {
    private readonly conformalBounds;
    private readonly conformalBankLimit;
    private readonly display;
    private readonly transform;
    private needUpdate;
    private readonly pauseable;
    private showSub?;
    /** @inheritdoc */
    protected onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onProjectionChanged(): void;
    /** @inheritdoc */
    onUpdated(): void;
    /** @inheritdoc */
    onDetached(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A data provider for a flight director.
 */
interface FlightDirectorDataProvider {
    /** Whether the flight director is active. */
    readonly isFdActive: Subscribable<boolean>;
    /** The pitch commanded by the flight director, in degrees. Positive values indicated upward pitch. */
    readonly fdPitch: Subscribable<number>;
    /** The bank commanded by the flight director, in degrees. Positive values indicate rightward bank. */
    readonly fdBank: Subscribable<number>;
}
/**
 * A default implementation of {@link FlightDirectorDataProvider} which smooths pitch and bank commands.
 */
declare class DefaultFlightDirectorDataProvider implements FlightDirectorDataProvider {
    private readonly bus;
    private readonly _isFdActive;
    /** @inheritdoc */
    readonly isFdActive: Subscribable<boolean>;
    private readonly _fdPitch;
    /** @inheritdoc */
    readonly fdPitch: Subscribable<number>;
    private readonly _fdBank;
    /** @inheritdoc */
    readonly fdBank: Subscribable<number>;
    private readonly isFdActiveSource;
    private readonly fdPitchSource;
    private readonly fdBankSource;
    private readonly simRate;
    private readonly pitchSmoother;
    private readonly bankSmoother;
    private isFdNotInstalled;
    private lastUpdateTime;
    private readonly pauseable;
    private fdNotInstalledSub?;
    private isInit;
    private isAlive;
    private isPaused;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param pitchSmoothingTau The time constant used for smoothing pitch commands, in milliseconds.
     * @param bankSmoothingTau The time constant used for smoothing bank commands, in milliseconds.
     */
    constructor(bus: EventBus, pitchSmoothingTau: number, bankSmoothingTau: number);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider has been destroyed.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider has been destroyed.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider has been destroyed.
     */
    pause(): void;
    /**
     * Updates this data provider.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time: number): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Component props for FlightPathMarker.
 */
interface FlightPathMarkerProps extends HorizonLayerProps {
    /** The event bus. */
    bus: EventBus;
    /** Whether to show the flight path marker. */
    show: Subscribable<boolean>;
    /** The minimum ground speed, in knots, required for the flight path marker to be displayed. Defaults to 30 knots. */
    minGroundSpeed?: number;
    /** The lookahead time of the flight path marker, in seconds. Defaults to 60 seconds. */
    lookahead?: number;
    /** The smoothing time constant for ground track and ground speed, in milliseconds. Defaults to `500 / ln(2)`. */
    smoothingTimeConstant?: number;
}
/**
 * A PFD synthetic vision technology (SVT) flight path marker. Displays an icon depicting the estimated position of the
 * airplane projected forward in time given the airplane's current horizontal and vertical speed and track.
 */
declare class FlightPathMarker extends HorizonLayer<FlightPathMarkerProps> {
    private static readonly DEFAULT_MIN_GS;
    private static readonly DEFAULT_LOOKAHEAD;
    private static readonly DEFAULT_SMOOTHING_TIME_CONSTANT;
    private static readonly vec2Cache;
    private readonly style;
    private readonly minGs;
    private readonly lookahead;
    private readonly smoothingTimeConstant;
    private readonly gs;
    private readonly track;
    private readonly vs;
    private readonly isFpmVisible;
    private readonly groundTrackSmoother;
    private readonly gsSmoother;
    private readonly projectedPosition;
    private needUpdate;
    /** @inheritdoc */
    protected onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Smooths a ground track value.
     * @param track A ground track value.
     * @param dt The elapsed time, in milliseconds, since the last smoothed value was calculated.
     * @returns A smoothed ground track value.
     */
    private smoothGroundTrack;
    /** @inheritdoc */
    onDetached(): void;
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Synthetic vision technology (SVT) user settings.
 */
type SynVisUserSettingTypes = {
    /** Whether SVT is enabled. */
    svtEnabled: boolean;
    /** Whether to show the flight path marker when SVT is disabled. */
    svtDisabledFpmShow: boolean;
    /** Whether to show SVT horizon heading labels. */
    svtHeadingLabelShow: boolean;
    /** Whether to show SVT airport signs. */
    svtAirportSignShow: boolean;
    /** Whether to show SVT pathways. */
    svtPathwaysShow: boolean;
    /** Whether to show SVT traffic. */
    svtTrafficShow: boolean;
};

/**
 * A definition of an area in which certain horizon display elements should be occluded.
 */
interface HorizonOcclusionArea {
    /**
     * Paths this occlusion area to a canvas rendering context.
     * @param context A canvas rendering context.
     */
    path(context: CanvasRenderingContext2D): void;
}

/**
 * Options for {@link HorizonLine}.
 */
type HorizonLineOptions = {
    /** The width of the horizon line stroke, in pixels. Defaults to 2 pixels. */
    strokeWidth?: number;
    /** The color of the horizon line stroke. Defaults to `'white'`. */
    strokeColor?: string;
    /** The width of the horizon line outline, in pixels. Defaults to 1 pixel. */
    outlineWidth?: number;
    /** The color of the horizon line outline. Defaults to `'black'`. */
    outlineColor?: string;
    /** The size of the heading reference pointer. as `[width, height]` in pixels. */
    headingPointerSize: ReadonlyFloat64Array;
    /** The length of a heading tick, in pixels, when the tick is projected to the center of the projection. */
    headingTickLength: number;
    /** The width of each heading tick, in pixels. Defaults to 1 pixel. */
    headingTickWidth?: number;
    /** The color of each heading tick. Defaults to `'white'`. */
    headingTickColor?: string;
    /** The name of the heading label font. */
    font: string;
    /** The size of the heading label font, in pixels, when the label is projected to the center of the projection. */
    fontSize: number;
    /** The color of the heading label font. Defaults to `'white'`. */
    fontColor?: string;
    /** The width of the heading label font outline, in pixels. Defaults to 1 pixel. */
    fontOutlineWidth?: number;
    /** The color of the heading label font outline. Defaults to `'black'`. */
    fontOutlineColor?: string;
    /**
     * The offset of the heading label from its tick, in pixels. Positive offsets shift the label away from the tick.
     * Defaults to 0 pixels.
     */
    labelOffset?: number;
};
/**
 * Component props for HorizonLine.
 */
interface HorizonLineProps extends ComponentProps {
    /** Whether to show the horizon line. */
    show: Subscribable<boolean>;
    /** Whether to show heading labels. */
    showHeadingLabels: boolean | Subscribable<boolean>;
    /** Whether to approximate pitch scale based on FOV instead of performing a full projection. */
    approximate: boolean | Subscribable<boolean>;
    /** Whether to show magnetic heading. */
    useMagneticHeading: Subscribable<boolean>;
    /** The occlusion areas to apply to the horizon heading ticks and labels. */
    occlusions: SubscribableArray<HorizonOcclusionArea>;
    /** Options for the horizon line. */
    options: Readonly<HorizonLineOptions>;
}
/**
 * A PFD horizon line with optional heading reference pointer, optional heading tick marks every 10 degrees, and
 * optional heading labels every 30 degrees.
 */
declare class HorizonLine extends HorizonSharedCanvasSubLayer<HorizonLineProps> {
    private static readonly TICK_INCREMENT;
    private static readonly TICK_COUNT;
    private static readonly LABEL_FACTOR;
    private static readonly BOUNDS_BUFFER;
    private static readonly DEFAULT_LINE_STROKE_WIDTH;
    private static readonly DEFAULT_LINE_STROKE_COLOR;
    private static readonly DEFAULT_LINE_OUTLINE_WIDTH;
    private static readonly DEFAULT_LINE_OUTLINE_COLOR;
    private static readonly DEFAULT_TICK_STROKE_WIDTH;
    private static readonly DEFAULT_TICK_STROKE_COLOR;
    private static readonly DEFAULT_FONT_COLOR;
    private static readonly DEFAULT_FONT_OUTLINE_WIDTH;
    private static readonly DEFAULT_FONT_OUTLINE_COLOR;
    private static readonly vec2Cache;
    private readonly lineStrokeWidth;
    private readonly lineStrokeColor;
    private readonly lineOutlineWidth;
    private readonly lineOutlineColor;
    private readonly tickStrokeWidth;
    private readonly tickStrokeColor;
    private readonly font;
    private readonly fontColor;
    private readonly fontOutlineWidth;
    private readonly fontOutlineColor;
    private readonly labelOffset;
    private readonly approximate;
    private readonly showHeadingLabels;
    private readonly bounds;
    private readonly clipPathStream;
    private readonly transformPathStream;
    private readonly nodes;
    private readonly approximateTransform;
    private needUpdate;
    private readonly subscriptions;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /**
     * Updates this layer's drawing bounds.
     */
    private updateBounds;
    /** @inheritdoc */
    shouldInvalidate(): boolean;
    /** @inheritdoc */
    onUpdated(): void;
    /**
     * Applies a clip path based on this layer's occlusion areas. If there are no occlusion areas, then a clip path will
     * not be applied.
     * @param context The canvas rendering context to which to apply the clip path.
     * @param occlusions The occlusion areas to apply.
     * @returns Whether a clip path was applied.
     */
    private applyOcclusionClipPath;
    /**
     * Recalculates the positions of this horizon line's nodes using projection.
     * @param projection The horizon projection.
     * @param headingOffset The offset, in degrees, of the heading ticks with respect to true heading.
     */
    private projectNodes;
    /**
     * Recalculates the positions of this horizon line's nodes using an approximated pitch scale based on FOV.
     * @param projection The horizon projection.
     * @param headingOffset The offset, in degrees, of the heading ticks with respect to true heading.
     */
    private approximateNodes;
    /**
     * Draws the horizon line on a canvas.
     * @param context The canvas rendering context to which to draw the line.
     */
    private drawLine;
    /**
     * Draws this horizon line's heading reference pointer.
     * @param context The canvas rendering context to which to draw the pointer.
     * @param projection The horizon projection.
     */
    private drawHeadingPointer;
    /**
     * Draws this horizon line's heading ticks on a canvas.
     * @param context The canvas rendering context to which to draw the ticks.
     * @param projection The horizon projection.
     */
    private drawTicks;
    /**
     * Draws a heading tick on a canvas.
     * @param context The canvas rendering context to which to draw the tick.
     * @param projection The horizon projection.
     * @param startProjected The projected position of the start of the tick.
     * @param endProjected The projected position of the end of the tick.
     * @param tickStrokeWidth The stroke width of the tick, in pixels.
     * @param labelText The text to render for the tick's heading label, or `undefined` if there is no label.
     * @param fontSize The virtual font size of the tick's heading label, or `undefined` if there is no label.
     * @param labelOffset The virtual offset of the tick's heading label, or `undefined` if there is no label.
     */
    private drawTick;
    /**
     * Strokes a path on a canvas.
     * @param context The canvas rendering context with which to stroke the path.
     * @param strokeWidth The width of the stroke.
     * @param strokeStyle The style of the stroke.
     * @param outlineWidth The outline width of the stroke. Defaults to `0`.
     * @param outlineStyle The outline style of the stroke. Required to draw an outline.
     */
    private strokePath;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Styling options for the pitch ladder.
 */
type PitchLadderStyles = {
    /** The increment, in degrees, between major pitch lines. */
    majorLineIncrement: number;
    /** The number of medium pitch lines for each major pitch line. */
    mediumLineFactor: number;
    /** The number of minor pitch lines for each medium pitch line. */
    minorLineFactor: number;
    /** The maximum pitch at which to draw minor pitch lines. */
    minorLineMaxPitch: number;
    /** The maximum pitch at which to draw medium pitch lines. */
    mediumLineMaxPitch: number;
    /** The length of minor pitch lines. */
    minorLineLength: number;
    /** The length of medium pitch lines. */
    mediumLineLength: number;
    /** The length of major pitch lines. */
    majorLineLength: number;
    /** Whether to show number labels for minor pitch lines. */
    minorLineShowNumber: boolean;
    /** Whether to show number labels for medium pitch lines. */
    mediumLineShowNumber: boolean;
    /** Whether to show number labels for major pitch lines. */
    majorLineShowNumber: boolean;
    /** The horizontal margin of each number label from its pitch line, in pixels. */
    numberMargin: number;
    /** The vertical offset of each number label, in pixels. */
    numberOffsetY: number;
    /** The minimum positive pitch value at which to display warning chevrons. */
    chevronThresholdPositive: number;
    /** The maximum negative pitch value at which to display warning chevrons. */
    chevronThresholdNegative: number;
};
/**
 * Options for {@link PitchLadder}.
 */
type PitchLadderOptions = {
    /** Styling options to apply when synthetic vision is disabled. */
    svtDisabledStyles: PitchLadderStyles;
    /** Styling options to apply when synthetic vision is enabled. */
    svtEnabledStyles: PitchLadderStyles;
};
/**
 * Component props for PitchLadder.
 */
interface PitchLadderProps extends HorizonLayerProps {
    /** Whether to show the pitch ladder. */
    show: Subscribable<boolean>;
    /** Whether synthetic vision is enabled. */
    isSVTEnabled: Subscribable<boolean>;
    /**
     * The clipping bounds of the pitch ladder, as `[left, top, right, bottom]` in pixels relative to the center of the
     * projection.
     */
    clipBounds: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** Options for the pitch ladder. */
    options: PitchLadderOptions;
}
/**
 * A PFD pitch ladder. Displays major, medium, and minor pitch lines, each with optional pitch angle labels. Also
 * displays unusual attitude chevrons between major pitch lines above threshold positive and negative pitch angles.
 * Does not display a zero-pitch line.
 */
declare class PitchLadder extends HorizonLayer<PitchLadderProps> {
    private readonly svgRef;
    private readonly rootStyle;
    private readonly transform;
    private readonly clipBounds;
    private pitchResolution;
    private needUpdateClip;
    private needRebuildLadder;
    private needReposition;
    private showSub?;
    private clipBoundsSub?;
    /** @inheritdoc */
    protected onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(): void;
    /**
     * Updates this ladder's clipping boundaries.
     */
    private updateClip;
    /**
     * Repositions this ladder based on the current pitch and bank.
     */
    private repositionLadder;
    /**
     * Rebuilds this ladder.
     */
    private rebuildLadder;
    /**
     * Renders a warning chevron.
     * @param centerY The y coordinate of the center of the chevron, in pixels.
     * @param height The height of the chevron, in pixels.
     * @param width The width of the chevron, in pixels.
     * @param legWidth The width of each leg of the chevron, in pixels.
     * @param direction The direction in which the chevron is pointed: `1` for the positive y direction, `-1` for the
     * negative y direction.
     * @returns A warning chevron, as a VNode.
     */
    private renderChevron;
    /** @inheritdoc */
    onDetached(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Parameters describing a roll indicator scale.
 */
type RollIndicatorScaleParameters = {
    /** The radius of the roll scale, in pixels. */
    radius: number;
    /** Whether the roll arc is rendered. */
    showArc: boolean;
    /**
     * Whether the roll scale is rendered with a ground pointer or a sky pointer. With a ground pointer, the roll scale
     * rotates as the airplane banks to keep the zero-roll reference pointer pointed toward the ground while the roll
     * pointer remains fixed. With a sky pointer, the roll pointer rotates as the airplane banks to keep itself pointed
     * toward the sky while the roll scale remains fixed.
     */
    pointerStyle: 'ground' | 'sky';
    /** The length of the major roll scale ticks, in pixels. */
    majorTickLength: number;
    /** The length of the minor roll scale ticks, in pixels. */
    minorTickLength: number;
    /** The size of the zero-roll reference pointer, as `[width, height]` in pixels. */
    referencePointerSize: ReadonlyFloat64Array;
    /**
     * The offset of the tip of the zero-roll reference pointer from the roll scale, in pixels. Positive values displace
     * the pointer away from the center of the circle circumscribed by the roll scale.
     */
    referencePointerOffset: number;
};
/**
 * A component that is displayed on a PFD roll indicator scale.
 */
interface RollIndicatorScaleComponent extends DisplayComponent<any> {
    /** Flags this object as a `RollIndicatorScaleComponent`. */
    readonly isRollIndicatorScaleComponent: true;
    /**
     * This method is called when this component's parent roll indicator is attached to its parent horizon component.
     */
    onScaleAttached(): void;
    /**
     * This method is called when this component's parent roll indicator's visibility changes. This method is guaranteed
     * to be called only after `onScaleAttached()` is called. The parent roll indicator is always initially considered to
     * be visible (i.e. if this method is never called, then it is safe to assume the roll indicator is always visible).
     * @param isVisible Whether the parent roll indicator is now visible.
     */
    onScaleVisibilityChanged(isVisible: boolean): void;
    /**
     * This method is called when this component's horizon projection changes.
     * @param projection This component's horizon projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /**
     * This method is called once every update cycle.
     * @param time The current time, as a Javascript timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time: number, elapsed: number): void;
    /**
     * This method is called when this component's parent roll indicator is detached from its parent horizon component.
     */
    onScaleDetached(): void;
}

/**
 * Options for {@link RollIndicator}.
 */
type RollIndicatorOptions = {
    /** The radius of the roll scale, in pixels. */
    radius: number;
    /** Whether to render the roll arc. */
    showArc: boolean;
    /**
     * Whether to render the indicator with a ground pointer or a sky pointer. With a ground pointer, the roll scale
     * rotates as the airplane banks to keep the zero-roll reference pointer pointed toward the ground while the roll
     * pointer remains fixed. With a sky pointer, the roll pointer rotates as the airplane banks to keep itself pointed
     * toward the sky while the roll scale remains fixed.
     */
    pointerStyle: 'ground' | 'sky';
    /** The bank angle limit, in degrees, in Low Bank Mode. If not defined, the low-bank arc will not be displayed. */
    lowBankAngle?: number;
    /** The length of the major roll scale ticks, in pixels. */
    majorTickLength: number;
    /** The length of the minor roll scale ticks, in pixels. */
    minorTickLength: number;
    /** The size of the zero-roll reference pointer, as `[width, height]` in pixels. */
    referencePointerSize: ReadonlyFloat64Array;
    /**
     * The offset of the tip of the zero-roll reference pointer from the roll scale, in pixels. Positive values displace
     * the pointer away from the center of the circle circumscribed by the roll scale.
     */
    referencePointerOffset: number;
    /** The size of the roll pointer, as `[width, height]` in pixels. */
    rollPointerSize: ReadonlyFloat64Array;
    /**
     * The offset of the tip of the roll pointer from the roll scale, in pixels. Positive values displace the pointer
     * toward the center of the circle circumscribed by the roll scale.
     */
    rollPointerOffset: number;
    /** The offset of the slip/skid indicator from the roll pointer, in pixels. Values less than 0 will be clamped to 0. */
    slipSkidIndicatorOffset: number;
    /** The height of the slip/skid indicator, in pixels. */
    slipSkidIndicatorHeight: number;
    /** The amount to translate the slip/skid indicator, in pixels, at full deflection. */
    slipSkidIndicatorTranslateScale: number;
};
/**
 * A function that renders a roll scale component for a {@link RollIndicator}. The rendered component should be an
 * instance of {@link RollIndicatorScaleComponent}.
 * @param projection The component's horizon projection.
 * @param scaleParams Parameters describing the component's parent roll scale.
 * @returns A roll scale component, as a VNode.
 */
type RollIndicatorScaleComponentFactory = (projection: HorizonProjection, scaleParams: Readonly<RollIndicatorScaleParameters>) => VNode;
/**
 * Component props for {@link RollIndicator}.
 */
interface RollIndicatorProps extends HorizonLayerProps {
    /** Whether to show the indicator. */
    show: Subscribable<boolean>;
    /** Whether to show the slip-skid indicator. */
    showSlipSkid: Subscribable<boolean>;
    /** Whether to show the low-bank arc. */
    showLowBankArc: Subscribable<boolean>;
    /** The turn coordinator ball position, normalized to the range `[-1, 1]`. */
    turnCoordinatorBall: Subscribable<number>;
    /** Options for the roll indicator. */
    options: Readonly<RollIndicatorOptions>;
    /**
     * Factories to create roll scale components to render with the indicator.
     */
    scaleComponents?: Iterable<RollIndicatorScaleComponentFactory>;
}
/**
 * A PFD roll indicator. Displays a roll scale, roll pointer, and slip-skid indicator.
 */
declare class RollIndicator extends HorizonLayer<RollIndicatorProps> {
    private readonly rootStyle;
    private readonly lowBankArcDisplay;
    private readonly slipSkidDisplay;
    private readonly rollTransform;
    private readonly slipSkidTransform;
    private readonly scaleComponents;
    private areScaleComponentsAttached;
    private needUpdateRoll;
    private needUpdateSlipSkid;
    private showSub?;
    private turnCoordinatorBallSub?;
    /** @inheritDoc */
    protected onVisibilityChanged(isVisible: boolean): void;
    /** @inheritDoc */
    onAttached(): void;
    /** @inheritDoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /**
     * Updates this indicator's root container position.
     */
    private updateRootPosition;
    /** @inheritDoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates the rotation of the indicator.
     */
    private updateRoll;
    /**
     * Updates the position of the slip/skid indicator.
     */
    private updateSlipSkid;
    /** @inheritDoc */
    onDetached(): void;
    /** @inheritDoc */
    render(): VNode;
    /**
     * Renders the bank scale, which includes the bank reference pointer and the scale ticks.
     * @returns The bank scale, as a VNode.
     * @throws Error if a scale component factory creates a VNode that is not an instance of
     * `RollIndicatorScaleComponent`.
     */
    private renderScale;
    /**
     * Renders the roll pointer and slip/skid indicator.
     * @returns The roll pointer and slip/skid indicator, as a VNode.
     */
    private renderPointerContainer;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * Component props for TcasRaPitchCueLayer.
 */
interface TcasRaPitchCueLayerProps extends HorizonLayerProps {
    /** Whether to show the layer. */
    show: Subscribable<boolean>;
    /** A provider of TCAS-II resolution advisory vertical speed command data. */
    dataProvider: TcasRaCommandDataProvider;
    /** The airplane's current vertical speed, in feet per minute. */
    verticalSpeed: Subscribable<number>;
    /** The airplane's current true airspeed, in degrees. */
    tas: Subscribable<number>;
    /** The current simulation rate factor. */
    simRate: Subscribable<number>;
    /**
     * The clipping bounds of the layer, as `[left, top, right, bottom]` in pixels relative to the center of the
     * projection.
     */
    clipBounds: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The bounds defining the ovoid area in which the no-fly cues remain conformal, as `[left, top, right, bottom]` in
     * pixels relative to the center of the projection.
     */
    conformalBounds: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The smoothing time constant, in milliseconds, to use for smoothing true airspeed values when calculating the pitch
     * attitude required to achieve a given vertical speed. Defaults to `2000 / Math.LN2`.
     */
    tasSmoothingTau?: number;
    /**
     * The smoothing time constant, in milliseconds, to use for smoothing pitch values when calculating the pitch
     * attitude required to achieve a given vertical speed. Defaults to `2000 / Math.LN2`.
     */
    pitchSmoothingTau?: number;
}
/**
 * A PFD TCAS-II resolution advisory pitch cue layer.
 */
declare class TcasRaPitchCueLayer extends HorizonLayer<TcasRaPitchCueLayerProps> {
    private readonly clipBounds;
    private readonly conformalBounds;
    private readonly rootStyle;
    private readonly clipCenterX;
    private readonly clipCenterY;
    private readonly noflyAboveDisplay;
    private readonly noflyAboveTransform;
    private readonly noflyBelowDisplay;
    private readonly noflyBelowTransform;
    private readonly flytoDisplay;
    private readonly flytoHeight;
    private readonly flyToTransform;
    private readonly tasSmoother;
    private readonly pitchSmoother;
    private readonly smoothedTas;
    private readonly smoothedPitch;
    private needUpdateClipBounds;
    private needUpdateNoflyAbove;
    private needUpdateNoflyBelow;
    private needUpdateFlyto;
    private readonly pauseable;
    private showSub?;
    private clipBoundsSub?;
    /** @inheritdoc */
    protected onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Checks whether any of this layer's cues are visible, and if so, marks them to be updated.
     */
    private checkNeedUpdateCues;
    /** @inheritdoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /** @inheritdoc */
    onSleep(): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this layer's smoothed true airspeed and pitch values.
     * @param elapsed The elapsed time since the last update, in milliseconds.
     */
    private updateSmoothedValues;
    /**
     * Updates this layer's clipping bounds.
     */
    private updateClipBounds;
    /**
     * Updates one of this layer's no-fly pitch cues.
     * @param direction The direction of the no-fly cue: +1 for above and -1 for below.
     * @param vsLimit The vertical speed limit, in feet per minute, commanded by the currently active resolution
     * advisory, or `null` if there is no such limit.
     * @param display The display style of the no-fly cue.
     * @param transform The CSS transform of the no-fly cue.
     */
    private updateNoflyCue;
    /**
     * Updates this layer's fly-to pitch cue.
     */
    private updateFlytoCue;
    /** @inheritdoc */
    onDetached(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Options for the pitch ladder.
 */
type HorizonPitchLadderOptions = Pick<PitchLadderProps, 'clipBounds' | 'options'>;
/**
 * Options for the symbolic aircraft.
 */
type AircraftSymbolOptions = Pick<AttitudeAircraftSymbolProps, 'color'>;
/**
 * Options for the flight director.
 */
type FlightDirectorOptions = {
    /** The time constant used to smooth flight director pitch commands, in milliseconds. */
    pitchSmoothingTau?: number;
    /** The time constant used to smooth flight director bank commands, in milliseconds. */
    bankSmoothingTau?: number;
};
/**
 * Options for the single-cue flight director.
 */
type FlightDirectorSingleCueOptions = Pick<FlightDirectorSingleCueProps, 'conformalBounds' | 'conformalBankLimit'>;
/**
 * Options for the dual-cue flight director.
 */
type FlightDirectorDualCueOptions = Pick<FlightDirectorDualCueProps, 'conformalBounds' | 'pitchErrorFactor' | 'bankErrorFactor' | 'bankErrorConstant'>;
/**
 * Options for the flight path marker.
 */
type FlightPathMarkerOptions = Pick<FlightPathMarkerProps, 'minGroundSpeed' | 'lookahead'>;
/**
 * Options for the roll limit indicators.
 */
type HorizonRollLimitIndicatorsOptions = {
    /**
     * The roll angle magnitude at which to place the left limit indicator, in degrees. A non-finite value or `NaN` will
     * cause the indicator to not be displayed.
     */
    leftRollLimit: number | Accessible<number>;
    /**
     * The roll angle magnitude at which to place the right limit indicator, in degrees. A non-finite value or `NaN` will
     * cause the indicator to not be displayed.
     */
    rightRollLimit: number | Accessible<number>;
    /**
     * The duration of the indicators' easing animation, in milliseconds. The easing animation is used to smoothly
     * transition the indicators from one roll angle to another when the roll limits change. Defaults to `1000`.
     */
    easeDuration?: number;
};
/**
 * Options for the pitch limit indicator.
 */
type HorizonPitchLimitIndicatorOptions = {
    /**
     * The pitch angle, in degrees, at which to position the indicator. A non-finite value or `NaN` will cause the
     * indicator to not be displayed.
     */
    pitchLimit?: number | Accessible<number>;
    /**
     * The angle of attack value, in degrees, at which to position the indicator. A non-finite value or `NaN` will cause
     * the indicator to not be displayed. Ignored if `pitchLimit` is defined.
     */
    aoaLimit?: number | Accessible<number>;
    /**
     * The normalized angle of attack value, at which to position the indicator. A non-finite value or `NaN` will cause
     * the indicator to not be displayed. Ignored if `pitchLimit` or `aoaLimit` is defined.
     */
    normAoaLimit?: number | Accessible<number>;
    /**
     * The time constant, in milliseconds, to apply to angle of attack smoothing when converting angle of attack limits
     * to pitch limits. A value less than or equal to zero is equivalent to no smoothing. Ignored if `pitchLimit` is
     * defined. Defaults to `0`.
     */
    aoaSmoothingTau?: number;
    /**
     * The offset of the airplane's pitch from the indicated pitch limit, in degrees, at which to show the indicator. For
     * example, a value of `-5` will cause the indicator to be shown once the airplane's pitch is greater than or equal
     * to the pitch limit minus 5 degrees.
     */
    showPitchOffsetThreshold: number | Accessible<number>;
    /**
     * The offset of the airplane's pitch from the indicated pitch limit, in degrees, at which to hide the indicator. For
     * example, a value of `-5` will cause the indicator to be hidden once the airplane's pitch is less than the pitch
     * limit minus 5 degrees. This value will be clamped to be less than or equal to `showPitchOffsetThreshold`.
     */
    hidePitchOffsetThreshold: number | Accessible<number>;
};
/**
 * Options for the TCAS resolution advisory pitch cue layer.
 */
type TcasRaPitchCueLayerOptions = Pick<TcasRaPitchCueLayerProps, 'clipBounds' | 'conformalBounds' | 'tasSmoothingTau' | 'pitchSmoothingTau'>;
/**
 * Component props for HorizonDisplay.
 */
interface HorizonDisplayProps extends ComponentProps {
    /** Event bus. */
    bus: EventBus;
    /** The index of the ADC that is the source of the horizon display's data. */
    adcIndex: number | Subscribable<number>;
    /** The index of the AHRS that is the source of the horizon display's data. */
    ahrsIndex: number | Subscribable<number>;
    /** The index of the FMS positioning system that is the source of the horizon display's data. */
    fmsPosIndex: number | Subscribable<number>;
    /**
     * The index of the angle of attack computer system that is the source of the horizon display's data. If not defined,
     * then the display will not have access to angle of attack data.
     */
    aoaIndex?: number | Subscribable<number>;
    /** The size, as `[width, height]` in pixels, of the horizon display. */
    projectedSize: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The projected offset of the center of the projection, as `[x, y]` in pixels. */
    projectedOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The update frequency, in hertz, of the horizon display. */
    updateFreq: number | Subscribable<number>;
    /** The string ID to assign to the synthetic vision layer's bound Bing instance. */
    bingId: string;
    /** The amount of time, in milliseconds, to delay binding the synthetic vision layer's Bing instance. Defaults to 0. */
    bingDelay?: number;
    /** Options for the artificial horizon. */
    artificialHorizonOptions: Readonly<ArtificialHorizonOptions>;
    /** Options for the horizon line. */
    horizonLineOptions: Readonly<HorizonLineOptions>;
    /** Options for the pitch ladder. */
    pitchLadderOptions: HorizonPitchLadderOptions;
    /** Options for the roll indicator. */
    rollIndicatorOptions: RollIndicatorOptions;
    /** Options for the symbolic aircraft. */
    aircraftSymbolOptions: AircraftSymbolOptions;
    /** Options for the flight director. */
    flightDirectorOptions?: Readonly<FlightDirectorOptions>;
    /** Options for the single-cue flight director. Required to display the single-cue director. */
    flightDirectorSingleCueOptions?: Readonly<FlightDirectorSingleCueOptions>;
    /** Options for the dual-cue flight director. Required to display the dual-cue director. */
    flightDirectorDualCueOptions?: Readonly<FlightDirectorDualCueOptions>;
    /** Options for the roll limit indicators. Required to display the roll limit indicators. */
    rollLimitIndicatorsOptions?: Readonly<HorizonRollLimitIndicatorsOptions>;
    /** Options for the pitch limit indicator. Required to display the pitch limit indicator. */
    pitchLimitIndicatorOptions?: Readonly<HorizonPitchLimitIndicatorOptions>;
    /** Options for the TCAS resolution advisory pitch cue layer. Required to display the TCAS RA pitch cue layer. */
    tcasRaPitchCueLayerOptions?: Readonly<TcasRaPitchCueLayerOptions>;
    /**
     * A provider of TCAS-II resolution advisory vertical speed command data. Required to display the TCAS RA pitch cue
     * layer.
     */
    tcasRaCommandDataProvider?: TcasRaCommandDataProvider;
    /**
     * Whether to support advanced SVT features. Advanced SVT features include:
     * * The ability to display horizon heading labels when SVT is disabled.
     * * The ability to display the flight path marker when SVT is disabled.
     */
    supportAdvancedSvt: boolean;
    /** Whether to show magnetic heading information instead of true heading. */
    useMagneticHeading: Subscribable<boolean>;
    /** The flight director format to display. */
    flightDirectorFormat: FlightDirectorFormat | Subscribable<FlightDirectorFormat>;
    /** The set of occlusion areas to apply to certain horizon elements. If not defined, no occlusion will be applied. */
    occlusions?: SubscribableArray<HorizonOcclusionArea>;
    /** A manager for synthetic vision settings. */
    svtSettingManager: UserSettingManager<SynVisUserSettingTypes>;
    /** Whether the display should be decluttered. */
    declutter: Subscribable<boolean>;
    /** Normal field of view, in degrees. Defaults to 55 degrees. */
    normalFov?: number;
    /** Extended field of view, in degrees. Defaults to 110 degrees. */
    extendedFov?: number;
    /** A mutable subscribable to which to write whether SVT is enabled. */
    isSvtEnabled?: MutableSubscribable<any, boolean>;
    /** CSS class(es) to apply to the root of the horizon display. */
    class?: string | SubscribableSet<string>;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin PFD horizon display. Includes an artificial horizon, attitude indicator,
 * aircraft symbol, flight director, and synthetic vision technology (SVT) display.
 */
declare class HorizonDisplay extends DisplayComponent<HorizonDisplayProps> {
    private static readonly BING_FOV;
    private static readonly DEFAULT_NORMAL_FOV;
    private static readonly DEFAULT_EXTENDED_FOV;
    private static readonly SVT_SUPPORTED_FMS_POS_MODES;
    private readonly horizonRef;
    private readonly projectionParams;
    private readonly adcIndex;
    private readonly ahrsIndex;
    private readonly fmsPosIndex;
    private readonly aoaIndex;
    private adcIndexSub?;
    private ahrsIndexSub?;
    private fmsPosIndexSub?;
    private aoaIndexSub?;
    private readonly position;
    private readonly heading;
    private readonly pitch;
    private readonly roll;
    private readonly paramSubjects;
    private headingSub?;
    private pitchSub?;
    private rollSub?;
    private readonly simRate;
    private readonly isOnGround;
    private readonly isAltitudeDataValid;
    private readonly isAirspeedDataValid;
    private readonly isTemperatureDataValid;
    private readonly verticalSpeed;
    private readonly tas;
    private readonly ahrsState;
    private readonly isHeadingDataValid;
    private readonly isAttitudeDataValid;
    private readonly turnCoordinatorBall;
    private readonly fmsPosMode;
    private readonly isAoaDataValid;
    private readonly aoa;
    private readonly zeroLiftAoa;
    private readonly stallAoa;
    private readonly fdDataProvider;
    private readonly isSvtEnabled;
    private readonly horizonLineShowHeadingLabels;
    private readonly apMaxBankId;
    private readonly showLowBankArc;
    private readonly rollLimitIndicatorsOptions;
    private readonly pitchLimitIndicatorOptions;
    private readonly showPitchLimitIndicator;
    private readonly pitchLimit;
    private readonly pitchLimitIndicatorFormat;
    private readonly showTcasRaPitchCueLayer;
    private readonly showFpm;
    private readonly showFlightDirector;
    private readonly showFlightDirectorSingleCue;
    private readonly showFlightDirectorDualCue;
    private readonly aircraftSymbolFormat;
    private readonly normalFov;
    private readonly extendedFov;
    private readonly fov;
    private readonly nonSvtFovEndpoints;
    private readonly svtFovEndpoints;
    private readonly fovEndpoints;
    private readonly occlusions;
    private readonly ahrsAlignState;
    private readonly ahrsAlignDisplay;
    private readonly showFailureBox;
    private isAlive;
    private isAwake;
    private readonly updateFreq;
    private lastUpdateTime;
    private updateFreqSub?;
    private updateCycleSub?;
    private isSvtEnabledPipe?;
    private readonly updateCycleHandler;
    /**
     * Resolves pitch limit indicator options passed to this display.
     * @returns Resolved pitch limit indicator options, or `undefined` if the indicator should not be displayed.
     */
    private resolvePitchLimitIndicatorOptions;
    /**
     * Resolves roll limit indicators options passed to this display.
     * @returns Resolved roll limit indicators options, or `undefined` if the indicators should not be displayed.
     */
    private resolveRollLimitIndicatorsOptions;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Responds to when the index of the ADC from which this display sources data changes.
     * @param index The new index of the ADC from which this display sources data.
     */
    private onAdcIndexChanged;
    /**
     * Responds to when the index of the AHRS from which this display sources data changes.
     * @param index The new index of the AHRS from which this display sources data.
     */
    private onAhrsIndexChanged;
    /**
     * Responds to when the index of the FMS positioning system from which this display sources data changes.
     * @param index The new index of the FMS positioning system from which this display sources data.
     */
    private onFmsPosIndexChanged;
    /**
     * Responds to when the index of the angle of attack computer system from which this display sources data changes.
     * @param index The new index of the angle of attack computer system from which this display sources data.
     */
    private onAoaIndexChanged;
    /**
     * Wakes this horizon display. While awake, this display will be updated.
     * @throws Error if this horizon display is dead.
     */
    wake(): void;
    /**
     * Puts this horizon display to sleep. While asleep, this display will not be updated.
     * @throws Error if this horizon display is dead.
     */
    sleep(): void;
    /**
     * Responds to changes in this horizon display's projection.
     * @param projection This display's horizon projection.
     * @param changeFlags The types of changes made to the projection.
     */
    private onProjectionChanged;
    /**
     * Recomputes the endpoints at which the field of view of this display's projection is measured when synthetic
     * vision is enabled.
     * @param projection This display's horizon projection.
     */
    private recomputeSvtFovEndpoints;
    /**
     * This method is called every update cycle.
     * @param time The current time, as a UNIX timestamp in milliseconds.
     */
    private onUpdated;
    /**
     * Updates the parameters for this display's pitch limit indicator.
     * @param dt The elapsed time since the last update, in milliseconds.
     */
    private updatePitchLimitIndicatorParams;
    /** @inheritDoc */
    render(): VNode;
    /**
     * Creates roll scale component factories for this display's roll indicator.
     * @returns An array containing the roll scale component factories for this display's roll indicator.
     */
    private createRollScaleComponentFactories;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * Component props for {@link RollLimitIndicators}.
 */
interface RollLimitIndicatorsProps extends ComponentProps {
    /** The component's horizon projection. */
    projection: HorizonProjection;
    /** Parameters describing the indicators' parent roll scale. */
    scaleParams: Readonly<RollIndicatorScaleParameters>;
    /** Whether to show the indicators. */
    show: Subscribable<boolean>;
    /**
     * The roll angle magnitude at which to place the left limit indicator, in degrees. A non-finite value or `NaN` will
     * cause the indicator to not be displayed.
     */
    leftRollLimit: Accessible<number>;
    /**
     * The roll angle magnitude at which to place the right limit indicator, in degrees. A non-finite value or `NaN` will
     * cause the indicator to not be displayed.
     */
    rightRollLimit: Accessible<number>;
    /**
     * The duration of the indicators' easing animation, in milliseconds. The easing animation is used to smoothly
     * transition the indicators from one roll angle to another when the roll limits change. Defaults to `1000`.
     */
    easeDuration?: number;
}
/**
 * A PFD roll indicator scale component that displays roll limit indicators.
 */
declare class RollLimitIndicators extends DisplayComponent<RollLimitIndicatorsProps> implements RollIndicatorScaleComponent {
    private static readonly EASING_BOTH_FUNC;
    private static readonly EASING_OUT_FUNC;
    /** @inheritDoc */
    readonly isRollIndicatorScaleComponent = true;
    private readonly easeDuration;
    private readonly entries;
    private isScaleVisible;
    /** @inheritDoc */
    onScaleAttached(): void;
    /** @inheritDoc */
    onScaleVisibilityChanged(isVisible: boolean): void;
    /** @inheritDoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /** @inheritDoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates a roll limit indicator.
     * @param entry The entry for the indicator to update.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    private updateIndicator;
    /**
     * Hides a roll limit indicator.
     * @param entry The entry for the indicator to hide.
     */
    private hideIndicator;
    /** @inheritDoc */
    onScaleDetached(): void;
    /** @inheritDoc */
    render(): VNode;
    /**
     * Renders a roll limit indicator.
     * @param entry The entry for the indicator to render.
     * @returns A roll limit indicator, as a VNode.
     */
    private renderIndicator;
    /**
     * Creates an entry for a roll limit indicator.
     * @param side The indicator's side.
     * @param limit The roll angle magnitude at which to position the indicator, in degrees.
     * @returns An entry for the specified roll limit indicator.
     */
    private static createEntry;
}

/**
 * Component props for SyntheticVision.
 */
interface SyntheticVisionProps extends HorizonLayerProps {
    /** The string ID to assign to the layer's bound Bing instance. */
    bingId: string;
    /** The amount of time, in milliseconds, to delay binding the layer's Bing instance. Defaults to 0. */
    bingDelay?: number;
    /** Whether to skip unbinding the layer's bound Bing instance when the layer is destroyed. Defaults to `false`. */
    bingSkipUnbindOnDestroy?: boolean;
    /** Whether synthetic vision is enabled. */
    isEnabled: Subscribable<boolean>;
}
/**
 * A synthetic vision technology (SVT) display.
 */
declare class SyntheticVision extends HorizonLayer<SyntheticVisionProps> {
    private static readonly SKY_COLOR;
    private readonly synVisRef;
    private readonly rootStyle;
    private readonly resolution;
    private needUpdateVisibility;
    private needUpdate;
    private isEnabledSub?;
    /** @inheritDoc */
    protected onVisibilityChanged(): void;
    /** @inheritDoc */
    onAttached(): void;
    /** @inheritDoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /** @inheritDoc */
    onWake(): void;
    /** @inheritDoc */
    onSleep(): void;
    /** @inheritDoc */
    onUpdated(): void;
    /** @inheritDoc */
    onDetached(): void;
    /** @inheritDoc */
    render(): VNode;
    /** @inheritDoc */
    destroy(): void;
    /**
     * Creates an object containing an earth color array and elevation range for an SVT display.
     * @returns An object containing an earth color array and elevation range for an SVT display.
     */
    private static createEarthColors;
}

/**
 * Utility class for creating CDI scaling mode text formatters.
 */
declare class CdiScaleFormatter {
    private static readonly TEXT_MAP;
    private static readonly RNP_TEXT_MAP;
    /**
     * Creates a function which formats CDI scaling modes to text strings.
     * @param useRnp Whether the formatter should output explicit RNP values for certain scaling modes (e.g. `'RNP2.00'`
     * instead of `'ENR'`).
     * @returns A function which formats CDI scaling modes to text strings.
     */
    static create(useRnp: boolean): (mode: CDIScaleLabel) => string;
}

/**
 * Display modes for {@link HsiGpsIntegrityAnnunciation}.
 */
declare enum HsiGpsIntegrityAnnunciationMode {
    Ok = "Ok",
    GpsNotUsed = "GpsNotUsed",
    UnableRnp = "UnableRnp",
    GpsLoi = "GpsLoi"
}
/**
 * Component props for HsiGpsIntegrityAnnunciation.
 */
interface HsiGpsIntegrityAnnunciationProps extends ComponentProps {
    /** The mode to display. */
    mode: Subscribable<HsiGpsIntegrityAnnunciationMode>;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin HSI GPS integrity annunciation.
 */
declare class HsiGpsIntegrityAnnunciation extends DisplayComponent<HsiGpsIntegrityAnnunciationProps> {
    private static readonly OK_SHOW_DURATION;
    private static readonly MODE_TEXT;
    private readonly rootStyle;
    private readonly rootCssClass;
    private readonly text;
    private readonly okShowTimer;
    private modeSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for HsiCompass.
 */
interface HsiCompassProps extends ComponentProps {
    /** The size of the compass, in pixels. */
    size: number;
    /** The length of the major compass ticks, in pixels. */
    majorTickLength: number;
    /** The length of the minor compass ticks, in pixels. */
    minorTickLength: number;
    /** The offset, in pixels, of the compass labels from the edge of the compass. */
    labelOffset: number;
}
/**
 * A compass display for a next-generation (NXi, G3000, etc) HSI.
 *
 * The compass display depicts a circular compass rose with minor tick marks every 5 degrees and major tick marks every
 * 10 degrees. The cardinal directions are labeled N/E/S/W, with numeric labels (3, 6, 12, ...) at every hour position
 * that does not represent a cardinal direction.
 *
 * The compass also optionally displays a single continuous circular line of arbitrary radius within the rose.
 */
declare class HsiCompass extends DisplayComponent<HsiCompassProps> {
    /** @inheritdoc */
    render(): VNode;
    /**
     * Renders this compass's tick marks.
     * @returns This compass's tick marks, as an array of VNodes.
     */
    private renderTicks;
    /**
     * Renders this compass's labels.
     * @returns This compass's labels, as an array of VNodes.
     */
    private renderLabels;
}

/**
 * An animator for HSI needle rotations.
 */
declare class NeedleAnimator {
    private readonly turnRate;
    private static readonly easeInOut;
    private static readonly easeOut;
    /** The minimum change in rotation, in degrees, required to trigger an animation. */
    private readonly animationThreshold;
    private readonly animator;
    /** This animator's current rotation, in degrees. */
    readonly rotation: _microsoft_msfs_sdk.Subscribable<number>;
    /**
     * Constructor.
     * @param turnRate The turn rate, in degrees per second, used by this animator.
     */
    constructor(turnRate: number);
    /**
     * Animates a rotation. This animator's rotation will be animated to rotate toward a target rotation with easing at
     * the start and end. If another animation is currently active, it will be immediately stopped and replaced by the
     * new animation, and the ease in will be skipped.
     * @param target The target rotation, in degrees.
     */
    animateRotation(target: number): void;
    /**
     * Immediately sets this animator's rotation to a given value and cancels any animation in progress.
     * @param rotation The rotation to set, in degrees.
     */
    setRotation(rotation: number): void;
    /**
     * Stops the current animation in progress, if any, and optionally sets this animator's rotation to the animation
     * target.
     * @param setAnimationTarget Whether to set this animator's rotation to the animation target. Defaults to `false`.
     */
    stopAnimation(setAnimationTarget?: boolean): void;
}

/**
 * Component props for TurnRateIndicator.
 */
interface TurnRateProps extends ComponentProps {
    /** The radius of the HSI compass, in pixels. */
    compassRadius: number;
    /** The height of the indicator, in pixels. Defaults to 24 pixels. */
    height?: number;
    /**
     * The radial offset, in pixels, of the inner end of each indicator tick from the outer edge of the HSI compass.
     * Positive values move the ticks outward. Defaults to 3 pixels.
     */
    tickOffset?: number;
    /** The length of each indicator tick, in pixels. Defaults to 15 pixels. */
    tickLength?: number;
    /**
     * The radial offset, in pixels, of the inner edge of the turn rate vector from the outer edge of the HSI compass.
     * Positive values move the vector outward. Defaults to 1 pixel.
     */
    vectorOffset?: number;
    /** The width of the turn rate vector, in pixels. Defaults to 6 pixels. */
    vectorWidth?: number;
    /** The width of the turn rate vector arrow (inner to outer edge), in pixels. Defaults to 12 pixels. */
    vectorArrowWidth?: number;
    /** The length of the turn rate vector arrow (base to tip), in pixels. Defaults to 12 pixels. */
    vectorArrowLength?: number;
}
/**
 * A turn rate indicator for a next-generation (NXi, G3000, etc) HSI.
 *
 * The turn rate indicator is rendered such that it sits on the top edge of an HSI compass. The indicator spans 24
 * degrees of arc on either side of the lubber line. Markings are present at 9 and 18 degrees on either side of the
 * lubber line. A turn rate vector is extended along an arc parallel to the compass edge subtending an angle equal to
 * the estimated change in heading over the next 6 seconds. If turn rate exceeds 4 degrees per second, the vector is
 * clamped to 24 degrees of arc and an arrowhead is added to the end.
 *
 * The turn rate indicator's root element should be positioned such that its bottom edge intersects the center of the
 * HSI compass, and its left edge sits flush with the left edge of the HSI compass (the width of the root element is
 * equal to the diameter of the compass).
 */
declare class TurnRateIndicator extends DisplayComponent<TurnRateProps> {
    private static readonly HALF_ANGULAR_WIDTH;
    private static readonly DEFAULT_HEIGHT;
    private static readonly DEFAULT_TICK_OFFSET;
    private static readonly DEFAULT_TICK_LENGTH;
    private static readonly DEFAULT_VECTOR_OFFSET;
    private static readonly DEFAULT_VECTOR_WIDTH;
    private static readonly DEFAULT_VECTOR_ARROW_WIDTH;
    private static readonly DEFAULT_VECTOR_ARROW_LENGTH;
    private readonly clipStyle;
    private readonly rotateStyle;
    private noArrowVectorPath;
    private arrowVectorPath;
    private readonly vectorPath;
    private readonly vectorRotate;
    private readonly vectorRotateSign;
    private readonly vectorRotateMag;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Sets this indicator's displayed turn rate.
     * @param turnRate The turn rate, in degrees per second. Positive values indicate a right-hand turn.
     */
    setTurnRate(turnRate: number): void;
    /** @inheritDoc */
    render(): VNode;
}

/**
 * A provider of marker beacon data.
 */
interface MarkerBeaconDataProvider {
    /** The current marker beacon receiving state. */
    readonly markerBeaconState: Subscribable<MarkerBeaconState>;
    /** Whether marker beacon data is in a failed state. */
    readonly isDataFailed: Subscribable<boolean>;
}
/**
 * A default implementation of {@link MarkerBeaconDataProvider}.
 */
declare class DefaultMarkerBeaconDataProvider implements MarkerBeaconDataProvider {
    private readonly bus;
    private readonly _markerBeaconState;
    /** @inheritdoc */
    readonly markerBeaconState: Subscribable<number>;
    private readonly _isDataFailed;
    /** @inheritdoc */
    readonly isDataFailed: Subscribable<boolean>;
    private readonly markerBeaconIndex;
    private readonly markerSystemState;
    private isInit;
    private isAlive;
    private isPaused;
    private markerBeaconIndexSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param markerBeaconIndex The index of the AoA computer that is the source of this provider's data.
     */
    constructor(bus: EventBus, markerBeaconIndex: number | Subscribable<number>);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Component props for MarkerBeaconDisplay.
 */
interface MarkerBeaconDisplayProps extends ComponentProps {
    /** A provider of marker beacon data. */
    dataProvider: MarkerBeaconDataProvider;
    /** Whether the display should be decluttered. */
    declutter: Subscribable<boolean>;
}
/**
 * The PFD marker beacon annunciation display.
 */
declare class MarkerBeaconDisplay extends DisplayComponent<MarkerBeaconDisplayProps> {
    private static readonly TEXT;
    private readonly rootStyle;
    private readonly rootCssClass;
    private readonly text;
    private stateSub?;
    private isDataFailedSub?;
    private declutterSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Altimeter user settings.
 */
type AltimeterUserSettingTypes = MetricAltitudeSelectSetting & {
    /** Whether to display altimeter barometric pressure settings in metric units. */
    altimeterBaroMetric: boolean;
};

/**
 * Setting modes for COM radio channel spacing.
 */
declare enum ComRadioSpacingSettingMode {
    Spacing25Khz = "25Khz",
    Spacing8_33Khz = "8.33Khz"
}
/**
 * COM radio user settings.
 */
type ComRadioUserSettingTypes = {
    /** COM radio channel spacing mode. */
    comRadioSpacing: ComRadioSpacingSettingMode;
};
/**
 * Utility class for retrieving COM radio user setting managers.
 */
declare class ComRadioUserSettings {
    private static INSTANCE;
    /**
     * Retrieves a manager for COM radio user settings.
     * @param bus The event bus.
     * @returns A manager for COM radio user settings.
     */
    static getManager(bus: EventBus): UserSettingManager<ComRadioUserSettingTypes>;
}

/**
 * Setting modes for DME tuning.
 */
declare enum DmeTuneSettingMode {
    Nav1 = "Nav1",
    Nav2 = "Nav2",
    Hold = "Hold"
}
/**
 * Type descriptions for DME user settings.
 */
type DmeUserSettingTypes = {
    /** Tuning mode for DME radio 1. */
    dme1TuneMode: DmeTuneSettingMode;
    /** Tuning mode for DME radio 2. */
    dme2TuneMode: DmeTuneSettingMode;
};
/**
 * Utility class for retrieving DME user setting managers.
 */
declare class DmeUserSettings {
    private static INSTANCE;
    /**
     * Retrieves a manager for DME user settings.
     * @param bus The event bus.
     * @returns A manager for DME user settings.
     */
    static getManager(bus: EventBus): DefaultUserSettingManager<DmeUserSettingTypes>;
}

/**
 * Type description for nearest airport user settings.
 */
type NearestAirportUserSettingTypes = {
    /** The minimum runway length, in feet, required for an airport to be included in the nearest list. */
    nearestAptRunwayLength: number;
    /** Bitflags of the supported runway surface types for an airport to be included in the nearest list.  */
    nearestAptRunwaySurfaceTypes: number;
};
/**
 * Utility class for retrieving nearest airport user setting managers.
 */
declare class NearestAirportUserSettings {
    private static INSTANCE;
    /**
     * Retrieves a manager for airport search settings.
     * @param bus The event bus.
     * @returns a manager for airport search settings.
     */
    static getManager(bus: EventBus): DefaultUserSettingManager<NearestAirportUserSettingTypes>;
}

/**
 * The operating mode of a Garmin weather radar.
 */
declare enum WeatherRadarOperatingMode {
    Standby = "Standby",
    Weather = "Weather"
}
/**
 * The scan mode of a Garmin weather radar.
 */
declare enum WeatherRadarScanMode {
    Horizontal = "Horizontal",
    Vertical = "Vertical"
}
/**
 * Component props for WeatherRadar.
 */
interface WeatherRadarProps extends ComponentProps {
    /** The unique ID to assign to the weather radar's Bing instance. */
    bingId: string;
    /** The event bus. */
    bus: EventBus;
    /** The operating mode of the weather radar. */
    operatingMode: Subscribable<WeatherRadarOperatingMode>;
    /** The scan mode of the weather radar. */
    scanMode: Subscribable<WeatherRadarScanMode>;
    /** The angular width, in degrees, of the radar arc in horizontal scan mode. */
    horizontalScanAngularWidth: number | Subscribable<number>;
    /** The angular width, in degrees, of the radar arc in vertical scan mode. */
    verticalScanAngularWidth: number | Subscribable<number>;
    /** The display range of the weather radar. */
    range: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** The units displayed by the weather radar's range labels. */
    rangeUnit: Unit<UnitFamily.Distance> | Subscribable<Unit<UnitFamily.Distance>>;
    /** The size of the weather radar display, as `[width, height]` in pixels. */
    size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** Whether to show the bearing line in horizontal scan mode. */
    showBearingLine: Subscribable<boolean>;
    /** Whether to show the tilt line in vertical scan mode. */
    showTiltLine: Subscribable<boolean>;
    /**
     * The colors for the weather radar at zero gain. Each entry `E_i` of the array is a tuple `[color, dBZ]` that
     * defines a color stop, where `color` is an RGBA color expressed as `R + G * 256 + B * 256^2 + A * 256^3` and `dBZ`
     * is a return signal strength.
     *
     * In general, the color defined by `E_i` is applied to returns ranging from the signal strength defined by `E_i-1`
     * to the signal strength defined by `E_i`. There are two special cases. The color defined by `E_0` is applied to
     * returns with signal strengths from negative infinity to the strength defined by `E_0`. The color defined by
     * `E_n-1`, where `n` is the length of the array, is applied to returns with signal strengths from the strength
     * defined by `E_n-2` to positive infinity.
     */
    colors: readonly (readonly [number, number])[] | Subscribable<readonly (readonly [number, number])[]>;
    /** The gain of the weather radar, in dBZ. */
    gain: Subscribable<number>;
    /** Whether weather radar data is in a failure state. */
    isDataFailed: Subscribable<boolean>;
    /**
     * The padding inside the weather radar display respected by the radar arc in horizontal scan mode, as
     * `[left, top, right, bottom]` in pixels. Defaults to `[0, 0, 0, 0]`.
     */
    horizontalScanPadding?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The padding inside the weather radar display respected by the radar arc in vertical scan mode, as
     * `[left, top, right, bottom]` in pixels. Defaults to `[0, 0, 0, 0]`.
     */
    verticalScanPadding?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The amount the vertical range lines extend outward from the boundaries of the radar arc, in pixels.
     * Defaults to 0 pixels.
     */
    verticalRangeLineExtend?: number | Subscribable<number>;
    /** The angular width of the reference line, in degrees. Defaults to 0 degrees. */
    referenceLineAngularWidth?: number;
    /** A mutable subscribable to bind to the position of the center of the radar arc, as `[x, y]` in pixels. */
    arcOrigin?: MutableSubscribable<any, ReadonlyFloat64Array>;
    /** A mutable subscribable to bind to the radius of the radar arc, in pixels. */
    arcRadius?: MutableSubscribable<any, number>;
    /** A mutable subscribable to bind to the bounding rect of the radar arc, as `[left, top, right, bottom]` in pixels. */
    arcBounds?: MutableSubscribable<any, ReadonlyFloat64Array>;
}
/**
 * A Garmin weather radar display.
 */
declare class WeatherRadar extends DisplayComponent<WeatherRadarProps> {
    private static readonly DEFAULT_PADDING;
    private static readonly DEFAULT_VERTICAL_RANGE_LINE_EXTEND;
    private static readonly DEFAULT_BEARING_LINE_ANGULAR_WIDTH;
    private static readonly VERTICAL_RANGE_MARKER_HEIGHT;
    private static readonly vec2Cache;
    private readonly bingRef;
    private readonly rangeLabelRefs;
    private readonly rootStyle;
    private readonly bingStyle;
    private readonly rangeLabelStyles;
    private readonly verticalRangeLineStyle;
    private readonly verticalRangeLabelTopStyle;
    private readonly verticalRangeLabelBottomStyle;
    private readonly referenceLineContainerStyle;
    private readonly rootCssClass;
    private readonly svgPathStream;
    private readonly svgTransformPathStream;
    private readonly horizontalScanAngularWidth;
    private readonly verticalScanAngularWidth;
    private readonly size;
    private readonly horizontalScanPadding;
    private readonly verticalScanPadding;
    private readonly verticalRangeLineExtend;
    private readonly referenceLineAngularWidth;
    private scanMode;
    private isSwitchingScanMode;
    /** The [x, y] position, in pixels, of the center of the weather radar arc. */
    private readonly arcOrigin;
    /** The radius, in pixels, of the weather radar arc. */
    private arcRadius;
    /** The angular width, in radians, of the weather radar arc. */
    private arcAngularWidth;
    /** The bounding rect of the weather radar arc. */
    private readonly arcBounds;
    private readonly overlayViewBox;
    private readonly boundaryLinePath;
    private readonly rangeLinesPath;
    private readonly referenceLineContainerViewBox;
    private readonly referenceLinePath;
    private readonly verticalRangeLinesPath;
    private readonly position;
    private readonly wxrMode;
    private readonly ranges;
    private readonly verticalRangeTop;
    private readonly verticalRangeBottom;
    private readonly isReferenceLineVisible;
    private readonly colors;
    private readonly bingWxrColorsWorkingArray;
    private readonly bingWxrColors;
    private needResize;
    private needReposition;
    private needUpdateBingWxrMode;
    private needUpdateBingWxrColors;
    private needRedrawOverlay;
    private needRedrawVerticalRangeLines;
    private needUpdateBing;
    private needUpdateReferenceLineVisibility;
    private needRotateReferenceLine;
    private operatingModeSub?;
    private scanModeSub?;
    private horizontalScanAngularWidthSub?;
    private verticalScanAngularWidthSub?;
    private rangeSub?;
    private isDataFailedSub?;
    private sizeSub?;
    private horizontalScanPaddingSub?;
    private verticalScanPaddingSub?;
    private verticalRangeLineExtendSub?;
    private colorsSub?;
    private gainSub?;
    private isAlive;
    private isInit;
    private isAwake;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Wakes this weather radar. Once awake, this radar will be able to update.
     * @throws Error if this weather radar is dead.
     */
    wake(): void;
    /**
     * Puts this weather radar to sleep. Once asleep, this radar will not be able to update until it is awakened.
     * @throws Error if this weather radar is dead.
     */
    sleep(): void;
    /**
     * Updates this weather radar.
     * @throws Error if this weather radar is dead.
     */
    update(): void;
    /**
     * Resizes this weather radar's root container.
     * @param size The size of the root container.
     */
    private resizeContainer;
    /**
     * Updates this weather radar's Bing component weather mode.
     */
    private updateBingWxrMode;
    /**
     * Recomputes the size and positioning of this weather radar's radar arc.
     */
    private recomputePositioning;
    /**
     * Repositions this weather radar's Bing component.
     */
    private repositionBing;
    /**
     * Redraws this weather radar's overlay elements, including the radar arc boundary lines, range lines, and reference
     * line.
     */
    private redrawOverlay;
    /**
     * Draws radar arc boundary lines.
     * @param arcOrigin The position of the center of the radar arc, as `[x, y]` in pixels.
     * @param arcRadius The radius of the radar arc, in pixels.
     * @param facing The facing angle of the radar arc, in radians. An angle of `0` points in the positive x-direction,
     * with positive angles proceeding clockwise.
     * @param arcAngularWidth The angular width of the radar arc, in radians.
     */
    private drawBoundaryLines;
    /**
     * Draws radar arc range lines.
     * @param size The size of this weather radar display, as `[width, height]` in pixels.
     * @param arcOrigin The position of the center of the radar arc, as `[x, y]` in pixels.
     * @param arcRadius The radius of the radar arc, in pixels.
     * @param facing The facing angle of the radar arc, in radians. An angle of `0` points in the positive x-direction,
     * with positive angles proceeding clockwise.
     * @param arcAngularWidth The angular width of the radar arc, in radians.
     */
    private drawRangeLines;
    /**
     * Draws a reference line.
     * @param arcOrigin The position of the center of the radar arc, as `[x, y]` in pixels.
     * @param arcRadius The radius of the radar arc, in pixels.
     */
    private drawReferenceLine;
    /**
     * Draws radar arc vertical range lines.
     * @param size The size of this weather radar display, as `[width, height]` in pixels.
     * @param arcOrigin The position of the center of the radar arc, as `[x, y]` in pixels.
     * @param arcRadius The radius of the radar arc, in pixels.
     * @param arcAngularWidth The angular width of the radar arc, in radians.
     * @param range The display range of this weather radar.
     */
    private drawVerticalRangeLines;
    /**
     * Hides this weather radar's vertical range lines.
     */
    private hideVerticalRangeLines;
    /**
     * Updates this weather radar's Bing component weather colors.
     */
    private updateBingWxrColors;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Weather radar user settings.
 */
type WeatherRadarUserSettingTypes = {
    /** Whether the weather radar is active. */
    wxrActive: boolean;
    /** The weather radar's operating mode. */
    wxrOperatingMode: WeatherRadarOperatingMode;
    /** The weather radar's scan mode. */
    wxrScanMode: WeatherRadarScanMode;
    /** The index of the weather radar's current range. */
    wxrRangeIndex: number;
    /** Whether to show the bearing line in horizontal scan mode. */
    wxrShowBearingLine: boolean;
    /** Whether to show the tilt line in vertical scan mode. */
    wxrShowTiltLine: boolean;
    /** Whether the weather radar's gain should be locked to the calibrated setting (0 dBZ). */
    wxrCalibratedGain: boolean;
    /** The weather radar's gain, in dBZ. */
    wxrGain: number;
};

/**
 * Component props for MinimumsDisplay.
 */
interface MinimumsDisplayProps extends ComponentProps {
    /** An instance of the event bus. */
    bus: EventBus;
    /** A data provider for the display. */
    dataProvider: MinimumsDataProvider;
    /** The current minimums alert state. */
    minimumsAlertState: Subscribable<MinimumsAlertState>;
    /** A manager for display units user settings. */
    unitsSettingManager: UnitsUserSettingManager;
    /** Whether the indicator should be decluttered. */
    declutter: Subscribable<boolean>;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin PFD minimums display.
 */
declare class MinimumsDisplay extends DisplayComponent<MinimumsDisplayProps> {
    private readonly valueRef;
    private readonly rootStyle;
    private readonly rootCssClass;
    private readonly modeText;
    private readonly minimumsValue;
    private modeSub?;
    private minimumsPipe?;
    private minimumsAlertSub?;
    private declutterSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A enumeration of waypoint alerting states.
 */
declare enum WaypointAlertingState {
    None = "None",
    ArrivingAtWaypoint = "ArrivingAtWaypoint",
    CourseInSeconds = "DtKinSeconds",
    CourseNow = "DtkNow",
    HoldDirect = "HoldDirect",
    HoldParallel = "HoldParallel",
    HoldTeardrop = "HoldTeardrop",
    LeftTurnInSeconds = "LeftTurnInSeconds",
    LeftTurnNow = "LeftTurnNow",
    ParallelTrackEnd = "ParallelTrackEnd",
    RightTurnInSeconds = "RightTurnInSeconds",
    RightTurnNow = "RightTurnNow"
}
/**
 * The type of course guidance in a waypoint alerting state, if any.
 */
declare enum WaypointAlertCourseType {
    DesiredTrack = "DesiredTrack",
    Heading = "Heading"
}
/**
 * A waypoint alert state event with a defined course.
 */
interface WaypointAlertStateEvent {
    /** The previous alerting state. */
    previousState: WaypointAlertingState;
    /** The new alerting state. */
    newState: WaypointAlertingState;
    /** The new course, in degrees true. */
    course?: number;
    /** The new course, in degrees magnetic. */
    courseMag?: number;
    /** The type of course to follow. */
    courseType?: WaypointAlertCourseType;
}
/**
 * Configuration options for {@link WaypointAlertComputer}.
 */
type WaypointAlertComputerOptions = {
    /** The flight planner from which to retrieve the active flight plan. */
    flightPlanner: FlightPlanner | Subscribable<FlightPlanner>;
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The amount of time from the waypoint or target turn, in seconds, to begin alerting. */
    alertLookaheadTime: number;
    /**
     * The amount of time, in seconds, to keep "...NOW" alerts active after they have been triggered. Defaults to five
     * seconds.
     */
    nowAlertTime?: number;
};
/**
 * A class that computes the current waypoint alert state for consumers to use for waypoint alert displays.
 */
declare class WaypointAlertComputer {
    private readonly bus;
    private static readonly DEFAULT_NOW_ALERT_TIME;
    private static readonly HOLD_ALERT_TIME;
    private readonly flightPlanner;
    private readonly lnavIndex;
    private readonly alertLookaheadTime;
    private readonly nowAlertTime;
    private readonly simTime;
    private readonly groundSpeed;
    private readonly ppos;
    private readonly alongTrackSpeed;
    private readonly distanceRemaining;
    private readonly currentDtk;
    private readonly nextDtk;
    private readonly nextDtkMag;
    private readonly nextDtkVector;
    private readonly lnavTrackingState;
    private readonly _state;
    /** The current alert state. */
    readonly state: Subscribable<Readonly<WaypointAlertStateEvent>>;
    /** An event which fires every time the alert state changes. */
    readonly onStateChanged: SubEvent<this, Readonly<WaypointAlertStateEvent>>;
    /** The time remaining for the current alert state, or `NaN` if an alert is not active. */
    readonly timeRemaining: NumberUnitSubject<_microsoft_msfs_sdk.UnitFamily.Duration, _microsoft_msfs_sdk.SimpleUnit<_microsoft_msfs_sdk.UnitFamily.Duration>>;
    private canUpdate;
    private previousState;
    private currentState;
    private armedNowState;
    private armedNowLegIndex;
    private armedNowVectorIndex;
    private armedNowCourse;
    private armedNowCourseMag;
    private armedNowCourseType;
    private nowStateTimeStamp;
    private readonly stateSubject;
    private currentCourse;
    private currentCourseMag;
    private currentCourseType;
    private readonly geoCircleCache;
    private readonly geoPointCache;
    /**
     * Creates an instance of the WaypointAlertComputer.
     * @param bus The event bus to use with this instance.
     * @param options Options with which to configure the computer.
     */
    constructor(bus: EventBus, options: Readonly<WaypointAlertComputerOptions>);
    /**
     * Creates an instance of the WaypointAlertComputer.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner from which to retrieve the active flight plan.
     * @param alertLookaheadTime The amount of time from the waypoint or target turn, in seconds, to begin alerting.
     * @param nowAlertTime The amount of time, in seconds, to keep "...NOW" alerts active after they have been triggered.
     * Defaults to five seconds.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, alertLookaheadTime: number, nowAlertTime?: number);
    /**
     * Responds to when this computer's LNAV index changes.
     * @param lnavEvents An event subscriber for LNAV events.
     * @param index The new LNAV index.
     */
    private onLNavIndexChanged;
    /**
     * Handles when the internal state has changed.
     * @param state The new alerting state.
     */
    private handleStateChanged;
    /**
     * Handles when the LNAV tracking state changes.
     * @param state The new LNAV tracking state.
     */
    private handleTrackedIndicesChanged;
    /**
     * Resets this computer's internal state.
     */
    private reset;
    /**
     * Updates the WaypointAlertComputer.
     */
    update(): void;
    /**
     * Handles the default legs cases.
     * @param currentLegDef The definition of the current leg.
     * @param nextLegDef The next leg definition.
     */
    private handleDefaultLegs;
    /**
     * Checks whether the provided leg type can support a WaypointAlertingState.LeftTurnNow/RightTurnNow
     * instead of a WaypointAlertingState.Course message.
     * @param legType The leg type.
     * @param isNextLeg Whether this leg type is the next leg (true) or the current leg (false).
     * @returns Whether or not the leg supports a LeftTurn/RightTurn WaypointAlertingState.
     */
    private doesLegTypeSupportTurn;
    /**
     * Checks whether or not the current state is a now type state.
     * @returns True if in a now type state, false otherwise.
     */
    private isInNowState;
    /**
     * Gets the initial DTK for a hold leg.
     * @param nextLegCalcs The next leg in the flight plan.
     * @returns The DTK in degrees true, or undefined if one could not be determined.
     */
    private getInitialHoldDtk;
    /**
     * Gets the initial DTK for a PI leg.
     * @param nextLegCalcs The leg calculations for the next leg in the flight plan.
     * @returns The DTK in degrees true.
     */
    private getInitialPIDtk;
    /**
     * Handles alerting while on hold and procedure turn legs.
     * @param currentLegDef The definition of the current leg.
     * @param nextLegDef The definition of the next leg.
     */
    private handleHoldAndPILegs;
    /**
     * Determines if a leg is a hold leg.
     * @param legDef The leg definition to check.
     * @returns True if a hold, false otherwise.
     */
    private legIsHold;
    /**
     * Gets the next turn vector index in a set of leg calculations.
     * @param startIndex The index, non-inclusive, to start searching at.
     * @param flightPath The set of leg vectors to pull from.
     * @param includeContinuous Whether or not to include turns that are continous to the next turn.
     * @returns The next turn vector index, or -1 if none found.
     */
    private getNextTurnIndex;
    /**
     * Checks to see if two turn vectors are effectively continous (a continuation of the same circle).
     * @param a The first vector.
     * @param b The second vector.
     * @returns Whether or not the two vectors are continuous.
     */
    private areTurnsContinuous;
    /**
     * Gets the amount of distance, in nautical miles, remaining before the end of a portion of a leg.
     * @param startIndex The start vector index, inclusive.
     * @param endIndex The end vector index, exclusive.
     * @param flightPath The set of leg vectors to pull from.
     * @returns The amount of distance remaining.
     */
    private getSegmentDistanceRemaining;
    /**
     * Attempts to enter the hold state if applicable.
     * @param nextLegDef The next leg in the plan.
     * @param secondsRemaining The number of seconds remaining before the waypoint.
     * @returns True if entered a hold state, false otherwise.
     */
    private tryEnterHoldState;
    /**
     * Handles when the computer is potentially in the ArrivingAtWaypoint state.
     * @param secondsRemaining The number of seconds remaining until the waypoint.
     */
    private handleArrivingAtWaypoint;
}

/**
 * Valid types of VNAV target altitude restrictions.
 */
type VNavTargetAltitudeRestrictionType = Exclude<AltitudeRestrictionType, AltitudeRestrictionType.Between | AltitudeRestrictionType.Unused>;
/**
 * A VNAV target altitude restriction.
 */
type VNavTargetAltitudeRestriction = {
    /** The type of this restriction. */
    type: VNavTargetAltitudeRestrictionType;
    /** The altitude for this restriction, in feet. */
    altitude: number;
};
/**
 * A provider of VNAV data for various displays.
 */
interface VNavDataProvider {
    /** The current VNAV phase. */
    readonly phase: Subscribable<VerticalFlightPhase | null>;
    /** The current VNAV flight phase. */
    readonly vnavFlightPhase: Subscribable<GarminVNavFlightPhase>;
    /** The current VNAV tracking phase. */
    readonly vnavTrackingPhase: Subscribable<GarminVNavTrackingPhase>;
    /** Whether VNAV direct-to is currently active. */
    readonly isVNavDirectToActive: Subscribable<boolean>;
    /** The current VNAV path mode. */
    readonly pathMode: Subscribable<VNavPathMode>;
    /** The current VNAV cruise altitude, in feet. */
    readonly cruiseAltitude: Subscribable<number | null>;
    /** The flight plan leg that defines the active VNAV constraint. */
    readonly activeConstraintLeg: Subscribable<LegDefinition | null>;
    /** The target VNAV altitude restriction. */
    readonly targetRestriction: Subscribable<VNavTargetAltitudeRestriction | null>;
    /** The desired flight path angle, in degrees, for the current VNAV leg. Positive angles represent descending paths. */
    readonly fpa: Subscribable<number | null>;
    /** The vertical speed target, in feet per minute, for the current VNAV leg. */
    readonly verticalSpeedTarget: Subscribable<number | null>;
    /** The vertical speed required, in feet per minute, to meet the active VNAV restriction. */
    readonly vsRequired: Subscribable<number | null>;
    /** The vertical deviation, in feet, from the VNAV path profile. Positive values indicate deviation above the profile. */
    readonly verticalDeviation: Subscribable<number | null>;
    /** The distance remaining to the next top of descent, in nautical miles. */
    readonly distanceToTod: Subscribable<number | null>;
    /** The time remaining to the next top of descent, in seconds. */
    readonly timeToTod: Subscribable<number | null>;
    /** The time remaining to the next bottom of descent, in seconds. */
    readonly timeToBod: Subscribable<number | null>;
    /** The time remaining to the next top of climb, in seconds. */
    readonly timeToToc: Subscribable<number | null>;
    /** The time remaining to the next bottom of climb, in seconds. */
    readonly timeToBoc: Subscribable<number | null>;
    /** An event that is fired when a vertical track alert is issued. The event data is the alert type. */
    readonly trackAlert: ReadonlySubEvent<void, GarminVNavTrackAlertType>;
}
/**
 * Configuration options for {@link DefaultVNavDataProvider}.
 */
type DefaultVNavDataProviderOptions = {
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
    /** The index of the ADC from which to source data. Defaults to `1`. */
    adcIndex?: number | Subscribable<number>;
    /** The ID of the CDI from which to source data. Defaults to the empty string (`''`). */
    cdiId?: string | Subscribable<string>;
};
/**
 * A default implementation of {@link VNavDataProvider}.
 */
declare class DefaultVNavDataProvider implements VNavDataProvider {
    private readonly bus;
    /** The amount of time before reaching TOD/BOC when VNAV path tracking data becomes valid, in hours. */
    private static readonly PATH_TRACKING_LOOKAHEAD;
    private readonly fms;
    private readonly vnavIndex;
    private isVNavIndexValid;
    private readonly _phase;
    /** @inheritdoc */
    readonly phase: Subscribable<VerticalFlightPhase | null>;
    private readonly _vnavFlightPhase;
    /** @inheritdoc */
    readonly vnavFlightPhase: Subscribable<GarminVNavFlightPhase>;
    private readonly _vnavTrackingPhase;
    /** @inheritdoc */
    readonly vnavTrackingPhase: Subscribable<GarminVNavTrackingPhase>;
    private readonly _isVNavDirectToActive;
    /** @inheritdoc */
    readonly isVNavDirectToActive: Subscribable<boolean>;
    private readonly _pathMode;
    /** @inheritdoc */
    readonly pathMode: Subscribable<VNavPathMode>;
    private readonly _cruiseAltitude;
    /** @inheritdoc */
    readonly cruiseAltitude: Subscribable<number | null>;
    private readonly _activeConstraintLeg;
    /** @inheritdoc */
    readonly activeConstraintLeg: Subscribable<LegDefinition | null>;
    private readonly _targetAltitude;
    private readonly _fpa;
    /** @inheritdoc */
    readonly fpa: Subscribable<number | null>;
    private readonly _verticalSpeedTarget;
    /** @inheritdoc */
    readonly verticalSpeedTarget: Subscribable<number | null>;
    private readonly _vsRequired;
    /** @inheritdoc */
    readonly vsRequired: Subscribable<number | null>;
    private readonly _verticalDeviation;
    /** @inheritdoc */
    readonly verticalDeviation: Subscribable<number | null>;
    private readonly _distanceToTod;
    /** @inheritdoc */
    readonly distanceToTod: Subscribable<number | null>;
    private readonly _timeToTod;
    /** @inheritdoc */
    readonly timeToTod: Subscribable<number | null>;
    private readonly _timeToBod;
    /** @inheritdoc */
    readonly timeToBod: Subscribable<number | null>;
    private readonly _timeToToc;
    /** @inheritdoc */
    readonly timeToToc: Subscribable<number | null>;
    private readonly _timeToBoc;
    /** @inheritdoc */
    readonly timeToBoc: Subscribable<number | null>;
    private readonly _trackAlert;
    /** @inheritdoc */
    readonly trackAlert: ReadonlySubEvent<void, GarminVNavTrackAlertType>;
    private readonly indicatedAlt;
    private readonly groundSpeed;
    private readonly activeNavSource;
    private readonly approachDetails;
    private readonly flightPhase;
    private readonly vnavState;
    private readonly vnavFlightPhaseSource;
    private readonly vnavTrackingPhaseSource;
    private readonly vnavPathMode;
    private readonly vnavCruiseAltitude;
    private readonly vnavActiveConstraintLegIndex;
    private readonly vnavFpa;
    private readonly vnavVsRequired;
    private readonly vnavVerticalDeviation;
    private readonly vnavTodIndex;
    private readonly vnavTodDistance;
    private readonly vnavBodIndex;
    private readonly vnavBodDistance;
    private readonly vnavTocIndex;
    private readonly vnavTocDistance;
    private readonly vnavBocIndex;
    private readonly vnavBocDistance;
    private readonly approachGuidanceMode;
    private readonly vnavConstraintDetails;
    /** @inheritdoc */
    readonly targetRestriction: Subscribable<VNavTargetAltitudeRestriction | null>;
    private readonly adcIndex;
    private readonly cdiId;
    private isInit;
    private isAlive;
    private isPaused;
    private readonly pauseable;
    private fmsSub?;
    private vnavIndexSub?;
    private adcIndexSub?;
    private cdiIdSub?;
    private clockSub?;
    private vnavStateSub?;
    private trackAlertSub?;
    /**
     * Creates a new instance of DefaultVNavDataProvider.
     * @param bus The event bus.
     * @param fms The FMS.
     * @param adcIndex The index of the ADC that is the source of this provider's data.
     */
    constructor(bus: EventBus, fms: Fms | Subscribable<Fms>, options?: Readonly<DefaultVNavDataProviderOptions>);
    /**
     * Creates a new instance of DefaultVNavDataProvider that sources data from VNAV index 0.
     * @param bus The event bus.
     * @param fms The FMS.
     * @param adcIndex The index of the ADC that is the source of this provider's data. Defaults to `1`.
     */
    constructor(bus: EventBus, fms: Fms | Subscribable<Fms>, adcIndex?: number | Subscribable<number>);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Updates this provider's data.
     */
    private update;
    /**
     * Clears this provider's data.
     */
    private clearData;
    /**
     * Responds to when a vertical track alert is issued.
     * @param type The type of alert that was issued.
     */
    private onTrackAlertIssued;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * From, to, and next flight plan legs tracked by LNAV.
 */
type NavStatusTrackedLegs = {
    /** The current nominal leg from which LNAV is tracking. */
    fromLeg: LegDefinition | null;
    /** The current nominal leg which LNAV is tracking. */
    toLeg: LegDefinition | null;
    /** The next nominal leg which LNAV is tracking. */
    nextLeg: LegDefinition | null;
};
/**
 * A data provider for a navigation status box.
 */
interface NavStatusBoxDataProvider {
    /** The current from, to, and next flight plan legs LNAV is tracking. */
    readonly trackedLegs: Subscribable<Readonly<NavStatusTrackedLegs>>;
    /** The current active OBS course, in degrees, or `null` if OBS is inactive. */
    readonly obsCourse: Subscribable<number | null>;
    /** The current waypoint alert state. */
    readonly waypointAlertState: Subscribable<Readonly<WaypointAlertStateEvent>>;
    /** The time remaining for the current waypoint alert, or `NaN` if an alert is not active. */
    readonly waypointAlertTime: Subscribable<NumberUnitInterface<UnitFamily.Duration>>;
    /** An event that is fired when a vertical track alert is issued. The event data is the alert type. */
    readonly verticalTrackAlert: ReadonlySubEvent<void, GarminVNavTrackAlertType>;
}

/**
 * A default implementation of `NavStatusBoxDataProvider`.
 */
declare class DefaultNavStatusBoxDataProvider implements NavStatusBoxDataProvider {
    private readonly bus;
    private readonly fms;
    private readonly waypointAlertComputer;
    private readonly vnavDataProvider?;
    private readonly trackedLegsBuffer;
    private readonly _trackedLegs;
    /** @inheritDoc */
    readonly trackedLegs: Subscribable<Readonly<NavStatusTrackedLegs>>;
    private readonly isObsActive;
    private readonly obsCourseSource;
    private readonly _obsCourse;
    readonly obsCourse: Subscribable<number | null>;
    /** @inheritDoc */
    readonly waypointAlertState: Subscribable<Readonly<WaypointAlertStateEvent>>;
    /** @inheritDoc */
    readonly waypointAlertTime: _microsoft_msfs_sdk.NumberUnitSubject<_microsoft_msfs_sdk.UnitFamily.Duration, _microsoft_msfs_sdk.SimpleUnit<_microsoft_msfs_sdk.UnitFamily.Duration>>;
    /** @inheritDoc */
    readonly verticalTrackAlert: _microsoft_msfs_sdk.ReadonlySubEvent<void, GarminVNavTrackAlertType>;
    private isInit;
    private isAlive;
    private isPaused;
    private needUpdateTrackedLegs;
    private clockSub?;
    private readonly fplSubs;
    /**
     * Creates a new instance of DefaultNavStatusBoxDataProvider.
     * @param bus The event bus.
     * @param fms The FMS.
     * @param waypointAlertComputer The waypoint alert computer from which to source this provider's waypoint alert data.
     * @param vnavDataProvider The VNAV data provider from which to source this provider's vertical track alert data. If
     * not defined, then vertical track alert data will not be provided.
     */
    constructor(bus: EventBus, fms: Fms, waypointAlertComputer: WaypointAlertComputer, vnavDataProvider?: VNavDataProvider | undefined);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Updates this data provider.
     */
    private update;
    /**
     * Updates this provider's tracked leg information.
     */
    private updateTrackedLegs;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * A type of data field supported by the navigation status box.
 */
type NavStatusBoxFieldType = NavDataFieldType.BearingToWaypoint | NavDataFieldType.DistanceToWaypoint | NavDataFieldType.TimeToWaypoint;

/**
 * Component props for NavStatusBox.
 */
interface NavStatusBoxProps extends ComponentProps {
    /** The event bus. */
    bus: EventBus;
    /** The field types to display with the status box. */
    fieldTypes: readonly [NavStatusBoxFieldType, NavStatusBoxFieldType];
    /** A data provider for the status box. */
    dataProvider: NavStatusBoxDataProvider;
    /** The current GPS data validity state. */
    gpsValidity: Subscribable<NavDataFieldGpsValidity>;
    /** A manager for display units user settings. */
    unitsSettingManager: UnitsUserSettingManager;
    /** Whether the status box should be decluttered. */
    declutter: Subscribable<boolean>;
    /** CSS class(es) to add to the status box's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin PFD navigation status box.
 */
declare class NavStatusBox extends DisplayComponent<NavStatusBoxProps> {
    private static readonly RESERVED_CSS_CLASSES;
    private static readonly VERTICAL_TRACK_ALERT_TEXT;
    private static readonly VERTICAL_TRACK_ALERT_DURATION;
    private readonly legRef;
    private readonly rootCssClass;
    private readonly rootDisplay;
    private readonly modelFactory;
    private readonly fieldRenderer;
    private readonly fieldModels;
    private readonly fieldInstances;
    private readonly fieldDisplay;
    private readonly verticalTrackAlertDisplay;
    private readonly verticalTrackAlertText;
    private readonly verticalTrackAlertDebounceTimer;
    private readonly hideVerticalTrackAlertFunc;
    private cssClassSub?;
    private declutterSub?;
    private gpsValiditySub?;
    private verticalTrackAlertSub?;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Responds to when whether this box is decluttered changes.
     * @param declutter Whether this box is decluttered.
     */
    private onDeclutterChanged;
    /**
     * Responds to when a vertical track alert is issued.
     * @param source The source of the alert event.
     * @param type The type of alert that was issued.
     */
    private onVerticalTrackAlert;
    /**
     * Sets the visibility of this box's vertical track alert indication.
     * @param visible Whether to set the vertical track alert indication to be visible.
     */
    private setVerticalTrackAlertVisibility;
    /** @inheritDoc */
    render(): VNode;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * The props for the NavStatusBoxDtkAlert component.
 */
interface NavStatusBoxDtkAlertProps extends ComponentProps {
    /** A data provider for the alert display. */
    dataProvider: NavStatusBoxDataProvider;
    /** Whether to use magnetic bearings. */
    useMagnetic: Subscribable<boolean>;
    /** A mutable subscribable to bind to this component's active state. */
    isActive?: MutableSubscribable<boolean>;
}
/**
 * A component that alerts when the waypoint is about to change.
 */
declare class NavStatusBoxDtkAlert extends DisplayComponent<NavStatusBoxDtkAlertProps> {
    private static readonly TRUE_COURSE;
    private static readonly MAG_COURSE;
    private static readonly COURSE_FORMATTER;
    private static readonly SHOW_COURSE_STATES;
    private static readonly SHOW_TIME_STATES;
    private static readonly SHOW_NOW_STATES;
    private readonly rootStyle;
    private readonly rootCssClass;
    private readonly beforeCourseText;
    private readonly afterCourseText;
    private readonly course;
    private readonly courseUnit;
    private readonly seconds;
    private isPaused;
    private alertStateSub?;
    private courseSub?;
    private timePipe?;
    private secondsPipe?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Resumes this component. Once resumed, this component will automatically update.
     */
    resume(): void;
    /**
     * Pauses this component. This component will not update while it is paused.
     */
    pause(): void;
    /**
     * Responds to when the waypoint alert state changes.
     * @param stateEvent The alert state change event.
     */
    private onAlertStateChanged;
    /**
     * Responds to when whether to display magnetic course changes.
     * @param useMagnetic Whether to display magnetic course.
     */
    private onUseMagneticChanged;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A data model for a navigation status box field.
 */
interface NavStatusBoxFieldModel<T> extends NavDataFieldModel<T> {
    /**
     * Destroys this model.
     */
    destroy(): void;
}
/**
 * A map from navigation data field type to navigation status box field data model type.
 */
type NavStatusBoxFieldTypeModelMap = {
    [Type in NavStatusBoxFieldType]: NavStatusBoxFieldModel<NavDataFieldTypeModelMap[Type] extends NavDataFieldModel<infer T> ? T : never>;
};
/**
 * A factory which creates data models for a single type of navigation status box field.
 */
interface NavStatusBoxFieldTypeModelFactory<T extends NavStatusBoxFieldType> {
    /**
     * Creates a navigation status box field data model for this factory's data field type.
     * @param gpsValidity The subscribable that provides the validity of the GPS data for the models.
     * @returns A navigation status box field data model for this factory's data field type.
     */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavStatusBoxFieldTypeModelMap[T];
}
/**
 * A factory for navigation status box field data models.
 */
declare class NavStatusBoxFieldModelFactory implements NavStatusBoxFieldModelFactory {
    private readonly gpsValidity;
    private readonly factories;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param gpsValidity The subscribable that provides the validity of the GPS data for the models.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, gpsValidity: Subscribable<NavDataFieldGpsValidity>, lnavIndex?: number | Subscribable<number>);
    /**
     * Creates a navigation status box field data model for a given type of field.
     * @param type A navigation status box field type.
     * @returns A navigation status box field data model for the given field type.
     * @throws Error if an unsupported field type is specified.
     */
    create<T extends NavStatusBoxFieldType>(type: T): NavStatusBoxFieldTypeModelMap[T];
}
/**
 * Creates data models for Bearing to Waypoint navigation status box fields.
 */
declare class NavStatusBoxFieldBrgModelFactory implements NavStatusBoxFieldTypeModelFactory<NavDataFieldType.BearingToWaypoint> {
    private readonly bus;
    private readonly lnavIndex?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number> | undefined);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavStatusBoxFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
}
/**
 * Creates data models for Distance to Waypoint navigation status box fields.
 */
declare class NavStatusBoxFieldDisModelFactory implements NavStatusBoxFieldTypeModelFactory<NavDataFieldType.DistanceToWaypoint> {
    private readonly bus;
    private readonly lnavIndex?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number> | undefined);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavStatusBoxFieldModel<NumberUnitInterface<UnitFamily.Distance>>;
}
/**
 * Creates data models for Time To Waypoint navigation status box fields.
 */
declare class NavStatusBoxFieldEteModelFactory implements NavStatusBoxFieldTypeModelFactory<NavDataFieldType.TimeToWaypoint> {
    private readonly bus;
    private readonly lnavIndex?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, lnavIndex?: number | Subscribable<number> | undefined);
    /** @inheritDoc */
    create(gpsValidity: Subscribable<NavDataFieldGpsValidity>): NavStatusBoxFieldModel<NumberUnitInterface<UnitFamily.Duration>>;
}
/**
 * A data model for Bearing to Waypoint navigation status box fields.
 */
declare class NavStatusBoxFieldBrgModel implements NavStatusBoxFieldModel<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>> {
    readonly value: BasicNavAngleSubject;
    private readonly isLNavIndexValid;
    private readonly lnavIsTracking;
    private readonly bearing;
    private readonly magVar;
    private readonly state;
    private readonly lnavIndexSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param gpsValidity The current validity state of the GPS data for this model.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, gpsValidity: Subscribable<NavDataFieldGpsValidity>, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    destroy(): void;
}
/**
 * A data model for Distance to Waypoint navigation status box fields.
 */
declare class NavStatusBoxFieldDisModel implements NavStatusBoxFieldModel<NumberUnitInterface<UnitFamily.Distance>> {
    private static readonly PRECISION;
    readonly value: NumberUnitSubject<UnitFamily.Distance, _microsoft_msfs_sdk.SimpleUnit<UnitFamily.Distance>>;
    private readonly isLNavIndexValid;
    private readonly lnavIsTracking;
    private readonly distance;
    private readonly state;
    private readonly lnavIndexSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param gpsValidity The current validity state of the GPS data for this model.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, gpsValidity: Subscribable<NavDataFieldGpsValidity>, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    destroy(): void;
}
/**
 * A data model for Time to Waypoint navigation status box fields.
 */
declare class NavStatusBoxFieldEteModel implements NavStatusBoxFieldModel<NumberUnitInterface<UnitFamily.Duration>> {
    private static readonly PRECISION;
    readonly value: NumberUnitSubject<UnitFamily.Duration, _microsoft_msfs_sdk.SimpleUnit<UnitFamily.Duration>>;
    private readonly isLNavIndexValid;
    private readonly lnavIsTracking;
    private readonly distance;
    private readonly groundSpeed;
    private readonly state;
    private readonly lnavIndexSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param gpsValidity The current validity state of the GPS data for this model.
     * @param lnavIndex The index of the LNAV from which to source data. Defaults to `0`.
     */
    constructor(bus: EventBus, gpsValidity: Subscribable<NavDataFieldGpsValidity>, lnavIndex?: number | Subscribable<number>);
    /** @inheritDoc */
    destroy(): void;
}

/**
 * A navigation status box field renderer.
 */
declare class NavStatusBoxFieldRenderer {
    private readonly renderer;
    /**
     * Constructor.
     * @param unitsSettingManager A display units user setting manager.
     */
    constructor(unitsSettingManager: UnitsUserSettingManager);
    /** @inheritdoc */
    render<T extends NavStatusBoxFieldType>(type: T, model: NavDataFieldTypeModelMap[T]): VNode;
}

/**
 * Component props for NavStatusBoxLegArrow.
 */
interface NavStatusBoxLegArrowProps extends ComponentProps {
    /** The nominal flight plan leg which LNAV is currently tracking. */
    toLeg: Subscribable<LegDefinition | null>;
}
/**
 * A next-generation (NXi, G3000, etc) navigation status box leg arrow display.
 */
declare class NavStatusBoxLegArrow extends DisplayComponent<NavStatusBoxLegArrowProps> {
    private readonly rootStyle;
    private readonly straightStyle;
    private readonly leftStyle;
    private readonly rightStyle;
    private readonly holdLeftStyle;
    private readonly holdRightStyle;
    private readonly directStyle;
    private readonly arrowMode;
    private legSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for NavStatusBoxLegDisplay.
 */
interface NavStatusBoxLegDisplayProps extends ComponentProps {
    /** A data provider for the display. */
    dataProvider: NavStatusBoxDataProvider;
    /** A manager for display units user settings. */
    unitsSettingManager: UnitsUserSettingManager;
}
/**
 * A next-generation (NXi, G3000, etc) navigation status box flight plan leg display.
 */
declare class NavStatusBoxLegDisplay extends DisplayComponent<NavStatusBoxLegDisplayProps> {
    private static readonly HEADING_FORMATTER;
    private static readonly ALTITUDE_FORMATTER;
    private static readonly DISTANCE_FORMATTER;
    private readonly legArrowRef;
    private readonly fromLegDistanceRef;
    private readonly alertRef;
    private readonly baseStyle;
    private readonly fromLegStyle;
    private readonly fromLegTextStyle;
    private readonly fromLegAltitudeStyle;
    private readonly fromLegDistanceStyle;
    private readonly fromLegProcLeftStyle;
    private readonly fromLegProcRightStyle;
    private readonly toLegStyle;
    private readonly toLegTextStyle;
    private readonly toLegAltitudeStyle;
    private readonly toLegProcLeftStyle;
    private readonly toLegProcRightStyle;
    private readonly toLeg;
    private readonly fromLegState;
    private readonly fromLegText;
    private readonly toLegText;
    private readonly fromLegAltitude;
    private readonly toLegAltitude;
    private readonly fromLegDistance;
    private readonly useMagnetic;
    private readonly isAlertActive;
    private isPaused;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Resumes this display. Once resumed, this display will automatically update.
     */
    resume(): void;
    /**
     * Pauses this display. This display will not update while it is paused.
     */
    pause(): void;
    /**
     * Updates the to leg display.
     * @param toLeg The current to leg.
     */
    private updateToLeg;
    /**
     * Updates the from leg display.
     * @param trackedLegs The legs currently tracked by LNAV.
     * @param obsCourse The active OBS course, or `null` if OBS is inactive.
     */
    private updateFromLeg;
    /**
     * Sets and displays the text of the from leg display.
     * @param text The text to set.
     */
    private setFromLegText;
    /**
     * Gets the fix type suffix for a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The fix type suffix for the specified flight plan leg.
     */
    private getFixTypeSuffix;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for PfdTrafficAnnunciation.
 */
interface PfdTrafficAnnunciationProps extends ComponentProps {
    /** The traffic system. */
    trafficSystem: TrafficSystem;
    /** A provider of TCAS advisory data. */
    advisoryDataProvider: TcasAdvisoryDataProvider;
    /** Whether to declutter the annunciation. */
    declutter: Subscribable<boolean>;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin PFD traffic annunciation.
 */
declare class PfdTrafficAnnunciation extends DisplayComponent<PfdTrafficAnnunciationProps> {
    private static readonly FLASH_DURATION;
    private readonly rootStyle;
    private readonly rootCssClass;
    private readonly isTcasII;
    private readonly flashTimer;
    private readonly removeFlashFunc;
    private readonly text;
    private activeAlertType;
    private declutterSub?;
    private taSub?;
    private raSub?;
    private operatingModeSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Responds to when an advisory is issued or cancelled.
     * @param alertLevel The level of the changed advisory.
     * @param type The type of change: whether the advisory was added or removed.
     */
    private onAdvisoryChanged;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A data provider for a vertical deviation indicator.
 */
interface VdiDataProvider {
    /** Whether a glideslope is available. */
    readonly hasGs: Subscribable<boolean>;
    /** The current glideslope deviation. */
    readonly gsDeviation: Subscribable<number | null>;
    /** Whether the current glideslope deviation is a preview. */
    readonly gsDeviationIsPreview: Subscribable<boolean>;
    /** Whether a glidepath is available. */
    readonly hasGp: Subscribable<boolean>;
    /** The current glidepath service level. */
    readonly gpServiceLevel: Subscribable<GlidepathServiceLevel>;
    /** The current glidepath deviation. */
    readonly gpDeviation: Subscribable<number | null>;
    /** Whether the current glidepath deviation is a preview. */
    readonly gpDeviationIsPreview: Subscribable<boolean>;
    /** The current glidepath deviation scale, in feet. */
    readonly gpDeviationScale: Subscribable<number | null>;
    /** Whether a VNAV path is available. */
    readonly hasVNav: Subscribable<boolean>;
    /** The current VNAV vertical deviation. */
    readonly vnavDeviation: Subscribable<number | null>;
    /** Whether the active leg is past the final approach fix. */
    readonly isPastFaf: Subscribable<boolean>;
}

/**
 * A data provider for a vertical speed indicator.
 */
interface VsiDataProvider {
    /** The current vertical speed, in feet per minute. */
    readonly verticalSpeed: Subscribable<number>;
    /** The current selected vertical speed, in feet per minute. */
    readonly selectedVs: Subscribable<number | null>;
    /** The target VNAV altitude restriction. */
    readonly targetRestriction: Subscribable<VNavTargetAltitudeRestriction | null>;
    /** The current vertical speed required to meet the next VNAV altitude restriction, in feet per minute. */
    readonly vsRequired: Subscribable<number | null>;
    /** Whether vertical speed data is in a failure state. */
    readonly isDataFailed: Subscribable<boolean>;
}
/**
 * A default implementation of {@link VsiDataProvider}.
 */
declare class DefaultVsiDataProvider implements VsiDataProvider {
    private readonly bus;
    private readonly vnavDataProvider;
    private readonly _verticalSpeed;
    readonly verticalSpeed: Subscribable<number>;
    private readonly selectedVsSource;
    private readonly isVsHoldActive;
    private readonly _selectedVs;
    /** @inheritdoc */
    readonly selectedVs: Subscribable<number | null>;
    /** @inheritdoc */
    readonly targetRestriction: Subscribable<VNavTargetAltitudeRestriction | null>;
    /** @inheritdoc */
    readonly vsRequired: Subscribable<number | null>;
    private readonly isAltitudeDataValid;
    /** @inheritdoc */
    readonly isDataFailed: Subscribable<boolean>;
    private readonly adcIndex;
    private isInit;
    private isAlive;
    private isPaused;
    private adcIndexSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param adcIndex The index of the ADC that is the source of this provider's data.
     * @param vnavDataProvider A provider of VNAV data.
     */
    constructor(bus: EventBus, adcIndex: number | Subscribable<number>, vnavDataProvider: VNavDataProvider);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Scale options for a vertical speed indicator.
 */
type VsiScaleOptions = {
    /** The maximum absolute vertical speed representable on the indicator, in feet per minute. */
    maximum: number | Subscribable<number>;
    /** The interval between major ticks, in feet per minute. */
    majorTickInterval: number | Subscribable<number>;
    /** The number of minor ticks for each major tick. */
    minorTickFactor: number | Subscribable<number>;
};
/**
 * Component props for VerticalSpeedIndicator.
 */
interface VerticalSpeedIndicatorProps extends ComponentProps {
    /** An instance of the event bus. */
    bus: EventBus;
    /** A data provider for the indicator. */
    dataProvider: VsiDataProvider;
    /**
     * A provider of TCAS-II resolution advisory vertical speed command data. If not defined, then the indicator will
     * not display resolution advisory commands.
     */
    tcasRaCommandDataProvider?: TcasRaCommandDataProvider;
    /** Whether the indicator should be decluttered. */
    declutter: Subscribable<boolean>;
    /** Scale options for the indicator. */
    scaleOptions: VsiScaleOptions;
    /** Whether advanced vnav is enabled or not. */
    isAdvancedVnav: boolean;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin PFD vertical speed indicator.
 */
declare class VerticalSpeedIndicator extends DisplayComponent<VerticalSpeedIndicatorProps> {
    /** The amount of overdraw on the upper and lower ends of the scale, as a factor of the scale maximum. */
    private static readonly SCALE_OVERDRAW;
    /**
     * The amount of overdraw available for the vertical speed pointer on the upper and lower ends of the scale, as a
     * factor of the scale maximum.
     */
    private static readonly POINTER_OVERDRAW;
    private static readonly POINTER_POS_MIN;
    private static readonly POINTER_POS_MAX;
    private readonly minorTickContainerRef;
    private readonly majorTickContainerRef;
    private readonly labelContainerRef;
    private readonly vsPointerBugRef;
    private readonly selectedVsBugRef;
    private readonly vsRequiredBugRef;
    private readonly vnavAltDisplayRef;
    private readonly selectedVsDisplayRef;
    private readonly raColorRangeMaxStyle;
    private readonly raColorRangeMinStyle;
    private readonly raColorRangeFlyToStyle;
    private readonly rootCssClass;
    private readonly maximum;
    private readonly majorTickInterval;
    private readonly minorTickFactor;
    private readonly options;
    private readonly updateTapeEvent;
    private readonly raFlyToState;
    private readonly raVsAvoidanceState;
    private readonly showBugs;
    private readonly showDisplays;
    private isDataFailedSub?;
    private raMaxVsSub?;
    private raMinVsSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Rebuilds this tape's ticks and labels.
     * @param options Scale options for this tape, as `[minimum, maximum, window, majorTickInterval, minorTickFactor]`.
     */
    private rebuildScale;
    /**
     * Updates the color range depicting the maximum allowed vertical speed commanded by the current resolution
     * advisory.
     * @param maxVs The maximum allowed vertical speed, in feet per minute, commanded by the current resolution
     * advisory, or `null` if there is no such value.
     */
    private updateRaMaxVsColorRange;
    /**
     * Updates the color range depicting the minimum allowed vertical speed commanded by the current resolution
     * advisory.
     * @param minVs The minimum allowed vertical speed, in feet per minute, commanded by the current resolution
     * advisory, or `null` if there is no such value.
     */
    private updateRaMinVsColorRange;
    /**
     * Updates the color range depicting the fly-to command issued by the current resolution advisory.
     * @param minVs The lower bound, in feet per minute, of the current fly-to command, or `null` if there is no such
     * value.
     * @param maxVs The upper bound, in feet per minute, of the current fly-to command, or `null` if there is no such
     * value.
     */
    private updateRaFlyToVsColorRange;
    /**
     * Calculates the vertical position on this indicator's scale at which a particular vertical speed is located, with
     * `0` at the top of the scale and `1` at the bottom.
     * @param verticalSpeed A vertical speed, in feet per minute.
     * @returns The vertical position on this indicator's scale at which the specified vertical speed is located, with
     * `0` at the top of the scale and `1` at the bottom.
     */
    private calculateScalePosition;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Next-generation (NXi, G3000, etc) Garmin PFD wind display options.
 */
declare enum WindDisplayOption {
    Option1 = 1,
    Option2 = 2,
    Option3 = 3
}
/**
 * Component props for WindDisplay.
 */
interface WindDisplayProps extends ComponentProps {
    /** A provider of wind data. */
    dataProvider: WindDataProvider;
    /** The wind option to display. */
    option: Subscribable<WindDisplayOption>;
    /** A manager for display units user settings. */
    unitsSettingManager: UnitsUserSettingManager;
    /** Whether the display should be decluttered. */
    declutter: Subscribable<boolean>;
}
/**
 * A next-generation (NXi, G3000, etc) Garmin PFD wind display.
 */
declare class WindDisplay extends DisplayComponent<WindDisplayProps> {
    private readonly option1Ref;
    private readonly option2Ref;
    private readonly option3Ref;
    private readonly rootStyle;
    private readonly noDataStyle;
    private readonly rootCssClass;
    private readonly option1Declutter;
    private readonly option2Declutter;
    private readonly option3Declutter;
    private declutterSub?;
    private isDeadReckoningSub?;
    private isDataFailedSub?;
    private optionSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A manager for the PFD declutter feature. Keeps track of whether the PFD should be decluttered due to unusual
 * airplane attitudes and exposes that information as a subscribable through the `declutter` property.
 */
declare class PfdDeclutterManager {
    private readonly bus;
    private readonly _declutter;
    /** Whether the PFD should be decluttered. */
    readonly declutter: Subscribable<boolean>;
    private readonly ahrsIndex;
    private readonly pitchUpThreshold;
    private readonly pitchDownThreshold;
    private readonly rollThreshold;
    private readonly pitchUpHysteresis;
    private readonly pitchDownHysteresis;
    private readonly rollHysteresis;
    private readonly pitch;
    private readonly roll;
    private readonly isAttitudeDataValid;
    private isPitchUpOob;
    private isPitchDownOob;
    private isRollOob;
    private isAlive;
    private isInit;
    private clockSub?;
    private ahrsIndexSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param ahrsIndex The index of the AHRS that is the source of the attitude data used by this manager.
     * @param pitchUpThreshold The pitch up threshold for declutter, in degrees. Defaults to 30 degrees.
     * @param pitchDownThreshold The pitch down threshold for declutter, in degrees. Defaults to -20 degrees.
     * @param rollThreshold The roll threshold for declutter, in degrees, in either direction. Defaults to 65 degrees.
     * @param pitchUpHysteresis The hysteresis to apply for the pitch up threshold, in degrees. Defaults to 5 degrees.
     * @param pitchDownHysteresis The hysteresis to apply for the pitch down threshold, in degrees. Defaults to 5
     * degrees.
     * @param rollHysteresis The hysteresis to apply for the roll threshold, in degrees. Defaults to 5 degrees.
     */
    constructor(bus: EventBus, ahrsIndex: number | Subscribable<number>, pitchUpThreshold?: number | Subscribable<number>, pitchDownThreshold?: number | Subscribable<number>, rollThreshold?: number | Subscribable<number>, pitchUpHysteresis?: number | Subscribable<number>, pitchDownHysteresis?: number | Subscribable<number>, rollHysteresis?: number | Subscribable<number>);
    /**
     * Initializes this manager. Once initialized, this manager will automatically keep track of whether the PFD should
     * be decluttered until it is destroyed.
     * @throws Error if this manager has been destroyed.
     */
    init(): void;
    /**
     * Updates this manager.
     */
    private update;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * Types of Garmin terrain alerting systems.
 */
declare enum TerrainSystemType {
    Svt = "Svt",
    TawsA = "TawsA",
    TawsB = "TawsB"
}
/**
 * Garmin terrain alerting system operating modes.
 */
declare enum TerrainSystemOperatingMode {
    Off = "Off",
    Operating = "Operating",
    Test = "Test"
}
/**
 * Data provided by Garmin terrain alerting systems to modules.
 */
type TerrainSystemData = {
    /** The current real (operating system) time, as a Javascript timestamp. */
    realTime: number;
    /** The current sim time, as a Javascript timestamp. */
    simTime: number;
    /** The current simulation rate factor. */
    simRate: number;
    /** Whether the airplane is on the ground. */
    isOnGround: boolean;
    /**
     * The positions of the airplane's gear, as `[nose, leftMain, rightMain]`. A value of `0` indicates fully retracted,
     * and a value of `1` indicates fully extended.
     */
    gearPosition: readonly [number, number, number];
    /** The extension angles, in degrees, of the airplane's trailing edge flaps, as `[left, right]`. */
    flapsAngle: readonly [number, number];
    /** Whether the terrain system has a valid position fix. */
    isGpsPosValid: boolean;
    /** The current GPS position of the airplane. */
    gpsPos: GeoPointReadOnly;
    /** The current GPS altitude of the airplane, in feet. */
    gpsAltitude: number;
    /** The current GPS vertical speed of the airplane, in feet per minute. */
    gpsVerticalSpeed: number;
    /** The current GPS ground speed of the airplane, in knots. */
    gpsGroundSpeed: number;
    /** The elevation of the ground directly below the airplane, in feet. */
    groundElevation: number;
    /** The current GPS above ground height of the airplane, in feet. */
    gpsAgl: number;
    /** Whether the terrain system has valid radar altitude data. */
    isRadarAltitudeValid: boolean;
    /** The current radar altitude of the airplane, in feet. */
    radarAltitude: number;
    /** Whether the terrain system has valid barometric altitude data. */
    isBaroAltitudeValid: boolean;
    /** The current barometric altitude of the airplane, in feet. */
    baroAltitude: number;
    /** The current barometric vertical speed of the airplane, in feet per minute. */
    baroVerticalSpeed: number;
    /** The current barometric above ground height of the airplane, in feet. */
    baroAgl: number;
    /** Whether the terrain system has valid attitude data. */
    isAttitudeValid: boolean;
    /** Whether the terrain system has valid heading data. */
    isHeadingValid: boolean;
    /** The current true heading of the airplane, in degrees. */
    headingTrue: number;
    /** Whether the autopilot GS or GP mode is active. */
    isGsGpActive: boolean;
    /** The departure airport loaded into the FMS, or `null` if there is no such airport. */
    departureAirport: AirportFacility | null;
    /** The departure runway loaded into the FMS, or `null` if there is no such runway. */
    departureRunway: OneWayRunway | null;
    /** The destination airport loaded into the FMS, or `null` if there is no such airport. */
    destinationAirport: AirportFacility | null;
    /** The destination runway loaded into the FMS, or `null` if there is no such runway. */
    destinationRunway: OneWayRunway | null;
    /** Details of the approach loaded into the FMS. */
    approachDetails: Readonly<ApproachDetails>;
    /** The current FMS flight phase. */
    flightPhase: Readonly<FmsFlightPhase>;
    /** The current glidepath service level. */
    gpServiceLevel: GlidepathServiceLevel;
    /**
     * The current glideslope or glidepath vertical deviation for the active approach, scaled such that 1 represents
     * full-scale deviation, or `NaN` if deviation is not available. Positive deviation indicates the airplane is below
     * the glideslope/glidepath.
     */
    gsGpDeviation: number;
    /** The nearest airport within five nautical miles of the airplane, or `null` if there is no such airport. */
    nearestAirport: AirportFacility | null;
};
/**
 * A controller for alerts tracked by a Garmin terrain alerting system.
 */
interface TerrainSystemAlertController {
    /**
     * Triggers an alert.
     * @param alert The alert to trigger.
     */
    triggerAlert(alert: string): void;
    /**
     * Untriggers an alert.
     * @param alert The alert to untrigger.
     */
    untriggerAlert(alert: string): void;
    /**
     * Inhibits an alert.
     * @param alert The alert to inhibit.
     */
    inhibitAlert(alert: string): void;
    /**
     * Uninhibits an alert.
     * @param alert The alert to uninhibit.
     */
    uninhibitAlert(alert: string): void;
}

/**
 * Terrain alerting system annunciation levels.
 */
declare enum TerrainSystemAnnunciationLevel {
    Advisory = 0,
    Caution = 1,
    Warning = 2
}
/**
 * A definition describing a terrain alerting system annunciation.
 */
type TerrainSystemAnnunciationDef = {
    /** The level of the annunciation. */
    level: TerrainSystemAnnunciationLevel;
    /** The text to display for the annunciation. */
    text: string;
};
/**
 * A definition describing a terrain alerting system annunciation with an assigned priority.
 */
type TerrainSystemAnnunciationPriorityDef = TerrainSystemAnnunciationDef & {
    /**
     * The priority of the annunciation. Annunciations with higher priorities will be displayed in place of those with
     * lower priorities.
     */
    priority: number;
};
/**
 * Component props for {@link TerrainSystemAnnunciation}.
 */
interface TerrainSystemAnnunciationProps extends ComponentProps {
    /** Whether to show the display. */
    show: boolean | Subscribable<boolean>;
    /** The terrain system's operating mode. */
    operatingMode: Subscribable<TerrainSystemOperatingMode>;
    /** The terrain system's active status flags. */
    statusFlags: SubscribableSet<string>;
    /** The terrain system's active inhibit flags. */
    inhibitFlags: SubscribableSet<string>;
    /** The terrain system's prioritized active alert. */
    prioritizedAlert: Subscribable<string | null>;
    /**
     * A definition for displaying a test mode annunciation. If not defined, then an annunciation will not be displayed
     * when the terrain system is in test mode.
     */
    testModeDef?: Readonly<TerrainSystemAnnunciationDef>;
    /**
     * Definitions for displaying status flag annunciations. If a definition is not provided for a status flag, then no
     * annunciation will be displayed for that flag.
     */
    statusDefs?: Readonly<Partial<Record<string, Readonly<TerrainSystemAnnunciationPriorityDef>>>>;
    /**
     * Definitions for displaying inhibit flag annunciations. If a definition is not provided for a inhibit flag, then no
     * annunciation will be displayed for that flag.
     */
    inhibitDefs?: Readonly<Partial<Record<string, Readonly<TerrainSystemAnnunciationPriorityDef>>>>;
    /**
     * Definitions for displaying alert annunciations. If a definition is not provided for an alert, then no annunciation
     * will be displayed for that alert.
     */
    alertDefs?: Readonly<Partial<Record<string, Readonly<TerrainSystemAnnunciationDef>>>>;
    /**
     * The duration, in milliseconds, for which the flashing state is applied after a new annunciation is displayed.
     * Defaults to 5000.
     */
    flashDuration?: number;
    /** CSS class(es) to apply to the display's root element. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/**
 * A Garmin terrain alerting system annunciation display.
 */
declare class TerrainSystemAnnunciation extends DisplayComponent<TerrainSystemAnnunciationProps> {
    private static readonly RESERVED_CLASSES;
    private readonly rootCssClass;
    private readonly show;
    private readonly display;
    private readonly text;
    private readonly flashDuration;
    private readonly flashDebounceTimer;
    private readonly cancelFlashFunc;
    private readonly statusDefs;
    private readonly inhibitDefs;
    private readonly alertDefs;
    private activeDef?;
    private readonly subscriptions;
    /** @inheritDoc */
    onAfterRender(): void;
    /**
     * Updates the annunciation shown by this display.
     */
    private updateDisplay;
    /**
     * Sets this display's current annunciation level.
     * @param level The annunciation level to set.
     */
    private setAnnunciationLevel;
    /**
     * Starts a flashing cycle on this display. The display immediately enters the flashing state and will automatically
     * exit the flashing state after an amount of time equal to this display's flashing duration.
     */
    private startFlash;
    /**
     * Stops any currently active flashing cycle on this display. The display immediately exits the flashing state.
     */
    private stopFlash;
    /** @inheritDoc */
    render(): VNode;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * A utility class for generating definitions for next-generation (NXi, G3000, etc) Garmin TAWS annunciations.
 */
declare class NextGenTawsAnnunciationDefs {
    /**
     * Creates a new definition for test mode.
     * @returns A new definition for test mode.
     */
    static testMode(): TerrainSystemAnnunciationDef;
    /**
     * Creates a new record of definitions for status flags, keyed by flag.
     * @returns A new record of definitions for status flags, keyed by flag.
     */
    static status(): Partial<Record<string, Readonly<TerrainSystemAnnunciationPriorityDef>>>;
    /**
     * Creates a new record of definitions for inhibit flags, keyed by flag.
     * @returns A new record of definitions for inhibit flags, keyed by flag.
     */
    static inhibit(): Partial<Record<string, Readonly<TerrainSystemAnnunciationPriorityDef>>>;
    /**
     * Creates a new record of definitions for alerts, keyed by alert.
     * @returns A new record of definitions for alerts, keyed by alert.
     */
    static alert(): Partial<Record<string, Readonly<TerrainSystemAnnunciationDef>>>;
}

/**
 * Actions that {@link TouchButton} can take in response to being touched.
 */
declare enum TouchButtonOnTouchedAction {
    /**
     * The button becomes primed. A primed button will be pressed if and when the mouse button is released. If the mouse
     * leaves the button before the mouse button is released, the button becomes un-primed and is not pressed.
     */
    Prime = "Prime",
    /**
     * The button is immediately pressed once. The button does not enter the primed state. Holding down the mouse button
     * will not trigger additional presses.
     */
    Press = "Press",
    /**
     * The button becomes held. The button will remain held until the mouse button is released, the mouse leaves the
     * button, mouse events are inhibited by dragging, or the button becomes disabled.
     */
    Hold = "Hold",
    /** The button takes no action as if it were disabled. */
    Ignore = "Ignore"
}
/**
 * Actions that {@link TouchButton} can take while it is in the held state.
 */
declare enum TouchButtonHoldAction {
    /** The button is immediately pressed once. */
    Press = "Press",
    /** The button ends its held state. */
    EndHold = "EndHold",
    /** The button takes no specific action. */
    None = "None"
}
/**
 * Reasons for ending a {@link TouchButton}'s held state.
 */
declare enum TouchButtonHoldEndReason {
    /** The held state ended for an unknown reason. */
    Unknown = "Unknown",
    /** The held state ended because the mouse button was released. */
    MouseUp = "MouseUp",
    /** The held state ended because the mouse left the button.  */
    MouseLeave = "MouseLeave",
    /** The held state ended as a result of a hold tick action. */
    TickAction = "TickAction",
    /** The held state ended because mouse events were inhibited by dragging. */
    DragInhibit = "DragInhibit",
    /** The held state ended because the button entered the primed state. */
    Primed = "Primed",
    /** The held state ended because the button was disabled. */
    Disabled = "Disabled"
}
/**
 * Component props for TouchButton.
 */
interface TouchButtonProps extends ComponentProps {
    /**
     * Whether the button is enabled, or a subscribable which provides it. Disabled buttons cannot be touched, primed,
     * pressed, or held. Defaults to `true`.
     */
    isEnabled?: boolean | Subscribable<boolean>;
    /** Whether the button is highlighted, or a subscribable which provides it. Defaults to `false`. */
    isHighlighted?: boolean | Subscribable<boolean>;
    /** Whether the button is visible. Defaults to `true`. */
    isVisible?: boolean | Subscribable<boolean>;
    /**
     * The label for the button. Can be defined as either a static `string`, a subscribable which provides the label
     * `string`, or a VNode. If not defined, the button will not have a label.
     *
     * If the label is defined as a VNode, all first-level DisplayComponents in the VNode tree will be destroyed when
     * the button is destroyed.
     */
    label?: string | Subscribable<string> | VNode;
    /**
     * A callback function which will be called every time the button is touched (i.e. a mouse down event on the button
     * is detected). If not defined, then the button will default to entering the primed state when touched.
     * @param button The button that was touched.
     * @returns The action to take as a result of the button being touched.
     */
    onTouched?: <B extends TouchButton = TouchButton>(button: B) => TouchButtonOnTouchedAction;
    /**
     * A callback function which will be called every time the button is pressed.
     * @param button The button that was pressed.
     * @param isHeld Whether the button was held when it was pressed.
     */
    onPressed?: <B extends TouchButton = TouchButton>(button: B, isHeld: boolean) => void;
    /**
     * A function which is called when the button enters the held state. If not defined, then the button will default to
     * taking no specific action when it enters the held state.
     * @param button The button that is held.
     * @returns The action to take. Ignored if the value is equal to {@link TouchButtonHoldAction.EndHold}.
     */
    onHoldStarted?: <B extends TouchButton = TouchButton>(button: B) => TouchButtonHoldAction;
    /**
     * A function which is called every frame when the button is held. If not defined, then the button will default to
     * taking no specific action with each frame tick.
     * @param button The button that is held.
     * @param dt The elapsed time, in milliseconds, since the previous frame.
     * @param totalTime The total amount of time, in milliseconds, that the button has been held.
     * @param timeSinceLastPress The amount of time, in milliseconds, that the button has been held since the last time
     * the button was pressed as a tick action.
     * @returns The action to take.
     */
    onHoldTick?: <B extends TouchButton = TouchButton>(button: B, dt: number, totalTime: number, timeSinceLastPress: number) => TouchButtonHoldAction;
    /**
     * A function which is called when the button exits the held state.
     * @param button The button that was held.
     * @param totalHoldDuration The total amount of time, in milliseconds, that the button was held.
     * @param endReason The reason that the button exited the held state.
     */
    onHoldEnded?: <B extends TouchButton = TouchButton>(button: B, totalHoldDuration: number, endReason: TouchButtonHoldEndReason) => void;
    /**
     * Whether the button should focus all mouse events when dragging and the button is primed or held, preventing the
     * events from bubbling up to any ancestors in the DOM tree. Defaults to `false`.
     */
    focusOnDrag?: boolean;
    /**
     * Whether the button should stop responding to mouse events and instead forward them to its parent after clicking
     * and dragging for a certain distance defined by `dragThresholdPx` along the axis defined by `inhibitOnDragAxis`.
     * When mouse events are inhibited, the button cannot be primed or held. Defaults to `false`.
     */
    inhibitOnDrag?: boolean;
    /**
     * The distance, in pixels, the mouse can click and drag before the pad begins to ignore mouse events. Ignored if
     * `inhibitOnDrag` is `false`. Defaults to 40 pixels.
     */
    dragThresholdPx?: number;
    /**
     * The axis along which dragging will trigger the inhibit function. Ignored if `inhibitOnDrag` is `false`.
     * Defaults to `'both'`.
     */
    inhibitOnDragAxis?: 'x' | 'y' | 'both';
    /** A callback function which will be called when the button is destroyed. */
    onDestroy?: () => void;
    /** CSS class(es) to apply to the button's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * A touchscreen button.
 *
 * The root element of the button contains the `touch-button` CSS class by default. The root element also
 * conditionally contains the `touch-button-disabled`, `touch-button-primed`, and `touch-button-held` classes when the
 * button is disabled, primed, and held, respectively.
 *
 * The root element optionally contains a child label element with the CSS class `touch-button-label`.
 */
declare class TouchButton<P extends TouchButtonProps = TouchButtonProps> extends DisplayComponent<P> {
    protected static readonly RESERVED_CSS_CLASSES: Set<string>;
    protected readonly rootRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly cssClassSet: SetSubject<string>;
    protected readonly mouseDownListener: (e: MouseEvent) => void;
    protected readonly mouseUpListener: () => void;
    protected readonly mouseLeaveListener: (e: MouseEvent) => void;
    protected readonly mouseMoveListener: (e: MouseEvent) => void;
    protected readonly isEnabled: Subscribable<boolean> | Subscribable<false> | Subscribable<true>;
    protected readonly isHighlighted: Subscribable<boolean> | Subscribable<false> | Subscribable<true>;
    protected readonly isVisible: Subscribable<boolean> | Subscribable<false> | Subscribable<true>;
    protected readonly labelContent: string | VNode | _microsoft_msfs_sdk.MappedSubscribable<string> | undefined;
    protected isPrimed: boolean;
    protected isHeld: boolean;
    protected holdTickInterval: NodeJS.Timeout | null;
    protected lastHoldTickTime: number | undefined;
    protected totalHoldTime: number;
    protected holdTimeSinceLastPress: number;
    protected readonly holdTickFunc: () => void;
    protected isEnabledSub?: Subscription;
    protected isHighlightedSub?: Subscription;
    protected isVisibleSub?: Subscription;
    protected cssClassSub?: Subscription;
    protected readonly mouseClickPosition: Vec2;
    protected readonly currentMousePosition: Vec2;
    protected readonly focusOnDrag: boolean;
    protected readonly inhibitOnDrag: boolean;
    protected readonly dragThresholdPxActual: number;
    protected readonly inhibitOnDragAxisActual: "both" | "x" | "y";
    /** @inheritdoc */
    onAfterRender(node: VNode): void;
    /**
     * Gets this button's root HTML element.
     * @returns This button's root HTML element.
     * @throws Error if this button has not yet been rendered.
     */
    getRootElement(): HTMLElement;
    /**
     * Simulates this button being pressed. This will execute the `onPressed()` callback if one is defined.
     * @param ignoreDisabled Whether to simulate the button being pressed regardless of whether the button is disabled.
     * Defaults to `false`.
     */
    simulatePressed(ignoreDisabled?: boolean): void;
    /**
     * Sets the primed state of this button.
     * @param isPrimed The new primed state.
     */
    protected setPrimed(isPrimed: boolean): void;
    /**
     * Sets the held state of this button.
     * @param isHeld The new held state.
     * @param endReason The reason that the held state is set to `false`. Ignored if {@linkcode isHeld} is `true`.
     * Defaults to {@link TouchButtonHoldEndReason.Unknown}.
     */
    protected setHeld(isHeld: boolean, endReason?: TouchButtonHoldEndReason): void;
    /**
     * Responds to mouse down events on this button's root element.
     * @param e The mouse event.
     */
    protected onMouseDown(e: MouseEvent): void;
    /**
     * Responds to mouse up events on this button's root element.
     */
    protected onMouseUp(): void;
    /**
     * Responds to mouse leave events on this button's root element.
     * @param e The mouse event.
     */
    protected onMouseLeave(e: MouseEvent): void;
    /**
     * Handle mouse moving after clicking.
     * @param e The mouse event.
     */
    protected onMouseMove(e: MouseEvent): void;
    /**
     * Get the distance that the mouse has been dragged on the correct axis.
     * @returns The distance.
     */
    protected getDragDistance(): number;
    /**
     * Responds to when this button is pressed.
     */
    protected onPressed(): void;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Renders this button's label.
     * @returns This button's rendered label, or `null` if this button does not have a label.
     */
    protected renderLabel(): VNode | null;
    /**
     * Gets the CSS classes that are reserved for this button's root element.
     * @returns The CSS classes that are reserved for this button's root element.
     */
    protected getReservedCssClasses(): ReadonlySet<string>;
    /** @inheritdoc */
    destroy(): void;
}

/** Component props for ImgTouchButton. */
interface ImgTouchButtonProps extends TouchButtonProps {
    /** The src of the button's image. If not defined, the button will not display an image. */
    imgSrc?: string | Subscribable<string>;
}
/**
 * A touchscreen button which displays an optional label and image.
 *
 * The root element of the button contains the `touch-button-img` CSS class by default, in addition to all
 * root-element classes used by {@link TouchButton}.
 *
 * The root element contains an optional child `<img>` element with the CSS class `touch-button-img-img` and an
 * optional label element with the CSS class `touch-button-label`.
 */
declare class ImgTouchButton extends DisplayComponent<ImgTouchButtonProps> {
    protected static readonly RESERVED_CSS_CLASSES: Set<string>;
    protected readonly buttonRef: _microsoft_msfs_sdk.NodeReference<TouchButton<TouchButtonProps>>;
    protected readonly cssClassSet: SetSubject<string>;
    protected readonly imgSrc: _microsoft_msfs_sdk.MappedSubscribable<string> | undefined;
    protected cssClassSub?: Subscription;
    /**
     * Gets this button's root HTML element.
     * @returns This button's root HTML element.
     * @throws Error if this button has not yet been rendered.
     */
    getRootElement(): HTMLElement;
    /**
     * Simulates this button being pressed. This will execute the `onPressed()` callback if one is defined.
     * @param ignoreDisabled Whether to simulate the button being pressed regardless of whether the button is disabled.
     * Defaults to `false`.
     */
    simulatePressed(ignoreDisabled?: boolean): void;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Renders this button's image.
     * @returns This button's rendered image, or `null` if this button does not have an image.
     */
    protected renderImg(): VNode | null;
    /**
     * Gets the CSS classes that are reserved for this button's root element.
     * @returns The CSS classes that are reserved for this button's root element.
     */
    protected getReservedCssClasses(): ReadonlySet<string>;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for SetValueTouchButton.
 */
interface SetValueTouchButtonProps<S extends MutableSubscribable<any>> extends Omit<TouchButtonProps, 'onTouched' | 'onPressed' | 'onHoldStarted' | 'onHoldTick' | 'onHoldEnded'> {
    /** A mutable subscribable whose state will be bound to the button. */
    state: S;
    /** A subscribable which provides the value that the button sets. */
    setValue: SubscribableType<S> | Subscribable<SubscribableType<S>>;
    /**
     * A callback function which will be called every time the button is touched (i.e. a mouse down event on the button
     * is detected). If not defined, then the button will default to entering the primed state when touched.
     * @param button The button that was touched.
     * @param state The state that is bound to the button.
     * @param setValue The value that the button sets.
     * @returns The action to take as a result of the button being touched.
     */
    onTouched?: <B extends SetValueTouchButton<S> = SetValueTouchButton<S>>(button: B, state: S, setValue: SubscribableType<S>) => TouchButtonOnTouchedAction;
    /**
     * A callback function which will be called when the button is pressed. If not defined, pressing the button will
     * apply the button's set value to its bound state.
     * @param button The button that was pressed.
     * @param state The state that is bound to the button.
     * @param setValue The value that the button sets.
     * @param isHeld Whether the button was held when it was pressed.
     */
    onPressed?: <B extends SetValueTouchButton<S> = SetValueTouchButton<S>>(button: B, state: S, setValue: SubscribableType<S>, isHeld: boolean) => void;
    /**
     * A function which is called when the button enters the held state. If not defined, then the button will default to
     * taking no specific action when it enters the held state.
     * @param button The button that is held.
     * @param state The state that is bound to the button.
     * @param setValue The value that the button sets.
     * @returns The action to take. Ignored if the value is equal to {@link TouchButtonHoldAction.EndHold}.
     */
    onHoldStarted?: <B extends SetValueTouchButton<S> = SetValueTouchButton<S>>(button: B, state: S, setValue: SubscribableType<S>) => TouchButtonHoldAction;
    /**
     * A function which is called every frame when the button is held. If not defined, then the button will default to
     * taking no specific action with each frame tick.
     * @param button The button that is held.
     * @param state The state that is bound to the button.
     * @param setValue The value that the button sets.
     * @param dt The elapsed time, in milliseconds, since the previous frame.
     * @param totalTime The total amount of time, in milliseconds, that the button has been held.
     * @param timeSinceLastPress The amount of time, in milliseconds, that the button has been held since the last time
     * the button was pressed as a tick action.
     * @returns The action to take.
     */
    onHoldTick?: <B extends SetValueTouchButton<S> = SetValueTouchButton<S>>(button: B, state: S, setValue: SubscribableType<S>, dt: number, totalTime: number, timeSinceLastPress: number) => TouchButtonHoldAction;
    /**
     * A function which is called when the button exits the held state.
     * @param button The button that was held.
     * @param state The state that is bound to the button.
     * @param setValue The value that the button sets.
     * @param totalHoldDuration The total amount of time, in milliseconds, that the button was held.
     * @param endReason The reason that the button exited the held state.
     */
    onHoldEnded?: <B extends SetValueTouchButton<S> = SetValueTouchButton<S>>(button: B, state: S, setValue: SubscribableType<S>, totalHoldDuration: number, endReason: TouchButtonHoldEndReason) => void;
}
/**
 * A touchscreen button which displays whether the value of a bound state is equal to a set value. By default, pressing
 * the button will apply its set value to the state. This behavior can be overridden by providing a custom callback
 * function which runs when the button is pressed.
 *
 * The root element of the button contains the `touch-button-set-value` CSS class by default, in addition to all
 * root-element classes used by {@link TouchButton}.
 *
 * The root element contains a child {@link ToggleStatusBar} component with the CSS class
 * `touch-button-set-value-status-bar` and an optional label element with the CSS class `touch-button-label`.
 */
declare class SetValueTouchButton<S extends MutableSubscribable<any>> extends DisplayComponent<SetValueTouchButtonProps<S>> {
    protected static readonly RESERVED_CSS_CLASSES: Set<string>;
    protected readonly buttonRef: _microsoft_msfs_sdk.NodeReference<TouchButton<TouchButtonProps>>;
    protected readonly statusBarRef: _microsoft_msfs_sdk.NodeReference<ToggleStatusBar>;
    protected readonly cssClassSet: SetSubject<string>;
    protected readonly setValue: Subscribable<SubscribableType<S>>;
    protected readonly toggleState: MappedSubject<[any, SubscribableType<S>], boolean>;
    protected cssClassSub?: Subscription;
    /**
     * Gets this button's root HTML element.
     * @returns This button's root HTML element.
     * @throws Error if this button has not yet been rendered.
     */
    getRootElement(): HTMLElement;
    /**
     * Simulates this button being pressed. This will execute the `onPressed()` callback if one is defined.
     * @param ignoreDisabled Whether to simulate the button being pressed regardless of whether the button is disabled.
     * Defaults to `false`.
     */
    simulatePressed(ignoreDisabled?: boolean): void;
    /**
     * Responds to when this button is touched.
     * @param button The button that was touched.
     * @returns The action to take as a result of the button being touched.
     */
    protected onTouched(button: TouchButton): TouchButtonOnTouchedAction;
    /**
     * Responds to when this button is pressed.
     * @param button The button that was pressed.
     * @param isHeld Whether the button was held when it was pressed.
     */
    protected onPressed(button: TouchButton, isHeld: boolean): void;
    /**
     * Responds to when this button enters the held state.
     * @param button The button that is held.
     * @returns The action to take. Ignored if the value is equal to {@link TouchButtonHoldAction.EndHold}.
     */
    protected onHoldStarted(button: TouchButton): TouchButtonHoldAction;
    /**
     * A callback which is called every frame when this button is held.
     * @param button The button that is held.
     * @param dt The elapsed time, in milliseconds, since the previous frame.
     * @param totalTime The total amount of time, in milliseconds, that this button has been held.
     * @param timeSinceLastPress The amount of time, in milliseconds, that this button has been held since the last time
     * the button was pressed as a tick action.
     * @returns The action to take.
     */
    protected onHoldTick(button: TouchButton, dt: number, totalTime: number, timeSinceLastPress: number): TouchButtonHoldAction;
    /**
     * Responds to when this button exits the held state.
     * @param button The button that was held.
     * @param totalHoldDuration The total amount of time, in milliseconds, that this button was held.
     * @param endReason The reason that this button exited the held state.
     */
    protected onHoldEnded(button: TouchButton, totalHoldDuration: number, endReason: TouchButtonHoldEndReason): void;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Gets the CSS classes that are reserved for this button's root element.
     * @returns The CSS classes that are reserved for this button's root element.
     */
    protected getReservedCssClasses(): ReadonlySet<string>;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for ToggleTouchButton.
 */
interface ToggleTouchButtonProps<S extends Subscribable<boolean> | MutableSubscribable<boolean>> extends Omit<TouchButtonProps, 'onTouched' | 'onPressed' | 'onHoldStarted' | 'onHoldTick' | 'onHoldEnded'> {
    /** A subscribable whose state will be bound to the button. */
    state: S;
    /**
     * A callback function which will be called every time the button is touched (i.e. a mouse down event on the button
     * is detected). If not defined, then the button will default to entering the primed state when touched.
     * @param button The button that was touched.
     * @param state The state that is bound to the button.
     * @returns The action to take as a result of the button being touched.
     */
    onTouched?: <B extends ToggleTouchButton<S> = ToggleTouchButton<S>>(button: B, state: S) => TouchButtonOnTouchedAction;
    /**
     * A callback function which will be called when the button is pressed. If not defined, pressing the button will
     * toggle its bound state if the state is mutable.
     * @param button The button that was pressed.
     * @param state The state that is bound to the button.
     * @param isHeld Whether the button was held when it was pressed.
     */
    onPressed?: <B extends ToggleTouchButton<S> = ToggleTouchButton<S>>(button: B, state: S, isHeld: boolean) => void;
    /**
     * A function which is called when the button enters the held state. If not defined, then the button will default to
     * taking no specific action when it enters the held state.
     * @param button The button that is held.
     * @param state The state that is bound to the button.
     * @returns The action to take. Ignored if the value is equal to {@link TouchButtonHoldAction.EndHold}.
     */
    onHoldStarted?: <B extends ToggleTouchButton<S> = ToggleTouchButton<S>>(button: B, state: S) => TouchButtonHoldAction;
    /**
     * A function which is called every frame when the button is held. If not defined, then the button will default to
     * taking no specific action with each frame tick.
     * @param button The button that is held.
     * @param state The state that is bound to the button.
     * @param dt The elapsed time, in milliseconds, since the previous frame.
     * @param totalTime The total amount of time, in milliseconds, that the button has been held.
     * @param timeSinceLastPress The amount of time, in milliseconds, that the button has been held since the last time
     * the button was pressed as a tick action.
     * @returns The action to take.
     */
    onHoldTick?: <B extends ToggleTouchButton<S> = ToggleTouchButton<S>>(button: B, state: S, dt: number, totalTime: number, timeSinceLastPress: number) => TouchButtonHoldAction;
    /**
     * A function which is called when the button exits the held state.
     * @param button The button that was held.
     * @param state The state that is bound to the button.
     * @param totalHoldDuration The total amount of time, in milliseconds, that the button was held.
     * @param endReason The reason that the button exited the held state.
     */
    onHoldEnded?: <B extends ToggleTouchButton<S> = ToggleTouchButton<S>>(button: B, state: S, totalHoldDuration: number, endReason: TouchButtonHoldEndReason) => void;
}
/**
 * A touchscreen button which displays the value of a bound boolean state. By default, pressing the button will toggle
 * its state if the state is mutable. This behavior can be overridden by providing a custom callback function which
 * runs when the button is pressed.
 *
 * The root element of the button contains the `touch-button-toggle` CSS class by default, in addition to all
 * root-element classes used by {@link TouchButton}.
 *
 * The root element contains a child {@link ToggleStatusBar} component with the CSS class
 * `touch-button-toggle-status-bar` and an optional label element with the CSS class `touch-button-label`.
 */
declare class ToggleTouchButton<S extends Subscribable<boolean> | MutableSubscribable<boolean>> extends DisplayComponent<ToggleTouchButtonProps<S>> {
    protected static readonly RESERVED_CSS_CLASSES: Set<string>;
    protected readonly buttonRef: _microsoft_msfs_sdk.NodeReference<TouchButton<TouchButtonProps>>;
    protected readonly statusBarRef: _microsoft_msfs_sdk.NodeReference<ToggleStatusBar>;
    protected readonly cssClassSet: SetSubject<string>;
    protected cssClassSub?: Subscription;
    /**
     * Gets this button's root HTML element.
     * @returns This button's root HTML element.
     * @throws Error if this button has not yet been rendered.
     */
    getRootElement(): HTMLElement;
    /**
     * Simulates this button being pressed. This will execute the `onPressed()` callback if one is defined.
     * @param ignoreDisabled Whether to simulate the button being pressed regardless of whether the button is disabled.
     * Defaults to `false`.
     */
    simulatePressed(ignoreDisabled?: boolean): void;
    /**
     * Responds to when this button is touched.
     * @param button The button that was touched.
     * @returns The action to take as a result of the button being touched.
     */
    protected onTouched(button: TouchButton): TouchButtonOnTouchedAction;
    /**
     * Responds to when this button is pressed.
     * @param button The button that was pressed.
     * @param isHeld Whether the button was held when it was pressed.
     */
    protected onPressed(button: TouchButton, isHeld: boolean): void;
    /**
     * Responds to when this button enters the held state.
     * @param button The button that is held.
     * @returns The action to take. Ignored if the value is equal to {@link TouchButtonHoldAction.EndHold}.
     */
    protected onHoldStarted(button: TouchButton): TouchButtonHoldAction;
    /**
     * A callback which is called every frame when this button is held.
     * @param button The button that is held.
     * @param dt The elapsed time, in milliseconds, since the previous frame.
     * @param totalTime The total amount of time, in milliseconds, that this button has been held.
     * @param timeSinceLastPress The amount of time, in milliseconds, that this button has been held since the last time
     * the button was pressed as a tick action.
     * @returns The action to take.
     */
    protected onHoldTick(button: TouchButton, dt: number, totalTime: number, timeSinceLastPress: number): TouchButtonHoldAction;
    /**
     * Responds to when this button exits the held state.
     * @param button The button that was held.
     * @param totalHoldDuration The total amount of time, in milliseconds, that this button was held.
     * @param endReason The reason that this button exited the held state.
     */
    protected onHoldEnded(button: TouchButton, totalHoldDuration: number, endReason: TouchButtonHoldEndReason): void;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Gets the CSS classes that are reserved for this button's root element.
     * @returns The CSS classes that are reserved for this button's root element.
     */
    protected getReservedCssClasses(): ReadonlySet<string>;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for ValueTouchButton.
 */
interface ValueTouchButtonProps<S extends Subscribable<any>> extends Omit<TouchButtonProps, 'onTouched' | 'onPressed' | 'onHoldStarted' | 'onHoldTick' | 'onHoldEnded'> {
    /** A subscribable whose state will be bound to the button. */
    state: S;
    /**
     * A function which renders the value of the button's bound state, or a {@link VNode} which renders the value. If not
     * defined, values are rendered into strings via default `toString()` behavior.
     *
     * If the rendered value is a VNode, all first-level DisplayComponents in the VNode tree will be destroyed when a new
     * value is rendered or when the button is destroyed.
     */
    renderValue?: ((stateValue: SubscribableType<S>) => string | VNode) | VNode;
    /**
     * A callback function which will be called every time the button is touched (i.e. a mouse down event on the button
     * is detected). If not defined, then the button will default to entering the primed state when touched.
     * @param button The button that was touched.
     * @param state The state that is bound to the button.
     * @returns The action to take as a result of the button being touched.
     */
    onTouched?: <B extends ValueTouchButton<S> = ValueTouchButton<S>>(button: B, state: S) => TouchButtonOnTouchedAction;
    /**
     * A callback function which will be called every time the button is pressed.
     * @param button The button that was pressed.
     * @param state The state that is bound to the button.
     * @param isHeld Whether the button was held when it was pressed.
     */
    onPressed?: <B extends ValueTouchButton<S> = ValueTouchButton<S>>(button: B, state: S, isHeld: boolean) => void;
    /**
     * A function which is called when the button enters the held state. If not defined, then the button will default to
     * taking no specific action when it enters the held state.
     * @param button The button that is held.
     * @param state The state that is bound to the button.
     * @returns The action to take. Ignored if the value is equal to {@link TouchButtonHoldAction.EndHold}.
     */
    onHoldStarted?: <B extends ValueTouchButton<S> = ValueTouchButton<S>>(button: B, state: S) => TouchButtonHoldAction;
    /**
     * A function which is called every frame when the button is held. If not defined, then the button will default to
     * taking no specific action with each frame tick.
     * @param button The button that is held.
     * @param state The state that is bound to the button.
     * @param dt The elapsed time, in milliseconds, since the previous frame.
     * @param totalTime The total amount of time, in milliseconds, that the button has been held.
     * @param timeSinceLastPress The amount of time, in milliseconds, that the button has been held since the last time
     * the button was pressed as a tick action.
     * @returns The action to take.
     */
    onHoldTick?: <B extends ValueTouchButton<S> = ValueTouchButton<S>>(button: B, state: S, dt: number, totalTime: number, timeSinceLastPress: number) => TouchButtonHoldAction;
    /**
     * A function which is called when the button exits the held state.
     * @param button The button that was held.
     * @param state The state that is bound to the button.
     * @param totalHoldDuration The total amount of time, in milliseconds, that the button was held.
     * @param endReason The reason that the button exited the held state.
     */
    onHoldEnded?: <B extends ValueTouchButton<S> = ValueTouchButton<S>>(button: B, state: S, totalHoldDuration: number, endReason: TouchButtonHoldEndReason) => void;
}
/**
 * A touchscreen button which displays the value of a bound state.
 *
 * The root element of the button contains the `touch-button-value` CSS class by default, in addition to all
 * root-element classes used by {@link TouchButton}.
 *
 * The value of the button's bound state is rendered into a child `div` element containing the CSS class
 * `touch-button-value-value`.
 */
declare class ValueTouchButton<S extends Subscribable<any>> extends DisplayComponent<ValueTouchButtonProps<S>> {
    protected static readonly RESERVED_CSS_CLASSES: Set<string>;
    protected readonly buttonRef: _microsoft_msfs_sdk.NodeReference<TouchButton<TouchButtonProps>>;
    protected readonly valueRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly cssClassSet: SetSubject<string>;
    protected renderedValue?: string | VNode;
    private cssClassSub?;
    private stateSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Gets this button's root HTML element.
     * @returns This button's root HTML element.
     * @throws Error if this button has not yet been rendered.
     */
    getRootElement(): HTMLElement;
    /**
     * Simulates this button being pressed. This will execute the `onPressed()` callback if one is defined.
     * @param ignoreDisabled Whether to simulate the button being pressed regardless of whether the button is disabled.
     * Defaults to `false`.
     */
    simulatePressed(ignoreDisabled?: boolean): void;
    /**
     * Processes a newly rendered value. The new rendered value will rendered into this button's value container,
     * replacing any existing rendered value.
     * @param rendered The newly rendered value.
     */
    protected processRenderedValue(rendered: string | VNode): void;
    /**
     * Cleans up this button's rendered value.
     */
    protected cleanUpRenderedValue(): void;
    /**
     * Responds to when this button is touched.
     * @param button The button that was touched.
     * @returns The action to take as a result of the button being touched.
     */
    protected onTouched(button: TouchButton): TouchButtonOnTouchedAction;
    /**
     * Responds to when this button is pressed.
     * @param button The button that was pressed.
     * @param isHeld Whether the button was held when it was pressed.
     */
    protected onPressed(button: TouchButton, isHeld: boolean): void;
    /**
     * Responds to when this button enters the held state.
     * @param button The button that is held.
     * @returns The action to take. Ignored if the value is equal to {@link TouchButtonHoldAction.EndHold}.
     */
    protected onHoldStarted(button: TouchButton): TouchButtonHoldAction;
    /**
     * A callback which is called every frame when this button is held.
     * @param button The button that is held.
     * @param dt The elapsed time, in milliseconds, since the previous frame.
     * @param totalTime The total amount of time, in milliseconds, that this button has been held.
     * @param timeSinceLastPress The amount of time, in milliseconds, that this button has been held since the last time
     * the button was pressed as a tick action.
     * @returns The action to take.
     */
    protected onHoldTick(button: TouchButton, dt: number, totalTime: number, timeSinceLastPress: number): TouchButtonHoldAction;
    /**
     * Responds to when this button exits the held state.
     * @param button The button that was held.
     * @param totalHoldDuration The total amount of time, in milliseconds, that this button was held.
     * @param endReason The reason that this button exited the held state.
     */
    protected onHoldEnded(button: TouchButton, totalHoldDuration: number, endReason: TouchButtonHoldEndReason): void;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Renders this button's value container.
     * @returns This button's rendered value container.
     */
    protected renderValueContainer(): VNode;
    /**
     * Gets the CSS classes that are reserved for this button's root element.
     * @returns The CSS classes that are reserved for this button's root element.
     */
    protected getReservedCssClasses(): ReadonlySet<string>;
    /** @inheritdoc */
    destroy(): void;
}

/** Component props for BgImgTouchButton */
interface BgImgTouchButtonProps extends TouchButtonProps {
    /** The src of the button's "up" state background image. If not defined, the button will not display an image. */
    upImgSrc?: string | Subscribable<string>;
    /** The src of the button's "down" state background image. If not defined, the button will not display an image. */
    downImgSrc?: string | Subscribable<string>;
}
/**
 * A touchscreen button which uses different images for its "up" state and "down" state backgrounds and displays an optional label.
 *
 * The root element of the button contains the `bg-img-touch-button` CSS class by default, in addition to all
 * root-element classes used by {@link TouchButton}, with the exception of `touch-button` itself.
 *
 * The root element contains optional child `<img>` elements with the CSS classes `bg-img-touch-button-up-img` and
 * `bg-img-touch-button-down-img` as well as an optional label element with the CSS class `bg-img-touch-button-label`.
 */
declare class BgImgTouchButton extends TouchButton<BgImgTouchButtonProps> {
    protected static readonly RESERVED_CSS_CLASSES: Set<string>;
    protected readonly cssClassSet: SetSubject<string>;
    protected readonly upImgSrc: _microsoft_msfs_sdk.MappedSubscribable<string> | undefined;
    protected readonly downImgSrc: _microsoft_msfs_sdk.MappedSubscribable<string> | undefined;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for TouchPad.
 */
interface TouchPadProps extends ComponentProps {
    /**
     * The event bus. If defined, the touch pad will end drag motions when the mouse leaves the instrument window,
     * including when focus is locked. Requires the `vc_mouse_leave` topic from {@link InstrumentEvents} to be published
     * to the event bus.
     */
    bus?: EventBus;
    /**
     * A function which is called when a drag motion starts.
     * @param position The current position of the mouse.
     * @param pad The pad.
     */
    onDragStarted?: <T extends TouchPad = TouchPad>(position: ReadonlyFloat64Array, pad: T) => void;
    /**
     * A function which is called when the mouse is moved during a drag motion.
     * @param position The current position of the mouse.
     * @param prevPosition The position of the mouse at the previous update.
     * @param initialPosition The position of the mouse at the start of the current drag motion.
     * @param pad The pad.
     */
    onDragMoved?: <T extends TouchPad = TouchPad>(position: ReadonlyFloat64Array, prevPosition: ReadonlyFloat64Array, initialPosition: ReadonlyFloat64Array, pad: T) => void;
    /**
     * A function which is called every frame when a drag motion is active.
     * @param position The current position of the mouse.
     * @param prevPosition The position of the mouse during the previous frame, or `undefined` if this is the first frame
     * since the start of the current drag motion.
     * @param initialPosition The position of the mouse at the start of the current drag motion.
     * @param dt The elapsed time, in milliseconds, since the previous frame.
     * @param pad The pad.
     */
    onDragTick?: <T extends TouchPad = TouchPad>(position: ReadonlyFloat64Array, prevPosition: ReadonlyFloat64Array | undefined, initialPosition: ReadonlyFloat64Array, dt: number, pad: T) => void;
    /**
     * A function which is called when a drag motion ends.
     * @param position The current position of the mouse.
     * @param initialPosition The position of the mouse at the start of the drag motion.
     * @param pad The pad.
     */
    onDragEnded?: <T extends TouchPad = TouchPad>(position: ReadonlyFloat64Array, initialPosition: ReadonlyFloat64Array, pad: T) => void;
    /**
     * Whether the pad is enabled, or a subscribable which provides it. Disabled touchpads cannot be interacted with.
     * Defaults to `true`.
     */
    isEnabled?: boolean | Subscribable<boolean>;
    /** Whether the pad is visible. Defaults to `true`. */
    isVisible?: boolean | Subscribable<boolean>;
    /**
     * Whether the pad should focus all mouse events when dragging, preventing them from bubbling up to any ancestors
     * in the DOM tree. Defaults to `false`.
     */
    focusOnDrag?: boolean;
    /**
     * Whether the pad should lock focus when dragging, consuming mouse events for the entire document window instead
     * of just the pad's root element and disabling the inhibit function. Defaults to `false`.
     */
    lockFocusOnDrag?: boolean;
    /**
     * The axis along which dragging will trigger the lock focus function. Ignored if `lockFocusOnDrag` is `false`.
     * Defaults to `'both'`.
     */
    lockFocusOnDragAxis?: 'x' | 'y' | 'both';
    /**
     * The distance, in pixels, the mouse must click and drag before the pad locks focus. Ignored if `lockFocusOnDrag` is
     * `false`. Defaults to 0 pixels.
     */
    dragLockFocusThresholdPx?: number;
    /**
     * Whether the pad should stop responding to mouse events and instead forward them to its parent after clicking
     * and dragging for a certain distance defined by `dragInhibitThresholdPx` along the axis defined by
     * `inhibitOnDragAxis`. The inhibit function is disabled when focus is locked. Defaults to `false`.
     */
    inhibitOnDrag?: boolean;
    /**
     * The axis along which dragging will trigger the inhibit function. Ignored if `inhibitOnDrag` is `false`.
     * Defaults to `'both'`.
     */
    inhibitOnDragAxis?: 'x' | 'y' | 'both';
    /**
     * The distance, in pixels, the mouse can click and drag before the pad begins to ignore mouse events. Ignored if
     * `inhibitOnDrag` is `false`. Defaults to 40 pixels.
     */
    dragInhibitThresholdPx?: number;
    /** A callback function which will be called when the pad is destroyed. */
    onDestroy?: () => void;
    /** CSS class(es) to apply to the pad's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * A touchscreen pad which tracks mouse drag motions.
 */
declare class TouchPad<P extends TouchPadProps = TouchPadProps> extends DisplayComponent<P> {
    protected static readonly DEFAULT_SNAP_ANIMATION_EASING: (start: number, stop: number, progress: number) => number;
    protected static readonly RESERVED_CSS_CLASSES: Set<string>;
    protected readonly rootRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly sliderContainerRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly sliderThumbRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly rootCssClass: SetSubject<string>;
    protected readonly mouseDownListener: (e: MouseEvent) => void;
    protected readonly mouseUpListener: () => void;
    protected readonly mouseLeaveListener: (e?: MouseEvent) => void;
    protected readonly mouseMoveListener: (e: MouseEvent) => void;
    protected readonly isEnabled: Subscribable<boolean> | Subscribable<false> | Subscribable<true>;
    protected readonly isVisible: Subscribable<boolean> | Subscribable<false> | Subscribable<true>;
    protected isPrimed: boolean;
    protected isFocusLocked: boolean;
    protected readonly mouseDownPosition: Float64Array;
    protected readonly prevMousePosition: Float64Array;
    protected readonly currentMousePosition: Float64Array;
    protected readonly focusOnDrag: boolean;
    protected readonly lockFocusOnDrag: boolean;
    protected readonly lockFocusOnDragAxis: "both" | "x" | "y";
    protected readonly dragLockFocusThresholdPx: number;
    protected readonly inhibitOnDrag: boolean;
    protected readonly inhibitOnDragAxis: "both" | "x" | "y";
    protected readonly dragInhibitThresholdPx: number;
    protected tickInterval: NodeJS.Timeout | null;
    protected lastTickTime: number | undefined;
    protected readonly lastTickMousePosition: Float64Array;
    protected readonly tickFunc: () => void;
    protected cssClassSub?: Subscription;
    protected isEnabledSub?: Subscription;
    protected isVisibleSub?: Subscription;
    protected instrumentMouseLeaveSub?: Subscription;
    /** @inheritdoc */
    onAfterRender(node: VNode): void;
    /**
     * Sets the primed state of this pad.
     * @param isPrimed The new primed state.
     */
    protected setPrimed(isPrimed: boolean): void;
    /**
     * Sets the focus lock state of this pad.
     * @param isFocusLocked The new focus lock state.
     */
    protected setFocusLocked(isFocusLocked: boolean): void;
    /**
     * Responds to mouse down events on this pad's root element.
     * @param e The mouse event.
     */
    protected onMouseDown(e: MouseEvent): void;
    /**
     * Responds to mouse up events.
     */
    protected onMouseUp(): void;
    /**
     * Responds to mouse leave events.
     * @param e The mouse event, or `undefined` if the mouse left the instrument window.
     */
    protected onMouseLeave(e?: MouseEvent): void;
    /**
     * Responds to mouse move events.
     * @param e The mouse event.
     */
    protected onMouseMove(e: MouseEvent): void;
    /**
     * Get the distance that the mouse has been dragged along an axis relative to an initial position.
     * @param axis The axis along which to measure the distance.
     * @param initialPos The initial mouse position.
     * @returns The distance that the mouse has been dragged along the specified axis relative to the specified initial
     * position.
     */
    protected getDragDistance(axis: 'x' | 'y' | 'both', initialPos: ReadonlyFloat64Array): number;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Gets the CSS classes that are reserved for this pad's root element.
     * @returns The CSS classes that are reserved for this pad's root element.
     */
    protected getReservedCssClasses(): ReadonlySet<string>;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for TouchSlider.
 */
interface TouchSliderProps<S extends Subscribable<number> | MutableSubscribable<number>> extends ComponentProps {
    /**
     * The event bus. If defined, the mouse drags on the slider will end when the mouse leaves the instrument window,
     * including when focus is locked.
     */
    bus?: EventBus;
    /** The orientation of the slider's main axis. */
    orientation: 'to-left' | 'to-right' | 'to-top' | 'to-bottom';
    /** A subscribable whose state will be bound to the slider's value. */
    state: S;
    /**
     * An array of stops on the slider, defined as values in the range `[0, 1]`. The slider will snap to each stop. If
     * not defined or is equal to the empty array, then the slider will be able to take any value in the range `[0, 1]`.
     */
    stops?: readonly number[] | Subscribable<readonly number[]>;
    /**
     * Whether to change the slider's value immediately when dragging. If `false`, the slider's value will only be
     * changed when dragging stops. Defaults to `false`.
     */
    changeValueOnDrag?: boolean;
    /**
     * A function which is called when the slider's value changes from user input. If this function is not defined and
     * the slider's bound state is a mutable subscribable, the new value will be automatically written to the bound state.
     * @param value The new slider value.
     * @param state The slider's bound state.
     * @param slider The slider.
     */
    onValueChanged?: <T extends TouchSlider<S> = TouchSlider<S>>(value: number, state: S, slider: T) => void;
    /**
     * A function which is called when a drag motion starts.
     * @param position The current position of the mouse.
     * @param slider The slider.
     */
    onDragStarted?: <T extends TouchSlider<S> = TouchSlider<S>>(position: ReadonlyFloat64Array, slider: T) => void;
    /**
     * A function which is called when the mouse is moved during a drag motion.
     * @param position The current position of the mouse.
     * @param prevPosition The position of the mouse at the previous update.
     * @param initialPosition The position of the mouse at the start of the current drag motion.
     * @param slider The slider.
     */
    onDragMoved?: <T extends TouchSlider<S> = TouchSlider<S>>(position: ReadonlyFloat64Array, prevPosition: ReadonlyFloat64Array, initialPosition: ReadonlyFloat64Array, slider: T) => void;
    /**
     * A function which is called when a drag motion ends.
     * @param position The current position of the mouse.
     * @param initialPosition The position of the mouse at the start of the drag motion.
     * @param slider The slider.
     */
    onDragEnded?: <T extends TouchSlider<S> = TouchSlider<S>>(position: ReadonlyFloat64Array, initialPosition: ReadonlyFloat64Array, slider: T) => void;
    /**
     * Whether the slider is enabled, or a subscribable which provides it. Disabled sliders cannot be interacted with.
     * Defaults to `true`.
     */
    isEnabled?: boolean | Subscribable<boolean>;
    /** Whether the slider is visible. Defaults to `true`. */
    isVisible?: boolean | Subscribable<boolean>;
    /**
     * The background for the slider, as a VNode. The background is visible along the area of the slider corresponding
     * to values greater than the slider's current value.
     */
    background?: VNode;
    /**
     * The foreground for the slider, as a VNode. The foreground is visible along the area of the slider corresponding
     * to values less than the slider's current value.
     */
    foreground?: VNode;
    /**
     * The inset for the slider, as a VNode. The inset is placed above the background and foreground and below the
     * thumb and is always visible.
     */
    inset?: VNode;
    /**
     * The thumb for the slider, as a VNode. The thumb is placed at the location along the slider corresponding to the
     * slider's current value.
     */
    thumb?: VNode;
    /**
     * The speed of the animation when snapping to a stop, in units of slider value per second. A speed of zero will
     * result in no animation. Defaults to zero.
     */
    snapAnimationSpeed?: number | Subscribable<number>;
    /** The easing function to apply to the snapping-to-stop animation. Defaults to a cubic ease-out function. */
    snapAnimationEasing?: AnimatorEasingFunc;
    /**
     * Whether the slider should focus all mouse events when dragging, preventing them from bubbling up to any ancestors
     * in the DOM tree. Defaults to `false`.
     */
    focusOnDrag?: boolean;
    /**
     * Whether the slider should lock focus when dragging, consuming mouse events for the entire document window instead
     * of just the slider's root element and disabling the inhibit function. Defaults to `false`.
     */
    lockFocusOnDrag?: boolean;
    /**
     * The distance along the slider's main axis, in pixels, the mouse must click and drag before the slider locks focus.
     * Ignored if `lockFocusOnDrag` is `false`. Defaults to 10 pixels.
     */
    dragLockFocusThresholdPx?: number;
    /**
     * Whether the slider should stop responding to mouse events and instead forward them to its parent after clicking
     * and dragging for a certain distance defined by `dragThresholdPx` along the slider's cross-axis. The inhibit
     * function is disabled when focus is locked. Defaults to `false`.
     */
    inhibitOnDrag?: boolean;
    /**
     * The distance along the slider's cross-axis, in pixels, the mouse can click and drag before the slider begins to
     * ignore mouse events. Ignored if `inhibitOnDrag` is `false`. Defaults to 40 pixels.
     */
    dragInhibitThresholdPx?: number;
    /** A callback function which will be called when the slider is destroyed. */
    onDestroy?: () => void;
    /** CSS class(es) to apply to the slider's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * A touchscreen slider.
 */
declare class TouchSlider<S extends Subscribable<number> | MutableSubscribable<number>, P extends TouchSliderProps<S> = TouchSliderProps<S>> extends DisplayComponent<P> {
    protected static readonly DEFAULT_SNAP_ANIMATION_EASING: (start: number, stop: number, progress: number) => number;
    protected static readonly RESERVED_CSS_CLASSES: Set<string>;
    protected readonly mainAxisIndex: number;
    protected readonly crossAxisIndex: number;
    protected readonly mainAxisSign: number;
    protected readonly sliderContainerRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly touchPadRef: _microsoft_msfs_sdk.NodeReference<TouchPad<TouchPadProps>>;
    protected readonly sliderThumbRef: _microsoft_msfs_sdk.NodeReference<HTMLDivElement>;
    protected readonly snapAnimationSpeed: Subscribable<number>;
    protected readonly snapAnimationEasing: (start: number, stop: number, progress: number) => number;
    protected readonly valueAnimator: Animator;
    protected readonly sliderForegroundClipPathFunc: (value: number) => string;
    protected readonly sliderThumbTranslateFunc: (value: number) => string;
    protected readonly sliderForegroundStyle: ObjectSubject<{
        '-webkit-clip-path': string;
    }>;
    protected readonly sliderThumbStyle: ObjectSubject<{
        transform: string;
    }>;
    protected readonly rootCssClass: SetSubject<string>;
    protected readonly isEnabled: Subscribable<boolean> | Subscribable<false> | Subscribable<true>;
    protected readonly isVisible: Subscribable<boolean> | Subscribable<false> | Subscribable<true>;
    protected isPrimed: boolean;
    protected readonly stops: Subscribable<readonly number[]>;
    protected sliderLength: number;
    protected thumbLength: number;
    protected mouseDownValue: number;
    protected draggedValue: number;
    protected readonly mouseDownPosition: Float64Array;
    protected readonly referenceMousePosition: Float64Array;
    protected readonly currentMousePosition: Float64Array;
    protected readonly focusOnDrag: boolean;
    protected readonly lockFocusOnDrag: boolean;
    protected readonly dragLockFocusThresholdPx: number;
    protected readonly inhibitOnDrag: boolean;
    protected readonly dragInhibitThresholdPx: number;
    protected cssClassSub?: Subscription;
    protected isEnabledSub?: Subscription;
    protected isVisibleSub?: Subscription;
    protected stateSub?: Subscription;
    /** @inheritdoc */
    onAfterRender(node: VNode): void;
    /**
     * Sets the primed state of this slider.
     * @param isPrimed The new primed state.
     */
    protected setPrimed(isPrimed: boolean): void;
    /**
     * Responds to when a mouse drag is started on this slider.
     * @param position The current mouse position.
     */
    protected onDragStarted(position: ReadonlyFloat64Array): void;
    /**
     * Responds to when this slider is dragged.
     * @param position The current mouse position.
     * @param prevPosition The position of the mouse at the previous update.
     * @param initialPosition The position of the mouse at the start of the current drag motion.
     */
    protected onDragMoved(position: ReadonlyFloat64Array, prevPosition: ReadonlyFloat64Array, initialPosition: ReadonlyFloat64Array): void;
    /**
     * Responds to when a mouse drag is released on this slider.
     * @param position The current position of the mouse.
     * @param initialPosition The position of the mouse at the start of the drag motion.
     */
    protected onDragEnded(position: ReadonlyFloat64Array, initialPosition: ReadonlyFloat64Array): void;
    /**
     * Responds to when this slider's value changes from user input.
     * @param value The new slider value.
     */
    protected onValueChangedFromInput(value: number): void;
    /**
     * Finds the stop closest to a given value. If this slider has no defined stops, this method will return the query
     * value as-is.
     * @param value The query value.
     * @returns The stop closest to the specified value, or the specified value if this slider has no defined stops.
     */
    protected findClosestStop(value: number): number;
    /**
     * Sets this slider's displayed value.
     * @param value The value to set.
     * @param animate Whether to animate the change.
     */
    protected setDisplayedValue(value: number, animate: boolean): void;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Gets the CSS classes that are reserved for this slider's root element.
     * @returns The CSS classes that are reserved for this slider's root element.
     */
    protected getReservedCssClasses(): ReadonlySet<string>;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for WaypointComponent.
 */
interface WaypointComponentProps extends ComponentProps {
    /** A subscribable which provides a waypoint to bind. */
    waypoint: Subscribable<Waypoint | null>;
}
/**
 * An abstract component which is bound to a waypoint.
 */
declare abstract class WaypointComponent<T extends WaypointComponentProps> extends DisplayComponent<T> {
    private waypointChangedSub?;
    onAfterRender(): void;
    /**
     * A callback which is called when this component's waypoint changes.
     * @param waypoint The new waypoint.
     */
    protected onWaypointChanged(waypoint: Waypoint | null): void;
    abstract render(): VNode;
    destroy(): void;
}

/**
 * Keys for a DefaultWaypointIconImageCache.
 */
declare enum DefaultWaypointIconImageKey {
    AirportToweredServiced = "AIRPORT_TOWERED_SERVICED",
    AirportToweredUnserviced = "AIRPORT_TOWERED_NONSERVICED",
    AirportUntoweredServiced = "AIRPORT_NONTOWERED_SERVICED",
    AirportUntoweredUnserviced = "AIRPORT_NONTOWERED_NONSERVICED",
    AirportSmallServiced = "AIRPORT_SMALL_SERVICED",
    AirportSmallUnserviced = "AIRPORT_SMALL_NONSERVICED",
    AirportPrivate = "AIRPORT_PRIVATE",
    AirportUnknown = "AIRPORT_UNKNOWN",
    Vor = "VOR",
    VorDme = "VORDME",
    Vortac = "VORTAC",
    Tacan = "TACAN",
    DmeOnly = "DME",
    Ndb = "NDB",
    Intersection = "INTERSECTION",
    User = "USER",
    FlightPath = "FPLN",
    VNav = "VNAV"
}
/**
 * A default implementation of {@link WaypointIconImageCache}.
 */
declare class DefaultWaypointIconImageCache implements WaypointIconImageCache {
    protected readonly cache: Map<string, HTMLImageElement>;
    /**
     * Registers an image with this cache.
     * @param key The key of the image to register.
     * @param src The source URI of the image to register.
     */
    register(key: string, src: string): void;
    /**
     * Retrieves an image from this cache.
     * @param key The key of the image to retrieve.
     * @returns The image registered under the specified key, or `undefined` if one could not be found.
     */
    get(key: string): HTMLImageElement | undefined;
    /** @inheritdoc */
    getForWaypoint(waypoint: Waypoint): HTMLImageElement | undefined;
    /**
     * Retrieves an image for an airport.
     * @param airport The airport for which to retrieve the image.
     * @returns The image for the specified airport, or `undefined` if one could not be found.
     */
    protected getForAirport(airport: FacilityWaypoint<AirportFacility>): HTMLImageElement | undefined;
    /**
     * Retrieves an image for a VOR.
     * @param vor The VOR for which to retrieve the image.
     * @returns The image for the specified VOR, or `undefined` if one could not be found.
     */
    protected getForVor(vor: FacilityWaypoint<VorFacility>): HTMLImageElement | undefined;
}

/**
 * A utility class for creating Garmin unit formatters.
 *
 * Each unit formatter is a function which generates output strings from input measurement units.
 */
declare class UnitFormatter {
    private static readonly UNIT_TEXT;
    private static UNIT_TEXT_LOWER?;
    private static UNIT_TEXT_UPPER?;
    /**
     * Creates a function which formats measurement units to strings representing their abbreviated names.
     * @param defaultString The string to output when the input unit cannot be formatted. Defaults to the empty string.
     * @param charCase The case to enforce on the output string. Defaults to `'normal'`.
     * @returns A function which formats measurement units to strings representing their abbreviated names.
     */
    static create(defaultString?: string, charCase?: 'normal' | 'upper' | 'lower'): (unit: Unit<any>) => string;
    /**
     * Creates a record of lowercase unit abbreviated names.
     * @returns A record of lowercase unit abbreviated names.
     */
    private static createLowerCase;
    /**
     * Creates a record of uppercase unit abbreviated names.
     * @returns A record of uppercase unit abbreviated names.
     */
    private static createUpperCase;
    /**
     * Gets a mapping of unit family and name to text used by UnitFormatter to format units. The returned object maps
     * unit families to objects that map unit names within each family to formatted text.
     * @returns A mapping of unit family and name to text used by UnitFormatter to format units.
     */
    static getUnitTextMap(): Readonly<Partial<Record<string, Readonly<Partial<Record<string, string>>>>>>;
}

/** Component props for WaypointIcon. */
interface WaypointIconProps extends WaypointComponentProps {
    /**
     * A subscribable which provides the airplane's current true heading.
     * When provided, airport icons will be rotate depending on the difference
     * between the plane's heading and the airport's longest runway.
     * If not provided, airport icons will show the heading of the longest runway. */
    planeHeading?: Subscribable<number>;
    /** The size of each square icon in the texture atlas. */
    atlasIconSize: number;
    /** The image waypoint icon image cache to use. */
    imageCache: WaypointIconImageCache;
    /** CSS class(es) to add to the root of the icon component. */
    class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}
/** A waypoint icon. */
declare class WaypointIcon extends WaypointComponent<WaypointIconProps> {
    private static readonly RESERVED_CLASSES;
    private readonly imgRef;
    private readonly srcSub;
    private imgFrameRowCount;
    private imgFrameColCount;
    private imgOffset?;
    private readonly subscriptions;
    /** @inheritdoc */
    onAfterRender(): void;
    /** @inheritdoc */
    protected onWaypointChanged(waypoint: Waypoint | null): void;
    /**
     * Initializes the image onload listener.
     */
    private initImageLoadListener;
    /**
     * A callback which is called when this component's image element finishes loading an image.
     */
    private onImageLoaded;
    /**
     * Updates this icon's offset, or unsets it.
     */
    private updateOffset;
    /**
     * Updates this airport icon's offset.
     * @param headingOffset How mush to offset the runway heading by.
     * @param runwayHeading The heading of the runway.
     */
    private updateAirportIconOffset;
    /**
     * Sets the object offset of this icon's image element.
     * @param offset The new offset.
     */
    private setImgOffset;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Provides utility functions for working with Garmin weather radars.
 */
declare class WeatherRadarUtils {
    private static readonly DBZ_TO_RATE_TABLE;
    private static readonly STANDARD_COLORS;
    private static readonly EXTENDED_COLORS;
    /**
     * Converts a radar return signal strength in dBZ to an approximate precipitation rate in millimeters per hour.
     * @param dbz A radar return signal strength in dBZ.
     * @returns The precipitation rate, in millimeters per hour, that is approximately correlated with the specified
     * radar return signal strength.
     */
    static dbzToPrecipRate(dbz: number): number;
    /**
     * Gets the calibrated (zero-gain) standard Garmin three-color weather radar color array.
     * @returns The calibrated (zero-gain) standard Garmin three-color weather radar color array.
     */
    static standardColors(): readonly (readonly [number, number])[];
    /**
     * Gets the calibrated (zero-gain) extended Garmin 16-color weather radar color array.
     * @returns The calibrated (zero-gain) extended Garmin 16-color weather radar color array.
     */
    static extendedColors(): readonly (readonly [number, number])[];
}

/**
 * Garmin ESP operating modes.
 */
declare enum EspOperatingMode {
    /** The system is off. */
    Off = "Off",
    /**
     * The system is on, but arming is inhibited due to autopilot engagement, violation of an arming limit, or other
     * external factors.
     */
    Disarmed = "Disarmed",
    /** The system is on and can apply force to controls as necessary. */
    Armed = "Armed",
    /** The system is on and armed but is prevented from being able to apply force to controls due to pilot action. */
    Interrupted = "Interrupted",
    /** The system has failed. */
    Failed = "Failed"
}
/**
 * Data provided by Garmin ESP systems to modules.
 */
type EspData = {
    /** The current real (operating system) time, as a Javascript timestamp. */
    realTime: number;
    /** The current sim time, as a Javascript timestamp. */
    simTime: number;
    /** The current simulation rate factor. */
    simRate: number;
    /** Whether ESP arming is inhibited. */
    isArmingInhibited: boolean;
    /** Whether the airplane is on the ground. */
    isOnGround: boolean;
    /** Whether the autopilot is on. */
    isApOn: boolean;
    /** Whether ESP has valid attitude data. */
    isAttitudeValid: boolean;
    /** The airplane's pitch angle, in degrees. Positive values indicate downward pitch. */
    pitch: number;
    /**
     * The rate of change of the airplane's pitch angle, in degrees per second. Positive values indicate that the
     * airplane is pitching down.
     */
    pitchRate: number;
    /** The airplane's roll angle, in degrees. Positive values indicate leftward roll. */
    roll: number;
    /**
     * The rate of change of the airplane's roll angle, in degrees per second. Positive values indicate that the airplane
     * is rolling to the left.
     */
    rollRate: number;
    /** Whether ESP has valid indicated airspeed and mach data. */
    isAirspeedValid: boolean;
    /** The airplane's indicated airspeed, in knots. */
    ias: number;
    /** The airplane's mach number. */
    mach: number;
    /** Whether ESP has valid true airspeed data. */
    isTasValid: boolean;
    /** The airplane's true airspeed, in knots. */
    tas: number;
    /** Whether ESP has valid angle of attack data. */
    isAoaValid: boolean;
    /** The airplane's angle of attack, in degrees. */
    aoa: number;
    /** The airplane's stall (critical) angle of attack, in degrees. */
    stallAoa: number;
    /** The airplane's zero-lift angle of attack, in degrees. */
    zeroLiftAoa: number;
    /** Whether ESP has valid above ground height data. */
    isAglValid: boolean;
    /** The airplane's above ground height, in feet. */
    agl: number;
};
/**
 * A controller for forces applied to control axes by a Garmin ESP system.
 */
interface EspForceController {
    /**
     * Applies a force to the pitch control axis.
     * @param force The force to apply. A force of magnitude one is the amount of force required to deflect the control
     * axis from the neutral position to maximum deflection (on either side). Positive force deflects the control axis
     * to command an increase in pitch angle (i.e. increase downward pitch).
     */
    applyPitchForce(force: number): void;
    /**
     * Applies a force to the roll control axis.
     * @param force The force to apply. A force of magnitude one is the amount of force required to deflect the control
     * axis from the neutral position to maximum deflection (on either side). Positive force deflects the control axis
     * to command an increase in roll angle (i.e. increase leftward roll).
     */
    applyRollForce(force: number): void;
}

/**
 * A module for a Garmin electronic stability and protection (ESP) system. Modules are attached to a parent system,
 * which update the modules and provide them with data.
 */
interface EspModule {
    /** This module's ID. */
    readonly id: string;
    /**
     * Checks if this module is engaged.
     * @returns Whether this module is engaged.
     */
    isEngaged(): boolean;
    /**
     * A method that is called when this module is attached to an initialized system, or when this module's parent
     * system is initialized.
     */
    onInit(): void;
    /**
     * A method that is called every time this module's parent system is updated.
     * @param operatingMode The parent system's current operating mode.
     * @param data The data provided by the parent system.
     * @param forceController A controller for control axis forces applied by the parent system.
     */
    onUpdate(operatingMode: EspOperatingMode, data: Readonly<EspData>, forceController: EspForceController): void;
    /**
     * A method that is called when this module's parent system is paused.
     */
    onPause(): void;
    /**
     * A method that is called when this module's parent system is destroyed.
     */
    onDestroy(): void;
}

/**
 * Data describing the engagement state of an {@link EspAirspeedModule}.
 */
type EspAirspeedModuleEngageData = {
    /** Whether the module is engaged due to indicated airspeed exceedance. */
    isIasEngaged: boolean;
    /**
     * The indicated airspeed, in knots, at or beyond which the module engages, or `NaN` if the module cannot engage due
     * to indicated airspeed exceedance.
     */
    engageIas: number;
    /**
     * The indicated airspeed, in knots, within which the module disengages, or `NaN` if the module cannot engage due to
     * indicated airspeed exceedance.
     */
    disengageIas: number;
    /** Whether the module is engaged due to mach exceedance. */
    isMachEngaged: boolean;
    /** The mach number at or beyond which the module engages, or `NaN` if the module cannot engage due to mach exceedance. */
    engageMach: number;
    /** The mach number within which the module disengages, or `NaN` if the module cannot engage due to mach exceedance. */
    disengageMach: number;
    /** Whether the module is engaged due to true airspeed exceedance. */
    isTasEngaged: boolean;
    /**
     * The true airspeed, in knots, at or beyond which the module engages, or `NaN` if the module cannot engage due to
     * true airspeed exceedance.
     */
    engageTas: number;
    /**
     * The true airspeed, in knots, within which the module disengages, or `NaN` if the module cannot engage due to true
     * airspeed exceedance.
     */
    disengageTas: number;
};
/**
 * Configuration options for {@link EspAirspeedModule}.
 */
type EspAirspeedModuleOptions = {
    /**
     * The direction of airspeed exceedance used by the module. With a direction of `high`, the module will engage in
     * high airspeed conditions. With a direction of `low`, the module will engage in low airspeed conditions.
     */
    exceedDirection: 'high' | 'low';
    /**
     * The indicated airspeed, in knots, at or beyond which the module engages. A value equal to `NaN` will inhibit the
     * module from engaging due to indicated airspeed exceedance. If not defined, then the module will not engage due to
     * indicated airspeed exceedance.
     */
    engageIas?: number | Accessible<number>;
    /**
     * The indicated airspeed, in knots, within which the module disengages. The value will be clamped such that it is
     * not in the same direction as `exceedDirection` relative to `engageIas`. A value equal to `NaN` will inhibit the
     * module from engaging due to indicated airspeed exceedance. If not defined, then the module will not engage due to
     * indicated airspeed exceedance.
     */
    disengageIas?: number | Accessible<number>;
    /**
     * The mach number at or beyond which the module engages. A value equal to `NaN` will inhibit the module from
     * engaging due to mach exceedance. If not defined, then the module will not engage due to mach exceedance.
     */
    engageMach?: number | Accessible<number>;
    /**
     * The mach number within which the module disengages. The value will be clamped such that it is not in the same
     * direction as `exceedDirection` relative to `engageMach`. A value equal to `NaN` will inhibit the module from
     * engaging due to mach exceedance. If not defined, then the module will not engage due to mach exceedance.
     */
    disengageMach?: number | Accessible<number>;
    /**
     * The true airspeed, in knots, at or beyond which the module engages. A value equal to `NaN` will inhibit the module
     * from engaging due to true airspeed exceedance. If not defined, then the module will not engage due to true
     * airspeed exceedance.
     */
    engageTas?: number | Accessible<number>;
    /**
     * The true airspeed, in knots, within which the module disengages. The value will be clamped such that it is not in
     * the same direction as `exceedDirection` relative to `engageTas`. A value equal to `NaN` will inhibit the module
     * from engaging due to true airspeed exceedance. If not defined, then the module will not engage due to true
     * airspeed exceedance.
     */
    disengageTas?: number | Accessible<number>;
    /**
     * Gets the force to apply to the pitch control axis when the module is engaged, scaled such that a force of
     * magnitude one is the amount of force required to deflect the control axis from the neutral position to maximum
     * deflection (on either side). Positive force deflects the control axis to command an increase in pitch angle (i.e.
     * increase downward pitch).
     * @param data The current ESP data.
     * @param engageData Data describing the engagement state of the module.
     * @returns The force to apply to the pitch control axis when the module is engaged, scaled such that a force of
     * magnitude one is the amount of force required to deflect the control axis from the neutral position to maximum
     * deflection (on either side).
     */
    getForceToApply: (data: Readonly<EspData>, engageData: Readonly<EspAirspeedModuleEngageData>) => number;
    /** Whether the module can engage when AGL data is invalid. Defaults to `false`. */
    canEngageWhenAglInvalid?: boolean;
};
/**
 * An airspeed engagement module for Garmin ESP systems. The module applies a force to the pitch control axis to combat
 * excessive airspeed in one direction (either high airspeed or low airspeed). The module supports engagement due to
 * exceedances in indicated airspeed, mach number, and true airspeed. The module engages when there is an exceedance in
 * any of the supported airspeed types and disengages when there are no exceedances in any of the airspeed types.
 */
declare class EspAirspeedModule implements EspModule {
    readonly id: string;
    private readonly directionSign;
    private readonly engageIas?;
    private readonly disengageIas?;
    private readonly engageMach?;
    private readonly disengageMach?;
    private readonly engageTas?;
    private readonly disengageTas?;
    private readonly getForceToApply;
    private readonly canEngageWhenAglInvalid;
    private readonly engageData;
    /**
     * Creates a new instance of EspAirspeedModule.
     * @param id This module's ID.
     * @param options Options with which to configure the module.
     */
    constructor(id: string, options: Readonly<EspAirspeedModuleOptions>);
    /** @inheritDoc */
    isEngaged(): boolean;
    /**
     * Gets data describing this module's engagement state.
     * @returns Data describing this module's engagement state.
     */
    getEngageData(): Readonly<EspAirspeedModuleEngageData>;
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: EspOperatingMode, data: Readonly<EspData>, forceController: EspForceController): void;
    /** @inheritDoc */
    onPause(): void;
    /** @inheritDoc */
    onDestroy(): void;
}

/**
 * Data describing the engagement state of an {@link EspAoaModule}.
 */
type EspAoaModuleEngageData = {
    /** Whether the module is engaged. */
    isEngaged: boolean;
    /** The angle of attack, in degrees, at or above which the module engages, or `NaN` if the module cannot engage. */
    engageAoa: number;
    /** The angle of attack, in degrees, below which the module disengages, or `NaN` if the module cannot engage. */
    disengageAoa: number;
};
/**
 * Configuration options for {@link EspAoaModule}.
 */
type EspAoaModuleOptions = {
    /**
     * The angle of attack, in degrees, at or above which the module engages. A value equal to `NaN` will inhibit the
     * module from engaging.
     */
    engageAoa: number | Accessible<number>;
    /**
     * The angle of attack, in degrees, below which the module disengages. The value will be clamped such that it is not
     * greater than `engageAoa`. A value equal to `NaN` will inhibit the module from engaging.
     */
    disengageAoa: number | Accessible<number>;
    /**
     * Gets the force to apply to the pitch control axis when the module is engaged, scaled such that a force of
     * magnitude one is the amount of force required to deflect the control axis from the neutral position to maximum
     * deflection (on either side). Positive force deflects the control axis to command an increase in pitch angle (i.e.
     * increase downward pitch).
     * @param data The current ESP data.
     * @param engageData Data describing the engagement state of the module.
     * @returns The force to apply to the pitch control axis when the module is engaged, scaled such that a force of
     * magnitude one is the amount of force required to deflect the control axis from the neutral position to maximum
     * deflection (on either side).
     */
    getForceToApply: (data: Readonly<EspData>, engageData: Readonly<EspAoaModuleEngageData>) => number;
    /** Whether the module can engage when AGL data is invalid. Defaults to `false`. */
    canEngageWhenAglInvalid?: boolean;
};
/**
 * An angle of attack protection module for Garmin ESP systems. The module applies a force to the pitch control axis to
 * combat excessively high angle of attack values.
 */
declare class EspAoaModule implements EspModule {
    readonly id: string;
    private readonly engageAoa;
    private readonly disengageAoa;
    private readonly getForceToApply;
    private readonly canEngageWhenAglInvalid;
    private readonly engageData;
    /**
     * Creates a new instance of EspAoaModule.
     * @param id This module's ID.
     * @param options Options with which to configure the module.
     */
    constructor(id: string, options: Readonly<EspAoaModuleOptions>);
    /** @inheritDoc */
    isEngaged(): boolean;
    /**
     * Gets data describing this module's engagement state.
     * @returns Data describing this module's engagement state.
     */
    getEngageData(): Readonly<EspAoaModuleEngageData>;
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: EspOperatingMode, data: Readonly<EspData>, forceController: EspForceController): void;
    /** @inheritDoc */
    onPause(): void;
    /** @inheritDoc */
    onDestroy(): void;
}

/**
 * Data describing the engagement state of an {@link EspPitchModule}.
 */
type EspPitchModuleEngageData = {
    /** Whether the module is engaged. */
    isEngaged: boolean;
    /**
     * The pitch angle, in degrees, at or beyond which the module engages, or `NaN` if the module cannot engage. Positive
     * angles represent downward pitch.
     */
    engagePitch: number;
    /**
     * The pitch angle, in degrees, beyond which the module cannot engage, or `NaN` if there is no limit. Positive angles
     * represent downward pitch.
     */
    engagePitchLimit: number;
    /**
     * The pitch angle, in degrees, within which the module disengages, or `NaN` if the module cannot engage. Positive
     * angles represent downward pitch.
     */
    disengagePitch: number;
};
/**
 * Configuration options for {@link EspPitchModule}.
 */
type EspPitchModuleOptions = {
    /**
     * The direction of pitch angle exceedance used by the module. With a direction of `up`, the module will engage with
     * excessive pitch up angles. With a direction of `down`, the module will engage with excessive pitch down angles.
     */
    exceedDirection: 'up' | 'down';
    /**
     * The pitch angle, in degrees, at or beyond which the module engages. Positive angles represent downward pitch.
     * A value equal to `NaN` will inhibit the module from engaging.
     */
    engagePitch: number | Accessible<number>;
    /**
     * The pitch angle, in degrees, beyond which the module cannot engage. Positive angles represent downward pitch. The
     * value will be clamped such that it is not in the opposite direction as `exceedDirection` relative to
     * `engagePitch`. A value equal to `NaN` will be treated as the equivalent of no limit. Defaults to `NaN`.
     */
    engagePitchLimit?: number | Accessible<number>;
    /**
     * The pitch angle, in degrees, within which the module disengages. Positive angles represent downward pitch. The
     * value will be clamped such that it is not in the same direction as `exceedDirection` relative to `engagePitch`.
     * A value equal to `NaN` will inhibit the module from engaging.
     */
    disengagePitch: number | Accessible<number>;
    /**
     * Gets the force to apply to the pitch control axis when the module is engaged, scaled such that a force of
     * magnitude one is the amount of force required to deflect the control axis from the neutral position to maximum
     * deflection (on either side). Positive force deflects the control axis to command an increase in pitch angle (i.e.
     * increase downward pitch).
     * @param data The current ESP data.
     * @param engageData Data describing the engagement state of the module.
     * @returns The force to apply to the pitch control axis when the module is engaged, scaled such that a force of
     * magnitude one is the amount of force required to deflect the control axis from the neutral position to maximum
     * deflection (on either side).
     */
    getForceToApply: (data: Readonly<EspData>, engageData: Readonly<EspPitchModuleEngageData>) => number;
    /** Whether the module can engage when AGL data is invalid. Defaults to `false`. */
    canEngageWhenAglInvalid?: boolean;
};
/**
 * A pitch engagement module for Garmin ESP systems. The module applies a force to the pitch control axis to combat
 * excessive pitch angles in one direction (either excessive pitch up or pitch down).
 */
declare class EspPitchModule implements EspModule {
    readonly id: string;
    private readonly directionSign;
    private readonly engagePitch;
    private readonly engagePitchLimit;
    private readonly disengagePitch;
    private readonly getForceToApply;
    private readonly canEngageWhenAglInvalid;
    private readonly engageData;
    /**
     * Creates a new instance of EspPitchModule.
     * @param id This module's ID.
     * @param options Options with which to configure the module.
     */
    constructor(id: string, options: Readonly<EspPitchModuleOptions>);
    /** @inheritDoc */
    isEngaged(): boolean;
    /**
     * Gets data describing this module's engagement state.
     * @returns Data describing this module's engagement state.
     */
    getEngageData(): Readonly<EspPitchModuleEngageData>;
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: EspOperatingMode, data: Readonly<EspData>, forceController: EspForceController): void;
    /** @inheritDoc */
    onPause(): void;
    /** @inheritDoc */
    onDestroy(): void;
}

/**
 * Data describing the engagement state of an {@link EspRollModule}.
 */
type EspRollModuleEngageData = {
    /**
     * The module's engagement mode:
     * * `none`: The module is not engaged.
     * * `left`: The module is engaged due to excessive leftward roll.
     * * `right`: The module is engaged due to excessive rightward roll.
     */
    engageMode: 'none' | 'left' | 'right';
    /** The roll angle magnitude, in degrees, at or above which the module engages, or `NaN` if the module cannot engage. */
    engageRoll: number;
    /** The roll angle magnitude, in degrees, above which the module cannot engage, or `NaN` if there is no limit. */
    engageRollLimit: number;
    /** The roll angle magnitude, in degrees, below which the module disengages, or `NaN` if the module cannot engage. */
    disengageRoll: number;
};
/**
 * Configuration options for {@link EspRollModule}.
 */
type EspRollModuleOptions = {
    /**
     * The roll angle magnitude, in degrees, at or above which the module engages. The value will be clamped to be
     * greater than or equal to zero.
     */
    engageRoll: number | Accessible<number>;
    /**
     * The roll angle magnitude, in degrees, above which the module cannot engage. The value will be clamped to be
     * greater than or equal to `engageRoll`. A value equal to `NaN` will be treated as the equivalent of no limit.
     * Defaults to `NaN`.
     */
    engageRollLimit?: number | Accessible<number>;
    /**
     * The roll angle magnitude, in degrees, below which the module disengages. The value will be clamped to be less than
     * or equal to `engageRoll`.
     */
    disengageRoll: number | Accessible<number>;
    /**
     * Gets the force to apply to the roll control axis when the module is engaged, scaled such that a force of magnitude
     * one is the amount of force required to deflect the control axis from the neutral position to maximum deflection
     * (on either side). Positive force deflects the control axis to command an increase in roll angle (i.e. increase
     * leftward roll).
     * @param data The current ESP data.
     * @param engageData Data describing the engagement state of the module.
     * @returns The force to apply to the roll control axis when the module is engaged, scaled such that a force of
     * magnitude one is the amount of force required to deflect the control axis from the neutral position to maximum
     * deflection (on either side).
     */
    getForceToApply: (data: Readonly<EspData>, engageData: Readonly<EspRollModuleEngageData>) => number;
    /** Whether the module can engage when AGL data is invalid. Defaults to `false`. */
    canEngageWhenAglInvalid?: boolean;
};
/**
 * A roll engagement module for Garmin ESP systems. The module applies a force to the roll control axis to combat
 * excessive roll angles.
 */
declare class EspRollModule implements EspModule {
    readonly id: string;
    private readonly engageRoll;
    private readonly engageRollLimit;
    private readonly disengageRoll;
    private readonly getForceToApply;
    private readonly canEngageWhenAglInvalid;
    private readonly engageData;
    /**
     * Creates a new instance of EspRollModule.
     * @param id This module's ID.
     * @param options Options with which to configure the module.
     */
    constructor(id: string, options: Readonly<EspRollModuleOptions>);
    /** @inheritDoc */
    isEngaged(): boolean;
    /**
     * Gets data describing this module's engagement state.
     * @returns Data describing this module's engagement state.
     */
    getEngageData(): Readonly<EspRollModuleEngageData>;
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: EspOperatingMode, data: Readonly<EspData>, forceController: EspForceController): void;
    /** @inheritDoc */
    onPause(): void;
    /** @inheritDoc */
    onDestroy(): void;
}

/**
 * A provider of Garmin ESP data.
 */
interface EspDataProvider {
    /** The current ESP data. */
    readonly data: Readonly<EspData>;
}

/**
 * Configuration options for {@link Esp}.
 */
type EspOptions = {
    /** The above ground height, in feet, at or above which ESP can become armed from a disarmed state. */
    armAglThreshold: number;
    /** The above ground height, in feet, below which ESP becomes disarmed from an armed state. */
    disarmAglThreshold: number;
    /** Whether ESP can become armed when AGL data is invalid. Defaults to `false`. */
    canArmWhenAglInvalid?: boolean;
    /**
     * The minimum pitch angle, in degrees, at which ESP can become armed. Positive angles represent downward pitch.
     * Defaults to `-90`.
     */
    armMinPitchLimit?: number;
    /**
     * The maximum pitch angle, in degrees, at which ESP can become armed. Positive angles represent downward pitch.
     * Defaults to `90`.
     */
    armMaxPitchLimit?: number;
    /** The maximum roll angle magnitude, in degrees, at which ESP can become armed. Defaults to `90`. */
    armRollLimit?: number;
    /**
     * The maximum force ESP is allowed to apply to the pitch control axis to move it in the pitch up direction. A force
     * of magnitude one is the amount of force required to deflect the control axis from the neutral position to maximum
     * deflection (on either side). Defaults to `1`.
     */
    pitchAxisMaxForceUp?: number;
    /**
     * The maximum force ESP is allowed to apply to the pitch control axis to move it in the pitch down direction. A
     * force of magnitude one is the amount of force required to deflect the control axis from the neutral position to
     * maximum deflection (on either side). Defaults to `1`.
     */
    pitchAxisMaxForceDown?: number;
    /**
     * The rate at which the system changes the force applied to the pitch control axis, in units of force per second.
     * Defaults to `0.1`.
     */
    pitchAxisForceRate?: number;
    /**
     * The rate at which the system unloads force applied to the pitch control axis when it is not armed, in units of
     * force per second. Defaults to `1`.
     */
    pitchAxisUnloadRate?: number;
    /**
     * The maximum force ESP is allowed to apply to the roll control axis. A force of magnitude one is the amount of
     * force required to deflect the control axis from the neutral position to maximum deflection (on either side).
     * Defaults to `1`.
     */
    rollAxisMaxForce?: number;
    /**
     * The rate at which the system changes the force applied to the roll control axis, in units of force per second.
     * Defaults to `0.1`.
     */
    rollAxisForceRate?: number;
    /**
     * The rate at which the system unloads force applied to the roll control axis when it is not armed, in units of
     * force per second. Defaults to `1`.
     */
    rollAxisUnloadRate?: number;
    /**
     * The length of the window, in seconds, in which engagement time is tracked. Values less than or equal to zero will
     * cause engagement time to not be tracked. Defaults to `0`.
     */
    engagementTimeWindow?: number;
};
/**
 * A Garmin electronic stability and protection system.
 */
declare class Esp {
    private readonly dataProvider;
    private readonly modules;
    private readonly forceController;
    private readonly armAglThreshold;
    private readonly disarmAglThreshold;
    private readonly canArmWhenAglInvalid;
    private readonly armMinPitchLimit;
    private readonly armMaxPitchLimit;
    private readonly armRollLimit;
    private readonly pitchAxisMaxForceUp;
    private readonly pitchAxisMaxForceDown;
    private readonly pitchAxisForceRate;
    private readonly pitchAxisUnloadRate;
    private readonly rollAxisMaxForce;
    private readonly rollAxisForceRate;
    private readonly rollAxisUnloadRate;
    private isAlive;
    private isInit;
    private isPaused;
    private isOn;
    private isArmed;
    private isInterrupted;
    private isFailed;
    private isEngaged;
    private desiredPitchAxisForce;
    private desiredRollAxisForce;
    private readonly engagementTimeQueue;
    private engagementTime;
    private lastUpdateTime;
    private readonly _operatingMode;
    /** This system's current operating mode. */
    readonly operatingMode: Subscribable<EspOperatingMode>;
    private readonly _pitchAxisForce;
    /**
     * The force applied to the pitch control axis by this system, scaled such that a force of magnitude one is the
     * amount of force required to deflect the control axis from the neutral position to maximum deflection (on either
     * side). Positive force deflects the control axis to command an increase in pitch angle (i.e. increase downward
     * pitch).
     */
    readonly pitchAxisForce: Subscribable<number>;
    private readonly _rollAxisForce;
    /**
     * The force applied to the roll control axis by this system, scaled such that a force of magnitude one is the amount
     * of force required to deflect the control axis from the neutral position to maximum deflection (on either side).
     * Positive force deflects the control axis to command an increase in roll angle (i.e. increase leftward roll).
     */
    readonly rollAxisForce: Subscribable<number>;
    /**
     * The length of the window, in seconds, in which engagement time is tracked, or `0` if engagement time is not
     * tracked.
     */
    readonly engagementTimeWindow: number;
    private readonly _engagementTimeFraction;
    /**
     * The amount of time this system spent engaged during the engagement time window, as a fraction of the window
     * length. If engagement time is not tracked, then this value is always equal to zero.
     */
    readonly engagementTimeFraction: Subscribable<number>;
    /**
     * Creates a new instance of Esp. The system is created in a paused state. Initializing the system and calling
     * `update()` will resume it.
     * @param dataProvider A provider of ESP data.
     * @param options Options with which to configure the system.
     */
    constructor(dataProvider: EspDataProvider, options: Readonly<EspOptions>);
    /**
     * Gets an array containing all modules that have been added to this system.
     * @returns An array containing all modules that have been added to this system.
     */
    getAllModules(): readonly EspModule[];
    /**
     * Gets a module with a given ID that has been added to this system.
     * @param id The ID of the module to get.
     * @returns The module added to this system that has the specified ID, or `undefined` if there is no such module.
     */
    getModule(id: string): EspModule | undefined;
    /**
     * Adds a module to this system. If the module has already been added, then this method does nothing. If the module
     * shares an ID with any module already added to this system, then the previously added module will be removed before
     * the new module is added.
     * @param module The module to add.
     * @throws Error if this system has been destroyed or has been initialized.
     */
    addModule(module: EspModule): void;
    /**
     * Initializes this system. Once the system is initialized, it can be updated by calling `update()`.
     * @throws Error if this system has been destroyed.
     */
    init(): void;
    /**
     * Initializes this system's modules.
     */
    private initModules;
    /**
     * Sets the master state of this system.
     * @param on The state to set: `true` to turn the system on, and `false` to turn the system off.
     * @throws Error if this system has been destroyed.
     */
    setMaster(on: boolean): void;
    /**
     * Sets whether pilot action is preventing this system from being engaged.
     * @param interrupt Whether pilot action is preventing this system from being engaged.
     * @throws Error if this system has been destroyed.
     */
    setInterrupt(interrupt: boolean): void;
    /**
     * Sets whether this system has failed.
     * @param failed Whether this system has failed.
     * @throws Error if this system has been destroyed.
     */
    setFailed(failed: boolean): void;
    /**
     * Applies a force to the pitch control axis.
     * @param force The force to apply, scaled such that a force of magnitude one is the amount of force required to
     * deflect the control axis from the neutral position to maximum deflection (on either side). Positive force deflects
     * the control axis to command an increase in pitch angle (i.e. increase downward pitch).
     */
    private applyPitchForce;
    /**
     * Applies a force to the roll control axis.
     * @param force The force to apply, scaled such that a force of magnitude one is the amount of force required to
     * deflect the control axis from the neutral position to maximum deflection (on either side). Positive force deflects
     * the control axis to command an increase in roll angle (i.e. increase leftward roll).
     */
    private applyRollForce;
    /**
     * Updates this system.
     * @throws Error if this system has been destroyed.
     */
    update(): void;
    /**
     * Updates this system's tracked engagement time.
     * @param dtSec The elapsed time since the last update, in seconds.
     */
    private updateEngagementTime;
    /**
     * Updates this system's operating mode.
     */
    private updateOperatingMode;
    /**
     * Updates this system's modules.
     */
    private updateModules;
    /**
     * Updates this system's applied control axis forces.
     * @param dtSec The elapsed time since the last update, in seconds.
     */
    private updateControlAxisForces;
    /**
     * Pauses this system. The system will be resumed the next time `update()` is called.
     * @throws Error if this system has been destroyed.
     */
    pause(): void;
    /**
     * Destroys this system. Once destroyed, this system can no longer be initialized, updated, or manipulated.
     */
    destroy(): void;
}

/**
 * Data describing control axis forces applied by ESP used by {@link EspControlInputManager}.
 */
type EspControlInputManagerForceData = {
    /**
     * The force applied to the pitch control axis, scaled such that a force of magnitude one is the amount of force
     * required to deflect the control axis from the neutral position to maximum deflection (on either side). Positive
     * force deflects the control axis to command an increase in pitch angle (i.e. increase downward pitch). If not
     * defined, then the force applied is taken to be zero.
     */
    readonly pitchAxisForce?: Subscribable<number>;
    /**
     * The force applied to the roll control axis, scaled such that a force of magnitude one is the amount of force
     * required to deflect the control axis from the neutral position to maximum deflection (on either side). Positive
     * force deflects the control axis to command an increase in roll angle (i.e. increase leftward roll). If not
     * defined, then the force applied is taken to be zero.
     */
    readonly rollAxisForce?: Subscribable<number>;
};
/**
 * Control axis increment logic options for a {@link EspControlInputManager}.
 */
type EspControlInputManagerAxisIncrOptions = {
    /**
     * The base amount to increment the input control axis in response to incrementing/decrementing key events, scaled
     * such that `1` equals the amount of travel from the neutral position to maximum deflection (on either side).
     * Defaults to `0.03136` for the pitch axis or `0.06272` for the roll axis.
     */
    baseIncr?: number;
    /**
     * The true airspeed, in knots, at which the input control axis increment is reduced to one half its original value.
     * A value of less than or equal to zero prevents any adjustment of the increment based on true airspeed. Defaults to
     * `0`.
     */
    oneHalfTas?: number;
    /**
     * The true airspeed, in knots, at which the input control axis increment is reduced to one eighth its original
     * value. Will be clamped to be greater than `oneHalfTas`. Defaults to `0`.
     */
    oneEighthTas?: number;
    /**
     * The maximum amount of time, in milliseconds, allowed between two consecutive incrementing/decrementing key events
     * while the associated key is considered to be held down. Defaults to `200`.
     */
    keyReleaseThreshold?: number;
    /**
     * A function that computes a scaling factor to apply to the input control axis increment based on how long the
     * triggering key event's associated key has been held down.
     * @param heldTime The amount of time that the key has been held down, in milliseconds.
     * @returns The scaling factor to apply to the input control axis increment given the specified amount of time the
     * key has been held down.
     */
    keyTimingFactor?: (heldTime: number) => number;
    /**
     * The scaling factor to apply to the input control axis increment when the input control axis position is near the
     * neutral position and the triggering key event's associated key is not considered held down. Defaults to `4`.
     */
    neutralFactor?: number;
    /**
     * The tolerance to use when determing if the input control axis position is near neutral, scaled such that `1`
     * equals the amount of travel from the neutral position to maximum deflection (on either side). Defaults to `0.001`.
     */
    neutralEpsilon?: number;
};
/**
 * Configuration options for {@link EspControlInputManager}.
 */
type EspControlInputManagerOptions = {
    /** Options for pitch axis increment logic. */
    pitchAxisIncrOptions?: Readonly<EspControlInputManagerAxisIncrOptions>;
    /** Options for roll axis increment logic. */
    rollAxisIncrOptions?: Readonly<EspControlInputManagerAxisIncrOptions>;
};
/**
 * A manager that adjusts pitch and roll control inputs in response to forces applied by a Garmin ESP system.
 */
declare class EspControlInputManager {
    private readonly bus;
    private static readonly AXIS_LIMIT;
    private keyEventManager?;
    private readonly keyEventManagerPromise;
    private isInit;
    private readonly elevatorAxisInput;
    private readonly elevatorAxisOutput?;
    private readonly elevatorAxisIncrOptions?;
    private readonly aileronAxisInput;
    private readonly aileronAxisOutput?;
    private readonly aileronAxisIncrOptions?;
    private readonly keyTiming;
    /**
     * Creates a new instance of EspControlInputManager. Once created, the manager must be initialized in order for it to
     * adjust control inputs.
     * @param bus The event bus.
     * @param forceData Data describing control axis forces applied by ESP.
     * @param options Options with which to configure the manager.
     */
    constructor(bus: EventBus, forceData: EspControlInputManagerForceData, options?: Readonly<EspControlInputManagerOptions>);
    /**
     * Retrieves a key event manager.
     * @returns A Promise that is fulfilled when the key event manager has been retrieved.
     */
    private retrieveKeyEventManager;
    /**
     * Initializes this manager. Once initialized, the manager will automatically adjust pitch and roll control inputs
     * in response to forces applied by ESP.
     */
    init(): Promise<void>;
    /**
     * Responds to when a control axis output changes.
     * @param keyEvent The key event to trigger to set the position of the output's control axis.
     * @param output The new control axis output.
     */
    private onControlAxisOutputChanged;
    /**
     * Responds to when a key event is intercepted.
     * @param data Data describing the intercepted key event.
     */
    private onKeyIntercepted;
    /**
     * Sets a control axis input.
     * @param input The input to set.
     * @param value The value to set.
     */
    private setControlAxisInput;
    /**
     * Changes a control axis input.
     * @param input The input to change.
     * @param incrOptions Increment options for the input's control axis.
     * @param keyEvent The key event that is the source of the change.
     * @param direction The direction in which to change the input.
     */
    private changeControlAxisInput;
    /**
     * Maps a control axis input and ESP force to an output value.
     * @param param0 The input state to map.
     * @param param0."0" The control axis input.
     * @param param0."1" The ESP force applied to the control axis.
     * @returns The control axis output mapped from the specified input state.
     */
    private static mapControlAxis;
    /**
     * Uses default logic to compute a scaling factor to apply to the input control axis increment based on how long the
     * triggering key event's associated key has been held down. The returned scaling factor is equal to `4` if the key
     * has been held for at least 1 second, `2` if the key has been held for at least 0.5 seconds, and `1` otherwise.
     * @param heldTime The amount of time that the key has been held down, in milliseconds.
     * @returns The scaling factor to apply to the input control axis increment given the specified amount of time the
     * key has been held down.
     */
    private static defaultKeyTimingFactor;
}

/**
 * Configuration options for {@link FlightPathCalculatorManager}.
 */
type FlightPathCalculatorManagerOptions = {
    /** The ID of the flight path calculator to manage. Defaults to the empty string (`''`). */
    id?: string;
    /**
     * Whether ADC data is valid, or `undefined` if flight path calculations do not use ADC data for calculating airplane
     * speed.
     */
    isAdcDataValid?: Subscribable<boolean>;
    /**
     * Whether GPS data is valid, or `undefined` if flight path calculations do not use GPS data for calculating airplane
     * speed.
     */
    isGpsDataValid?: Subscribable<boolean>;
    /** The maximum bank angle, in degrees, supported outside of Low Bank Mode. */
    maxBankAngle: number;
    /** The maximum bank angle, in degrees, supported in Low Bank Mode. Defaults to `maxBankAngle`. */
    lowBankAngle?: number;
};
/**
 * A manager which automatically sets flight path calculator bank angles and airplane speed modes in response to
 * autopilot Low Bank Mode and ADC/GPS data validity, respectively.
 */
declare class FlightPathCalculatorManager {
    private readonly bus;
    private readonly publisher;
    private readonly setOptionsTopic;
    private readonly calculatorId;
    private readonly maxBankAngle;
    private readonly lowBankAngle;
    private isLowBank?;
    private readonly speedDataState;
    private isAlive;
    private isInit;
    private lowBankSub?;
    /**
     * Creates a new instance of FlightPathCalculatorManager.
     * @param bus The event bus.
     * @param options Options with which to configure the new manager.
     */
    constructor(bus: EventBus, options: Readonly<FlightPathCalculatorManagerOptions>);
    /**
     * Creates a new instance of FlightPathCalculatorManager.
     * @param bus The event bus.
     * @param isAdcDataValid Whether ADC data is valid, or `undefined` if flight path calculations do not use ADC data
     * for calculating airplane speed.
     * @param isGpsDataValid Whether GPS data is valid, or `undefined` if flight path calculations do not use GPS data
     * for calculating airplane speed.
     * @param maxBankAngle The maximum bank angle, in degrees, supported outside of Low Bank Mode.
     * @param lowBankAngle The maximum bank angle, in degrees, supported in Low Bank Mode. Defaults to `maxBankAngle`.
     * @deprecated Please use the constructor overload that accepts the options object instead.
     */
    constructor(bus: EventBus, isAdcDataValid: Subscribable<boolean> | undefined, isGpsDataValid: Subscribable<boolean> | undefined, maxBankAngle: number, lowBankAngle?: number);
    /**
     * Initializes this manager. Once this manager is initialized, it will automatically set the maximum bank angle and
     * airplane speed mode used by the flight path calculator.
     * @throws Error if this manager has been destroyed.
     */
    init(): void;
    /**
     * Responds to when autopilot Low Bank Mode is activated or deactivated.
     * @param isLowBank Whether autopilot Low Bank Mode is active.
     */
    private onLowBankChanged;
    /**
     * Responds to when the validity state of speed data changes.
     * @param state The validity state of speed data, as `[ADC, GPS]`.
     */
    private onSpeedDataValidityChanged;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * Garmin flight plan user data keys.
 */
declare enum FmsFplUserDataKey {
    /** The name of the flight plan. */
    Name = "name",
    /** Data describing the flight plan's loaded visual approach procedure. */
    VisualApproach = "visual_approach_data",
    /**
     * The designation of the runway associated with the flight plan's loaded visual approach procedure.
     * @deprecated
     */
    VisualApproachRunway = "visual_approach",
    /** Data describing the flight plan's loaded VFR approach procedure. */
    VfrApproach = "vfr_approach_data",
    /** Whether the flight plan's loaded approach procedure skips an initial course reversal. */
    ApproachSkipCourseReversal = "skipCourseReversal"
}
/**
 * Data describing a visual approach procedure that is loaded into a flight plan.
 */
type FmsFplVisualApproachData = {
    /** The designation of the runway associated with the loaded visual approach procedure. */
    runwayDesignation: string;
    /** Whether the loaded approach is a vectors-to-final (VTF) approach. */
    isVtf: boolean;
};
/**
 * Data describing a VFR approach procedure that is loaded into a flight plan.
 */
type FmsFplVfrApproachData = {
    /** The index of the published approach procedure on which the loaded VFR approach is based. */
    approachIndex: number;
    /** Whether the loaded approach is a vectors-to-final (VTF) approach. */
    isVtf: boolean;
};
/**
 * Mappings from Garmin flight plan user data keys to their data types.
 */
type FmsFplUserDataTypeMap = {
    /** The name of the flight plan. */
    [FmsFplUserDataKey.Name]: string;
    /** Data describing the flight plan's loaded visual approach procedure. */
    [FmsFplUserDataKey.VisualApproach]: Readonly<FmsFplVisualApproachData>;
    /** The designation of the runway associated with the flight plan's loaded visual approach procedure. */
    [FmsFplUserDataKey.VisualApproachRunway]: string;
    /** Data describing the flight plan's loaded VFR approach procedure. */
    [FmsFplUserDataKey.VfrApproach]: Readonly<FmsFplVfrApproachData>;
    /** Whether the flight plan's loaded approach procedure skips an initial course reversal. */
    [FmsFplUserDataKey.ApproachSkipCourseReversal]: boolean;
};

/**
 * A loader of flight plan routes into Garmin avionics.
 */
interface GarminFlightPlanRouteLoader {
    /**
     * Checks whether this loader is currently loading a flight plan route.
     */
    isLoadInProgress(): boolean;
    /**
     * Waits until this loader is finished with any in-progress operation to load a flight plan route. If there is no
     * such operation, then the returned Promise is fulfilled immediately.
     */
    awaitLoad(): Promise<void>;
    /**
     * Loads a flight plan route. This will preempt any existing in-progress route-loading operation.
     * @param route The flight plan route to load.
     * @returns A Promise which is fulfilled when the loading operation ends. The fulfillment value reports whether the
     * operation completed successfully without being cancelled.
     */
    loadRoute(route: ReadonlyFlightPlanRoute): Promise<boolean>;
    /**
     * Stops any in-progress operation by this loader to load a flight plan route.
     * @returns A Promise which is fulfilled after the in-progress operation to load a flight plan route at the time this
     * method is called has been stopped. If there is no in-progress operation, then the Promise is fulfilled
     * immediately.
     */
    cancelLoad(): Promise<void>;
}

/**
 * A provider of Garmin flight plan routes.
 */
interface GarminFlightPlanRouteProvider {
    /**
     * Gets a flight plan route.
     * @returns A flight plan route.
     */
    getRoute(): Promise<ReadonlyFlightPlanRoute>;
}

/**
 * A manager for syncing Garmin flight plan routes to and from the sim. The manager supports automatically replying to
 * avionics route requests and can be used to manually or automatically load synced flight plan routes.
 */
declare class GarminFlightPlanRouteSyncManager {
    private routeManager?;
    private routeLoader?;
    private routeProvider?;
    private isAlive;
    private _isAutoReplying;
    private _isAutoSyncing;
    private readonly initPromise;
    private readonly initPromiseResolve;
    private readonly initPromiseReject;
    private readonly pendingRequestIds;
    private activeReplyPromise?;
    private replyOpId;
    private avionicsRouteRequestSub?;
    private avionicsRouteSyncSub?;
    /**
     * Creates a new instance of GarminFlightPlanRouteSyncManager. The manager is created in an uninitialized state and
     * must be initialized before it can perform any functions.
     */
    constructor();
    /**
     * Creates a Promise that will be used to await this manager's initialization.
     * @returns A Promise that will be used to await this manager's initialization.
     */
    private createInitPromise;
    /**
     * Checks whether this manager is initialized.
     * @returns Whether this manager is initialized.
     */
    isInit(): boolean;
    /**
     * Waits until this manager is initialized.
     * @returns A Promise which is fulfilled when this manager is initialized, or rejected if this manager is destroyed
     * before it is initialized.
     */
    awaitInit(): Promise<void>;
    /**
     * Initializes this manager. Once initialized, this manager will automatically reply to avionics route requests and
     * can be used to manually or automatically load synced avionics routes.
     * @param manager A flight plan route manager.
     * @param loader A flight plan route loader. The loader will be used by this manager to load flight plan routes.
     * @param provider A flight plan route provider. The provider will be used by this manager to retrieve flight plan
     * routes with which to reply to avionics route requests.
     * @throws Error if this manager has been destroyed.
     */
    init(manager: FlightPlanRouteManager, loader: GarminFlightPlanRouteLoader, provider: GarminFlightPlanRouteProvider): void;
    /**
     * Checks whether this manager is currently set to automatically reply to avionics route requests.
     * @returns Whether this manager is currently set to automatically reply to avionics route requests.
     */
    isAutoReplying(): boolean;
    /**
     * Checks whether this manager is currently set to automatically load synced avionics flight plan routes.
     * @returns Whether this manager is currently set to automatically load synced avionics flight plan routes.
     */
    isAutoSyncing(): boolean;
    /**
     * Starts automatically replying to avionics route requests. This will not initiate replies to any existing pending
     * requests; only requests received after this method is called will receive an automatic reply. This method has no
     * effect if this manager is not initialized.
     * @throws Error if this manager has been destroyed.
     */
    startAutoReply(): void;
    /**
     * Stops automatically replying to avionics route requests. This method does not cancel any reply operation that is
     * already in progress. This method has no effect if this manager is not initialized.
     * @throws Error if this manager has been destroyed.
     */
    stopAutoReply(): void;
    /**
     * Starts automatically loading any synced avionics flight plan routes. After automatic sync has started, this
     * manager will wait until the next time a new avionics route is synced before loading the synced route. This method
     * has no effect if this manager is not initialized.
     * @throws Error if this manager has been destroyed.
     */
    startAutoSync(): void;
    /**
     * Stops automatically loading any synced avionics flight plan routes. This method does not cancel any route-loading
     * operation that is already in progress. This method has no effect if this manager is not initialized.
     * @throws Error if this manager has been destroyed.
     */
    stopAutoSync(): void;
    /**
     * Replies to all pending avionics route requests. The reply operations are handled asynchronously and so are not
     * guaranteed to have completed by the time this method returns. This method has no effect if this manager is not
     * initialized.
     * @throws Error if this manager has been destroyed.
     */
    replyToAllPendingRequests(): void;
    /**
     * Replies to a specific avionics route request. The reply operation is handled asynchronously and so is not
     * guaranteed to have completed by the time this method returns. This method has no effect if this manager is not
     * initialized.
     * @param requestId The ID of the request to which to reply.
     * @throws Error if this manager has been destroyed.
     */
    replyToRequest(requestId: number): void;
    /**
     * Stops any in-progress operation to reply to avionics route requests. This method has no effect if this manager is
     * not initialized.
     * @returns A Promise which is fulfilled after the in-progress operation to reply to avionics route requests at the
     * time this method is called has been stopped. If there are no in-progress operations, then the Promise is fulfilled
     * immediately.
     * @throws Error if this manager has been destroyed.
     */
    cancelReply(): Promise<void>;
    /**
     * Loads the most recent synced avionics flight plan route, if one exists. This will preempt any existing in-progress
     * route-loading operation. This method has no effect if this manager is not initialized.
     * @returns A Promise which is fulfilled when the loading operation ends. The fulfillment value reports whether the
     * operation completed successfully without being cancelled.
     * @throws Error if this manager has been destroyed.
     */
    loadFromSyncedRoute(): Promise<boolean>;
    /**
     * Loads a flight plan route. This will preempt any existing in-progress route-loading operation. This method has no
     * effect if this manager is not initialized.
     * @param route The flight plan route to load.
     * @returns A Promise which is fulfilled when the loading operation ends. The fulfillment value reports whether the
     * operation completed successfully without being cancelled.
     * @throws Error if this manager has been destroyed.
     */
    loadRoute(route: ReadonlyFlightPlanRoute): Promise<boolean>;
    /**
     * Stops any in-progress operation to load a synced route. This method has no effect if this manager is not
     * initialized.
     * @returns A Promise which is fulfilled after the in-progress operation to load a synced route into the primary
     * flight plan at the time this method is called has been stopped. If there are no in-progress operations, then the
     * Promise is fulfilled immediately.
     * @throws Error if this manager has been destroyed.
     */
    cancelLoad(): Promise<void>;
    /**
     * Responds to when an avionics route request is received.
     * @param provider The provider from which to get the flight plan route with which to reply to the request.
     * @param manager The flight plan route manager through which the route request was received.
     * @param requestId The ID of the request.
     */
    private onAvionicsRouteRequested;
    /**
     * Responds to when the most recent synced avionics route changes.
     * @param route The most recent synced avionics route.
     */
    private onSyncedAvionicsRouteChanged;
    /**
     * Queues a reply to one or more avionics route requests and starts the process of dequeuing the reply queue if it is not
     * already being dequeued.
     * @param provider The provider from which to get the flight plan route to send with the reply.
     * @param manager The flight plan route manager through which to reply.
     * @param requestIds The IDs of the requests to which to reply.
     */
    private queueReplyToRequests;
    /**
     * Schedules an avionics route reply operation.
     * @param provider The provider from which to get the flight plan route to send with the reply.
     * @param manager The flight plan route manager through which to reply.
     */
    private scheduleReplyToAvionicsRouteRequests;
    /**
     * Replies to all currently pending avionics route requests.
     * @param opId The reply operation ID.
     * @param provider The provider from which to get the flight plan route to send with the reply.
     * @param manager The flight plan route manager through which to reply.
     */
    private replyToAvionicsRouteRequests;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * A utility class for working with Garmin flight plan routes.
 */
declare class GarminFlightPlanRouteUtils {
    /** The default name for flight plan modification batches opened when loading a flight plan route into a flight plan. */
    static readonly DEFAULT_LOAD_ROUTE_BATCH_NAME = "flight-plan-route-load";
    /**
     * Creates a flight plan route representing the structure of a flight plan.
     * @param facLoader The facility loader to use to retrieve facilities referenced in the flight plan.
     * @param flightPlan The flight plan from which to create the route.
     * @returns A flight plan route representing the structure of the specified flight plan.
     */
    static createRouteFromFlightPlan(facLoader: FacilityLoader, flightPlan: FlightPlan): Promise<FlightPlanRoute>;
    /**
     * Converts a flight plan leg into a flight plan route enroute leg.
     * @param facLoader The facility loader to use to retrieve facilities referenced in the flight plan leg.
     * @param leg The flight plan leg.
     * @param out The flight plan route enroute leg object to which to write the results. If not defined, then a new
     * object will be created.
     * @returns The converted flight plan route enroute leg. If the specified flight plan leg could not be converted,
     * then the converted enroute leg will be empty.
     */
    static legToFlightPlanRouteEnrouteLeg(facLoader: FacilityLoader, leg: FlightPlanLeg, out?: FlightPlanRouteEnrouteLeg): Promise<FlightPlanRouteEnrouteLeg>;
}

/**
 * Configuration options for {@link GarminPrimaryFlightPlanRouteLoader}.
 */
type GarminPrimaryFlightPlanRouteLoaderOptions = {
    /**
     * The name to assign the flight plan modification batch opened on the primary flight plan when an operation to load
     * a flight plan route into the plan is in progress. Defaults to
     * {@link GarminFlightPlanRouteUtils.DEFAULT_LOAD_ROUTE_BATCH_NAME}.
     */
    loadRouteBatchName?: string;
    /**
     * Whether to flatten airways to their constituent waypoints when loading a flight plan route into a flight plan.
     * Defaults to `false`.
     */
    flattenAirways?: boolean;
    /**
     * The scope to assign user facilities created by the loader. The scope is written to the airport ident field of the
     * facilities' ICAO values. Must be four characters or less. Defaults to the empty string.
     */
    userFacilityScope?: string;
    /**
     * The prefix to use when assigning idents to user facilities created by the loader. A three-digit number is appended
     * to the prefix to form the full ident. Must be three characters or less. Defaults to `'FPL'`.
     */
    userFacilityIdentPrefix?: string;
};
/**
 * A loader of flight plan routes into the primary flight plan of an instance of {@link Fms}.
 */
declare class GarminPrimaryFlightPlanRouteLoader implements GarminFlightPlanRouteLoader {
    private readonly fms;
    private readonly loadRouteBatchName;
    private readonly flattenAirways;
    private readonly userFacilityScope;
    private readonly userFacilityIdentPrefix;
    private loadOpId;
    private activeLoadPromise?;
    /**
     * Creates a new instance of GarminPrimaryFlightPlanRouteLoader.
     * @param fms The FMS containing the primary flight plan to which the loader loads flight plan routes.
     * @param options Options with which to configure the loader.
     */
    constructor(fms: Fms, options?: Readonly<GarminPrimaryFlightPlanRouteLoaderOptions>);
    /** @inheritDoc */
    isLoadInProgress(): boolean;
    /** @inheritDoc */
    awaitLoad(): Promise<void>;
    /** @inheritDoc */
    loadRoute(route: ReadonlyFlightPlanRoute): Promise<boolean>;
    /** @inheritDoc */
    cancelLoad(): Promise<void>;
    /**
     * Schedules an operation to load a flight plan route into the primary flight plan.
     * @param route The flight plan route to load.
     * @returns A Promise which is fulfilled when the scheduled operation ends. The fulfillment value reports whether
     * the operation successfully completed without being cancelled.
     */
    private scheduleLoadFromRoute;
    /**
     * Loads a flight plan route into the primary flight plan.
     * @param opId The load operation ID.
     * @param route The flight plan route to load.
     * @returns A Promise which is fulfilled when the load operation ends. The fulfillment value reports whether the
     * operation successfully completed without being cancelled.
     */
    private loadFromRoute;
    /**
     * Loads the enroute legs of a flight plan route into the primary flight plan. This method should be called when the
     * primary flight plan does not have any loaded destination, arrival, or approach procedures.
     * @param opId The load operation ID.
     * @param plan The primary flight plan.
     * @param route The flight plan route to load.
     * @returns The desired on-route direct-to target leg within the enroute segments specified by the loaded flight plan
     * route, or `null` if there is no such leg.
     */
    private loadEnrouteLegs;
    /**
     * Retrieves a facility with a given ICAO.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which is fulfilled with the requested facility, or `null` if such a facility could not be
     * found.
     */
    private retrieveFacility;
    /**
     * Retrieves an origin or destination airport and runway.
     * @param airportIcao The ICAO of the airport.
     * @param runwayIdentifier The runway identifier.
     * @returns The airport and runway defined by the specified ICAO and runway identifier.
     */
    private retrieveOriginDest;
    /**
     * Retrieves indexes for a departure or arrival procedure.
     * @param airport The airport in which to search for the procedure.
     * @param procArray The procedure array in which to search for the procedure.
     * @param procedureName The name of the procedure to retrieve.
     * @param transitionName The name of the procedure enroute transition to retrieve.
     * @param runway The runway associated with the procedure runway transition to retrieve, or `undefined` if a runway
     * transition should not be retrieved.
     * @returns The indexes for the departure or arrival procedure defined by the specified parameters.
     */
    private retrieveDepartureArrivalIndexes;
    /**
     * Retrieves indexes for an approach procedure.
     * @param airport The airport in which to search for the approach procedure.
     * @param approachIdentifier The identifier for the approach procedure.
     * @param transitionName The name of the approach transition to retrieve.
     * @returns The indexes for the approach procedure defined by the specified parameters.
     */
    private retrieveApproachIndexes;
    /**
     * Retrieves an intersection facility with a given ICAO.
     * @param icao The ICAO of the intersection facility to retrieve.
     * @returns A Promise which is fulfilled with the requested intersection facility, or `null` if such a facility could
     * not be found.
     */
    private retrieveIntersectionFacility;
    /**
     * Retrieves the type-matched facility corresponding to an intersection facility.
     * @param facility The intersection facility for which to retrieve the type-matched facility.
     * @returns A Promise which is fulfilled with the requested facility, or `null` if such a facility could not be
     * found.
     */
    private retrieveFacilityFromIntersection;
    /**
     * Retrieves an airway connecting two waypoints.
     * @param airwayName The name of the airway to retrieve.
     * @param entryFacility The entry waypoint.
     * @param exitFacility The exit waypoint.
     * @returns A Promise which is fulfilled with the requested airway, or `null` if such an airway could not be found.
     */
    private retrieveAirway;
    /**
     * Gets an array of all user facility indexes that are currently in-use, sorted in ascending order.
     * @returns An array of all user facility indexes that are currently in-use, sorted in ascending order.
     */
    private getInUseUserFacilityIndexes;
    /**
     * Gets an array of all user facility indexes that are referenced in a flight plan.
     * @param plan The flight plan to check.
     * @returns An array of all user facility indexes that are references in the specified flight plan.
     */
    private getInUseUserFacilityIndexesFromPlan;
    /**
     * Creates a new user facility to reference from a flight plan leg.
     * @param latLon The latitude/longitude coordinates of the facility to create.
     * @param index The index of the facility to create.
     * @returns A new user facility with the specified parameters.
     */
    private createUserFacility;
}

/**
 * A provider of flight plan routes representing the structure of the primary flight plan of an instance of
 * {@link Fms}.
 */
declare class GarminPrimaryFlightPlanRouteProvider implements GarminFlightPlanRouteProvider {
    private readonly fms;
    /**
     * Creates a new instance of GarminPrimaryFlightPlanRouteProvider.
     * @param fms The FMS containing the primary flight plan from which this provider sources flight plan routes.
     */
    constructor(fms: Fms);
    /**
     * Gets a flight plan route representing the structure of the primary flight plan loaded in this provider's `Fms`
     * instance.
     * @returns A flight plan route representing the structure of the primary flight plan loaded in this provider's `Fms`
     * instance.
     */
    getRoute(): Promise<ReadonlyFlightPlanRoute>;
}

/** General Garmin-related control events. */
interface GarminControlEvents {
    /**
     * An event that indicates whether or not OBS is available.
     * @deprecated Use the equivalent topic defined in `LNavDataEvents` instead.
     */
    obs_available: boolean;
    /** Signals that the flight director is not installed if `true`. */
    fd_not_installed: boolean;
}

/**
 * A manager for minimums units. Keeps the minimums unit in sync with the Garmin altitude display units setting.
 */
declare class MinimumsUnitsManager {
    private readonly bus;
    private readonly publisher;
    private readonly altitudeUnitsSetting;
    private isAlive;
    private isInit;
    private altitudeUnitsSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Initializes this manager. Once initialized, this manager will automatically keep the minimums unit in sync with
     * the Garmin altitude display units setting until it is destroyed.
     * @throws Error if this manager has been destroyed.
     */
    init(): void;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * FMS positioning system data modes.
 */
declare enum FmsPositionMode {
    /** No position data is available. */
    None = "None",
    /** Position data is sourced from GPS. */
    Gps = "Gps",
    /** Position data is sourced from DME/DME. */
    Dme = "Dme",
    /** Position data is sourced from HNS (hybrid inertial navigation). */
    Hns = "Hns",
    /** Position data is sourced from dead reckoning. */
    DeadReckoning = "DeadReckoning",
    /** Position data is sourced from dead reckoning and more than 20 minutes have elapsed since the last accurate position fix. */
    DeadReckoningExpired = "DeadReckoningExpired"
}
/**
 * Topics for bus events from which FMS geo-positioning data is sourced.
 */
type FmsPositionDataSourceTopics = 'gps-position' | 'ground_speed' | 'track_deg_true' | 'track_deg_magnetic';
/**
 * Data events published by the GPS receiver system sourced from GNSS.
 */
type FmsPositionGNSSDataEvents = {
    [P in Extract<FmsPositionDataSourceTopics, keyof GNSSEvents> as `fms_pos_${P}_${number}`]: GNSSEvents[P];
};
/**
 * Events fired by the FMS geo-positioning system.
 */
interface FmsPositionSystemEvents extends FmsPositionGNSSDataEvents {
    /** An event fired when the FMS geo-positioning system state changes. */
    [fms_pos_state_: `fms_pos_state_${number}`]: AvionicsSystemStateEvent;
    /** The current positioning mode used by the FMS geo-positioning system. */
    [fms_pos_mode_: `fms_pos_mode_${number}`]: FmsPositionMode;
    /**
     * The index of the GPS receiver currently used by the FMS geo-positioning system, or `-1` if the system is not
     * using any GPS receiver.
     */
    [fms_pos_gps_index_: `fms_pos_gps_index_${number}`]: number;
    /** The index of the HNS currently used by the FMS geo-positioning system, or `-1` if the system is not using any HNS. */
    [fms_pos_hns_index_: `fms_pos_hns_index_${number}`]: number;
    /**
     * The index of the DME/DME navigation system currently used by the FMS geo-positioning system, or `-1` if the system
     * is not using any DME/DME system.
     */
    [fms_pos_dme_index_: `fms_pos_dme_index_${number}`]: number;
}
/**
 * A Garmin FMS geo-positioning system.
 */
declare class FmsPositionSystem extends BasicAvionicsSystem<FmsPositionSystemEvents> {
    private static readonly DEAD_RECKONING_EXPIRE_TIME;
    protected initializationTime: number;
    private readonly gnssDataSourceTopicMap;
    private readonly modeTopic;
    private readonly gpsIndexTopic;
    private readonly hnsIndexTopic;
    private readonly dataSourceSubscriber;
    private readonly gpsIndex;
    private readonly hnsIndex;
    private readonly dmeIndex;
    private readonly adcIndex;
    private readonly ahrsIndex;
    private readonly dataSubs;
    private readonly simTime;
    private readonly gpsStateSource;
    private readonly gpsState;
    private mode;
    private lastFixTime;
    /**
     * Creates an instance of an FMS geo-positioning system.
     * @param index The index of the FMS geo-positioning system.
     * @param bus An instance of the event bus.
     * @param gpsReceiverIndex The index of the GPS receiver used by this system. No GPS data will be used if the index
     * is negative.
     * @param adcIndex The index of the ADC used by this system in dead reckoning mode to obtain airspeed data.
     * @param ahrsIndex The index of the AHRS used by this system in dead reckoning mode to obtain heading data.
     * @param hnsIndex The index of the HNS used by this system. No HNS data will be used if the index is negative.
     * Defaults to `-1`.
     * @param dmeIndex The index of the DME/DME navigation system used by this system. No DME/DME data will be used if
     * the index is negative. Defaults to `-1`.
     * @param powerSource The source from which to retrieve the system's power state. Can be an event bus topic defined
     * in {@link ElectricalEvents} with boolean-valued data, an XML logic element that evaluates to zero (false) or
     * non-zero (true) values, or a boolean-valued subscribable. If not defined, then the system will be considered
     * always powered on.
     */
    constructor(index: number, bus: EventBus, gpsReceiverIndex: number | Subscribable<number>, adcIndex: number | Subscribable<number>, ahrsIndex: number | Subscribable<number>, hnsIndex?: number | Subscribable<number>, dmeIndex?: number | Subscribable<number>, powerSource?: SystemPowerKey | CompositeLogicXMLElement | Subscribable<boolean>);
    /**
     * Starts publishing data on the event bus.
     */
    private startDataPublish;
    /**
     * Responds to when someone first subscribes to one of this system's GNSS-sourced data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    private onGnssTopicSubscribed;
    /** @inheritdoc */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Updates this system's data mode.
     */
    private updateMode;
    /**
     * Sets this system's data mode, and publishes the new value to the event bus if it differs from the current value.
     * @param mode The new data mode.
     */
    private setMode;
}

/**
 * Automatically selects the best FMS geo-positioning system from a set of candidates based on the accuracy of their
 * provided positioning data.
 */
declare class FmsPositionSystemSelector {
    private readonly bus;
    private static readonly FMS_POS_MODE_PRIORITIES;
    private readonly enabledSystemIndexes;
    private readonly preferredSystemIndex;
    private readonly _selectedIndex;
    /** The index of the selected FMS geo-positioning system, or `-1` if no system could be selected. */
    readonly selectedIndex: Subscribable<number>;
    private readonly _selectedFmsPosMode;
    /** The positioning mode of the selected FMS geo-positioning system. */
    readonly selectedFmsPosMode: Subscribable<FmsPositionMode>;
    private readonly fmsPosModes;
    private isAlive;
    private isInit;
    private enabledSystemIndexesSub?;
    private preferredSystemIndexSub?;
    private fmsPosModePipe?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param enabledSystemIndexes The indexes of the FMS geo-positioning systems from which to select.
     * @param preferredSystemIndex The index of this selector's preferred system, or `-1` if there is no such system
     * This selector is guaranteed to select the preferred system if its state is at least as desirable as the state of
     * all other systems from which to select.
     */
    constructor(bus: EventBus, enabledSystemIndexes: Iterable<number> | SubscribableSet<number>, preferredSystemIndex?: number | Subscribable<number>);
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the FMS geo-positioning system
     * that currently provides the most accurate position data.
     * @throws Error if this selector has been destroyed.
     */
    init(): void;
    /**
     * Selects the index of the FMS geo-positioning system with the most desirable state.
     */
    private selectIndex;
    /**
     * Destroys this manager.
     */
    destroy(): void;
    /**
     * Compares two FMS geo-positioning system modes and returns a number whose sign indicates which one is more
     * desirable.
     * @param a The first mode to compare.
     * @param b The second mode to compare.
     * @returns A negative number of mode `a` is more desirable than `b`, a positive number if mode `b` is more desirable
     * than `a`, or zero if the two modes are equally desirable.
     */
    private static compareFmsPosMode;
}

/**
 * Configuration options for {@link GarminExistingUserWaypointsArray}.
 */
type GarminExistingUserWaypointsArrayOptions = {
    /**
     * The scope of the user waypoints to include in the array. The scope is read from the airport ident field of the
     * waypoints' ICAO values.
     */
    scope?: string;
};
/**
 * An array of all existing user waypoints. Each instance of this class is automatically updated to contain all
 * existing user waypoints in the order in which they were added.
 */
declare class GarminExistingUserWaypointsArray extends AbstractSubscribableArray<FacilityWaypoint<UserFacility>> {
    private readonly facWaypointCache;
    private readonly scope;
    private readonly _array;
    /** @inheritDoc */
    get length(): number;
    private readonly facRepoSubs;
    /**
     * Creates a new instance of GarminExistingUserWaypointsArray.
     * @param facRepo The facility repository.
     * @param bus The event bus.
     * @param facWaypointCache A cache from which to retrieve facility waypoints.
     * @param options Options with which to configure the array.
     */
    constructor(facRepo: FacilityRepository, bus: EventBus, facWaypointCache: FacilityWaypointCache, options?: Readonly<GarminExistingUserWaypointsArrayOptions>);
    /** @inheritDoc */
    getArray(): readonly FacilityWaypoint<UserFacility>[];
    /**
     * Responds to when a user facility is added.
     * @param facility The added facility.
     */
    private onFacilityAdded;
    /**
     * Responds to when a user facility is removed.
     * @param facility The removed facility.
     */
    private onFacilityRemoved;
    /**
     * Destroys this array. Once destroyed, the state of the array will no longer reflect all existing user waypoints.
     */
    destroy(): void;
}

/**
 * A Garmin-specific implementation of {@link FacilityWaypointCache}.
 */
declare class GarminFacilityWaypointCache implements FacilityWaypointCache {
    private readonly bus;
    readonly size: number;
    private static INSTANCE;
    private readonly cache;
    /**
     * Creates a new instance of GarminFacilityWaypointCache.
     * @param bus The event bus.
     * @param size The maximum size of this cache.
     */
    private constructor();
    /**
     * Gets a waypoint from the cache for a specific facility. If one does not exist, a new waypoint will be created.
     * @param facility The facility for which to get a waypoint.
     * @returns A waypoint.
     */
    get<T extends Facility>(facility: Facility): FacilityWaypoint<T>;
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param key The key of the waypoint to add.
     * @param waypoint The waypoint to add.
     */
    private addToCache;
    /**
     * Gets a GarminFacilityWaypointCache instance.
     * @param bus The event bus.
     * @returns A GarminFacilityWaypointCache instance.
     */
    static getCache(bus: EventBus): GarminFacilityWaypointCache;
    /**
     * Gets the cache key for a facility.
     * @param facility A facility.
     * @returns The cache key for the specified facility.
     */
    private static getFacilityKey;
}

/**
 * Active navigation sources for Garmin avionics.
 */
declare enum ActiveNavSource {
    Nav1 = 0,
    Nav2 = 1,
    Gps1 = 2,
    Gps2 = 3
}
/**
 * Sim var names for Garmin navigation data.
 */
declare enum GarminNavVars {
    /** The active navigation source for the pilot. */
    ActiveNavSource1 = "L:WTGarmin_Nav_ActiveNavSource:1",
    /** The active navigation source for the copilot. */
    ActiveNavSource2 = "L:WTGarmin_Nav_ActiveNavSource:2"
}
/**
 * Garmin events related to navigation.
 */
interface GarminNavEvents {
    /** The active navigation source for the pilot. */
    active_nav_source_1: ActiveNavSource;
    /** The active navigation source for the copilot. */
    active_nav_source_2: ActiveNavSource;
}
/**
 * A publisher for Garmin navigation sim var events.
 */
declare class GarminNavSimVarPublisher extends SimVarPublisher<GarminNavEvents> {
    private static readonly simvars;
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus: EventBus);
}

/**
 * A provider of GPS integrity data.
 */
interface GpsIntegrityDataProvider {
    /** The current data mode used by the FMS geo-positioning system. */
    fmsPosMode: Subscribable<FmsPositionMode>;
    /** Whether the current GPS integrity is sufficient for the current phase of flight. */
    isIntegritySufficient: Subscribable<boolean>;
}
/**
 * A default implementation of {@link GpsIntegrityDataProvider}.
 */
declare class DefaultGpsIntegrityDataProvider implements GpsIntegrityDataProvider {
    private readonly bus;
    private readonly _fmsPosMode;
    /** @inheritdoc */
    readonly fmsPosMode: Subscribable<FmsPositionMode>;
    private readonly _isIntegritySufficient;
    /** @inheritdoc */
    readonly isIntegritySufficient: Subscribable<boolean>;
    private readonly cdiScalingMode;
    private readonly fmsPosIndex;
    private isInit;
    private isAlive;
    private isPaused;
    private fmsPosIndexSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param fmsPosIndex The index of the FMS geo-positioning system that is the source of this provider's data.
     */
    constructor(bus: EventBus, fmsPosIndex: number | Subscribable<number>);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * The state of a GPS receiver used for selection.
 */
type GpsReceiverSelectionState = readonly [
    systemState: GPSSystemState,
    pdop: number,
    hdop: number,
    vdop: number
];
/**
 * Configuration options for {@link GpsReceiverSelector}.
 */
type GpsReceiverSelectorOptions = {
    /**
     * The priorities for selecting individual GPS receivers. If two receivers have the same desirability, then the one
     * with the higher priority will be selected. If a receiver's priority is not defined, then it will default to a
     * value of `0`. The priorities can be specified as an array of GPS receiver indexes or a map of GPS receiver indexes
     * to the priorities for selecting those receivers. If specified as an array of indexes, then each receiver whose
     * index appears in the array will be assigned a priority equal to `array.length - array.indexOf(index)`.
     */
    receiverPriorities?: readonly number[] | ReadonlyMap<number, number> | SubscribableMap<number, number>;
    /**
     * A function that compares the desirability of two GPS receivers. If not defined, then a set of default criteria
     * will be used to compare desirability.
     * @param a The state of the first GPS receiver.
     * @param b The state of the second GPS receiver.
     * @returns A number representing the relative desirability of the two GPS receivers: negative if receiver `a` is
     * more desirable than `b`, positive if receiver `b` is more desirable than `a`, and `0` if both are equally
     * desirable.
     */
    desirabilityComparator?: (a: GpsReceiverSelectionState, b: GpsReceiverSelectionState) => number;
};
/**
 * Automatically selects the best GPS receiver from a set of candidates based on the current states of all receivers.
 * Receivers that have computed a 3D position solution with differential corrections are favored over those that have
 * computed a 3D solution without corrections, and either of these are favored over those that have not computed any
 * position solution.
 */
declare class GpsReceiverSelector {
    private readonly bus;
    private readonly candidateReceiverIndexes;
    private readonly receiverPriorities;
    private readonly _selectedIndex;
    readonly selectedIndex: Subscribable<number>;
    private readonly receiverEntries;
    private readonly receiverOrder;
    private readonly receiverPriorityComparator;
    private readonly desirabilityComparator;
    private needReselect;
    private isAlive;
    private isInit;
    private candidateReceiverIndexesSub?;
    private preferredReceiverIndexSub?;
    private receiverPrioritiesSub?;
    private updateSub?;
    /**
     * Creates a new instance of GpsReceiverSelector.
     * @param bus The event bus.
     * @param candidateReceiverIndexes The indexes of the GPS receivers from which to select.
     * @param options Options with which to configure the selector.
     */
    constructor(bus: EventBus, candidateReceiverIndexes: Iterable<number> | SubscribableSet<number>, options?: Readonly<GpsReceiverSelectorOptions>);
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best GPS receiver among
     * its candidates.
     * @throws Error if this selector has been destroyed.
     */
    init(): void;
    /**
     * Updates this selector.
     */
    private update;
    /**
     * Selects the index of the GPS receiver with the most desirable state.
     */
    private selectIndex;
    /**
     * Destroys this selector.
     */
    destroy(): void;
    private static readonly GPS_STATE_PRIORITIES;
    /**
     * A function that compares the desirability of two GPS receivers using a set of default criteria. A receiver is
     * deemed more desirable than another if and only if its system state is located higher than the other's state in the
     * following hierarchy:
     * 1. `GPSSystemState.DiffSolutionAcquired`
     * 2. `GPSSystemState.SolutionAcquired`
     * 3. `GPSSystemState.Acquiring` / `GPSSystemState.Searching`
     * @param a The state of the first GPS receiver.
     * @param b The state of the second GPS receiver.
     * @returns A number representing the relative desirability of the two GPS receivers: negative if receiver `a` is
     * more desirable than `b`, positive if receiver `b` is more desirable than `a`, and `0` if both are equally
     * desirable.
     */
    private static defaultDesirabilityComparator;
}

/**
 * Configuration options for {@link NavdataComputer}.
 */
type NavdataComputerOptions = {
    /** The index of the LNAV computer from which to source data. Defaults to `0`. */
    lnavIndex?: number;
    /**
     * Whether to use the sim's native OBS state. If `true`, then the sim's OBS state as exposed through the event bus
     * topics defined in `NavEvents` will be used. If `false`, then the OBS state exposed through the event bus topics
     * defined in `LNavObsEvents` will be used. Defaults to `true`.
     */
    useSimObsState?: boolean;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
    /** Whether to use VFR instead of IFR CDI scaling logic. Defaults to `false`. */
    useVfrCdiScaling?: boolean | Subscribable<boolean>;
};
/**
 * Computes Garmin LNAV-related data.
 */
declare class NavdataComputer {
    private readonly bus;
    private readonly flightPlanner;
    private readonly facilityLoader;
    private static readonly GLIDEPATH_ANGULAR_SCALE;
    private static readonly GLIDEPATH_SCALE_TAN;
    private readonly geoPointCache;
    private readonly publisher;
    /** The index of the LNAV computer from which this computer sources data. */
    readonly lnavIndex: number;
    private readonly useSimObsState;
    private readonly eventBusTopicPublishers;
    private readonly vnavIndex;
    private isVNavIndexValid;
    private readonly vnavTopicMap;
    private readonly useVfrCdiScaling;
    private readonly planePos;
    private readonly magVar;
    private readonly isObsActive;
    private readonly obsAvailable;
    private approachDetails;
    private readonly lnavIsTracking;
    private readonly lnavLegIndex;
    private readonly lnavVectorIndex;
    private readonly lnavTransitionMode;
    private readonly lnavIsSuspended;
    private readonly lnavDtk;
    private readonly lnavXtk;
    private readonly lnavLegDistanceAlong;
    private readonly lnavLegDistanceRemaining;
    private readonly isMaprActive;
    private readonly gpServiceLevel;
    private readonly gpDistance;
    private readonly vnavData;
    private readonly nominalPathCircle;
    private primaryPlanOriginFacility?;
    private primaryPlanDestinationFacility?;
    private needUpdateDestination;
    private destinationPlanIndex?;
    private destinationIcao?;
    private destinationFacility?;
    private destinationLeg?;
    /**
     * Creates a new instance of the NavdataComputer.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options Options with which to configure the computer.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, facilityLoader: FacilityLoader, options?: Readonly<NavdataComputerOptions>);
    /**
     * Immediately republishes all event bus topics with their current values.
     */
    private republishEventBusTopics;
    /**
     * Responds to when a flight plan origin or destination changes.
     * @param event The event data describing the change.
     */
    private onOriginDestChanged;
    /**
     * Responds to when a flight plan segment changes.
     * @param event The event data describing the change.
     */
    private onSegmentChanged;
    /**
     * Responds to when a flight plan leg changes.
     * @param event The event data describing the change.
     */
    private onLegChanged;
    /**
     * Responds to when the active flight plan changes.
     */
    private onActivePlanChanged;
    /**
     * Responds to when a flight plan active leg changes.
     * @param event The event data describing the change.
     */
    private onActiveLegChanged;
    private primaryPlanOriginFacilityOpId;
    /**
     * Updates the primary flight plan's origin airport facility.
     * @param icao The ICAO of the origin airport facility, or `undefined` if there is no origin airport.
     */
    private updatePrimaryPlanOriginFacility;
    private primaryPlanDestinationFacilityOpId;
    /**
     * Updates the primary flight plan's destination airport facility.
     * @param icao The ICAO of the destination airport facility, or `undefined` if there is no destination airport.
     */
    private updatePrimaryPlanDestinationFacility;
    /**
     * Computes the nav tracking data, such as XTK, DTK, and distance to turn.
     */
    private computeTrackingData;
    /**
     * Updates the LNAV destination airport.
     */
    private updateDestination;
    private destinationFacilityOpId;
    /**
     * Updates the LNAV destination airport facility.
     * @param icao The ICAO of the destination airport facility, or `undefined` if there is no destination airport.
     */
    private updateDestinationFacility;
    /**
     * Updates a nominal desired track vector, and publishes the data to the event bus if necessary.
     * @param topic The event bus topic associated with the vector.
     * @param globalLegIndex The global index of the leg to which the vector belongs, or `-1` if there is no vector.
     * @param vectorIndex The index of the vector in its parent leg's `flightPath` array, or `-1` if there is no vector.
     */
    private updateDtkVector;
    /**
     * Computes CDI scaling.
     */
    private computeCdiScaling;
    /**
     * Computes CDI scaling using VFR logic.
     */
    private computeVfrCdiScaling;
    /**
     * Computes CDI scaling using IFR logic.
     */
    private computeIfrCdiScaling;
    /**
     * Computes glidepath scaling.
     */
    private computeGpScaling;
    /**
     * Gets the index of the FAF in a segment.
     * @param segment The segment to search.
     * @returns The index of the FAF if found.
     */
    private getFafIndex;
    /**
     * Gets the geo circle describing the nominal path tracked by LNAV.
     * @param leg The flight plan leg currently tracked by LNAV.
     * @param vectorIndex The index of the vector currently tracked by LNAV.
     * @param transitionMode The current LNAV transition mode.
     * @param out The object to which to write the result.
     * @param out.vectorIndex The index of the flight path vector associated with the geo circle.
     * @param out.circle The geo circle.
     * @returns The geo circle describing the initial path of a flight plan leg.
     */
    private getNominalPathCircle;
    /**
     * Gets the geo circle describing the nominal path tracked by LNAV for a flight plan leg whose nominal path is
     * defined by the course at the end of the leg.
     * @param legCalc The calculations for the flight plan leg.
     * @param out The object to which to write the result.
     * @param out.vectorIndex The index of the flight path vector associated with the geo circle.
     * @param out.circle The geo circle.
     * @returns The geo circle describing the initial path of a flight plan leg.
     */
    private getNominalPathCircleForEndCourseLeg;
    /**
     * Gets the geo circle describing the nominal path tracked by LNAV for a hold leg.
     * @param legCalc The calculations for the hold leg.
     * @param out The object to which to write the result.
     * @param out.vectorIndex The index of the flight path vector associated with the geo circle.
     * @param out.circle The geo circle.
     * @returns The geo circle describing the initial path of a flight plan leg.
     */
    private getNominalPathCircleForHoldLeg;
    /**
     * Gets the active distance from the plane position to the leg end.
     * @param leg The leg to get the distance for.
     * @param pos The current plane position.
     * @returns The distance, in nautical miles.
     */
    private getActiveDistance;
    /**
     * Gets the distance remaining, in nautical miles, to the LNAV destination.
     * @param activeLegIndex The global leg index of the active flight plan leg.
     * @param activeLegDistance The distance from the airplane's current position to the end of the active leg, in
     * nautical miles.
     * @returns The distance remaining, in nautical miles, to the LNAV destination, or `-1` if the distance cannot be
     * calculated.
     */
    private getDestinationDistance;
    /**
     * Updates whether OBS is available based on the current active flight plan leg, and sends a control event if OBS
     * availability has changed since the last update.
     * @param activeLeg The active flight plan leg, or `null` if none exists.
     */
    private updateObsAvailable;
    /**
     * Checks and returns the CDI Scale when in an approach.
     * @returns The CDIScaleLabel appropriate for the approach.
     */
    private getApproachCdiScale;
    /**
     * Gets the total distance of the egress transition of a flight plan leg, in nautical miles.
     * @param leg The leg to get the distance for.
     * @returns The total distance distance of the egress transition of the specified flight plan leg, in nautical miles.
     */
    private static getEgressDistance;
}

/**
 * Publishes select {@link NavEvents} topics in lieu of NavProcessor.
 */
declare class NavEventsPublisher {
    private readonly bus;
    private readonly republisher;
    private _isPublishing;
    /**
     * Creates an instance of NavEventPublisher.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Start publishing.
     */
    startPublish(): void;
    /**
     * Stop publishing.
     */
    stopPublish(): void;
    /**
     * A callback called when this publisher receives an update cycle.
     */
    onUpdate(): void;
}

/**
 * LNAV OBS/suspend modes.
 */
declare enum ObsSuspModes {
    NONE = 0,
    SUSP = 1,
    OBS = 2
}
/**
 * A provider for LNAV OBS/suspend data.
 */
interface ObsSuspDataProvider {
    /** The current LNAV OBS/suspend mode. */
    readonly mode: Subscribable<ObsSuspModes>;
    /** Whether OBS mode can be activated. */
    readonly isObsAvailable: Subscribable<boolean>;
    /** The current magnetic OBS course, in degrees. */
    readonly obsCourse: Subscribable<number>;
}
/**
 * Configuration options for {@link DefaultObsSuspDataProvider}.
 */
type DefaultObsSuspDataProviderOptions = {
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
};
/**
 * A default implementation of {@link ObsSuspDataProvider}.
 */
declare class DefaultObsSuspDataProvider implements ObsSuspDataProvider {
    private readonly bus;
    private readonly lnavIndex;
    private readonly isLNavIndexValid;
    private readonly isLNavSuspended;
    private readonly isObsActive;
    /** @inheritDoc */
    readonly mode: Subscribable<ObsSuspModes>;
    private readonly _isObsAvailable;
    /** @inheritDoc */
    readonly isObsAvailable: Subscribable<boolean>;
    private readonly _obsCourse;
    /** @inheritDoc */
    readonly obsCourse: Subscribable<number>;
    private isAlive;
    private isInit;
    private isPaused;
    private lnavIndexSub?;
    /**
     * Creates a new instance of DefaultObsSuspDataProvider.
     * @param bus The event bus.
     * @param options Options with which to configure the data provider.
     */
    constructor(bus: EventBus, options?: Readonly<DefaultObsSuspDataProviderOptions>);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

declare enum NavSensitivity {
    DPRT = "DPRT",
    TERM = "TERM",
    ENR = "ENR",
    OCN = "OCN",
    LNAV = "LNAV",
    LNAVplusV = "LNAV+V",
    VIS = "VISUAL",
    LVNAV = "L/VNAV",
    LPV = "LPV",
    LP = "LP",
    LPplusV = "LP+V",
    MAPR = "MAPR",
    VOR = "VOR",
    ILS = "ILS"
}
declare enum VNavDisplayMode {
    NONE = 0,
    PATH = 1
}
declare enum GPDisplayMode {
    NONE = 0,
    PREVIEW = 1,
    ACTIVE = 2
}
/**
 * A vertical deviation indicator component to be updated by the controller.
 */
interface VerticalDeviationIndicator {
    /** Notifies that the deviation information was updated. */
    updateDeviation(): void;
    /** Notifies that the source deviation sensititivy has been updated. */
    updateSourceSensitivity(): void;
}
/**
 * Encapsulation of the logic for an nav source.
 */
declare class HsiSource {
    source: NavSourceId;
    valid: boolean;
    bearing: number | null;
    distance: number | null;
    deviation: number | null;
    deviationScale: number;
    deviationScaleLabel: CDIScaleLabel | null;
    toFrom: VorToFrom;
    dtk_obs: number | null;
    isLocalizer: boolean;
    hasSignal: boolean;
    hasLocalizer: boolean;
    localizerCourse: number | null;
    hasGlideslope: boolean;
    gsDeviation: number | null;
    altDeviation: number | null;
    hasDme: boolean;
    frequency: number | null;
    /**
     * Create an HSI Source
     * @param id The navsourceid.
     */
    constructor(id: NavSourceId);
}
/**
 * A NavIndicatorController to control what nav sources are being indicated on the panel.
 */
declare class NavIndicatorController {
    fms: Fms;
    bus: EventBus;
    onUpdateDtkBox?: () => void;
    navStates: HsiSource[];
    activeSensitivity: NavSensitivity;
    activeSourceIndex: number;
    hsiMapActive: boolean;
    courseNeedleRefs: any;
    hsiRefs: any;
    hsiMapDeviationRef: any;
    vdi: VerticalDeviationIndicator | undefined;
    private bearingPointerStatus;
    private bearingPointerAdf;
    private bearingPointerDirection;
    private bearingPointerSourceIdxs;
    private bearingValidity;
    private firstRun;
    obsSuspMode: ObsSuspModes;
    private missedApproachActive;
    private lnavLegType;
    private currentSpeed;
    private currentHeading;
    private currentAltitude;
    private currentVNavTodDistance;
    private currentVNavBodDistance;
    private vnavPathInRange;
    private currentVNavTargetAltitude;
    private currentVNavConstraintAltitude;
    private currentVNavFpa;
    private vnavState;
    currentVNavPathMode: VNavPathMode;
    readonly vnavDisplayMode: Subject<VNavDisplayMode>;
    readonly gpDisplayMode: Subject<GPDisplayMode>;
    currentVnavApproachMode: ApproachGuidanceMode;
    private currentLpvDeviation;
    currentLpvDistance: number;
    readonly dmeSourceIndex: Subject<number>;
    readonly dmeDistanceSubject: Subject<number>;
    readonly isLnavCalculating: Subject<boolean>;
    private readonly shouldDisplayPathMode;
    private approachDetails;
    private flightPhase;
    /**
     * Initialize an instance of the NavIndicatorController.
     * @param bus is the event bus
     * @param fms is the fms
     */
    constructor(bus: EventBus, fms: Fms);
    /**
     * Method to monitor nav processor events to keep track of HSI-related data.
     */
    monitorEvents(): void;
    /**
     * A method to check if the VNAV Path is in a displayable range.
     */
    private checkIfVnavPathInRange;
    /**
     * A method to update the VNAV Display Mode Subject.
     */
    private updateVNavDisplayMode;
    /**
     * A method called on flight plan changes to set whether lnav has a valid plan.
     */
    private onFplChange;
    /**
     * Checks the leg type of the active lateral leg.
     * @param index The Global Leg Index.
     */
    private getActiveLegType;
    /**
     * A method called from hsimap when the HSI format is changed.
     * @param hsiMap a bool set to true when the hsiMap should be displayed and false when the rose should be displayed.
     */
    onFormatChange(hsiMap: boolean): void;
    /**
     * A method to compare the incoming NavSourceId with the Active Nav Source.
     * @param source The current selected CDI Source.
     * @returns a bool of whether the incoming NavSourceId is the active nav source.
     */
    private checkIfActive;
    /**
     * A callback called when the CDI Source Changes.
     * @param source The current selected CDI Source.
     */
    private onUpdateCdiSelect;
    /**
     * A callback called to update the nav sensitivity.
     * @param updatedSource is the source that was updated
     */
    private updateSensitivity;
    /**
     * Sets the GPS nav sentitivity value.
     */
    private setGpsSensitivity;
    /**
     * A callback called when the obs updates from the event bus.
     * @param obs The current obs/dtk value.
     */
    private onUpdateDtk;
    /**
     * A callback called when the lnav dtk updates from the event bus.
     * @param dtk The current lnav dtk value.
     */
    private onUpdateLnavDtk;
    /**
     * A callback called when the lnav xtk updates from the event bus.
     * @param xtk The current lnav xtk value.
     */
    private onUpdateLnavXtk;
    /**
     * A callback called when the bearing to an lnav fix updates across the event bus to set the to/from flag for GPS.
     * @param brg The current bearing to the current fix.
     */
    private onUpdateLnavBrg;
    /**
     * A method called when the bearing or dtk to/from an lnav fix updates to set the to/from flag for GPS.
     * @returns Whether the toFrom value has changed.
     */
    private setLnavToFrom;
    /**
     * A callback called when the cdi deviation updates from the event bus.
     * @param deviation The current deviation value.
     */
    private onUpdateCdiDeviation;
    /**
     * A callback called when the vor to/from updates from the event bus.
     * @param toFrom The current to/from value.
     */
    private onUpdateToFrom;
    /**
     * A callback called when the dme updates from the event bus.
     * @param dme The current deviation value.
     */
    private onUpdateDme;
    /**
     * A callback called when the localizer data updates from the event bus.
     * @param localizer The current localizer data.
     */
    private onUpdateLocalizer;
    /**
     * A callback called when the glideslope data updates from the event bus.
     * @param glideslope The current glideslope data.
     */
    private onUpdateGlideslope;
    /**
     * A callback called when the LPV data is updated.
     * @param deviation The LPV vertical deviation.
     * @param distance The LPV lateral distance.
     */
    private onUpdateLpv;
    /**
     * A callback called when the VNAV data is updated.
     * @param deviation The vnav vertical deviation.
     */
    private onUpdateVnav;
    /**
     * A callback called when isLoc value updates from the event bus.
     * @param isLoc The current isLoc value.
     */
    private onUpdateIsLocFreq;
    /**
     * A callback called to slew the obs to the ILS inbound course when an loc becomes valid.
     */
    private slewObs;
    /**
     * A method called when xtk/dtk data updates.
     * @param updatedSource is the source that was updated
     */
    private updateComponentsData;
    /**
     * A method called when any value updates that needs to trigger a component update.
     * @param updatedSource is the source that was updated
     */
    private updateComponentsDisplay;
    /**
     * Utility function to update a given bearing pointer in both the rose and map.
     * @param index The index of the bearing pointer to update.
     * @param func A function to execute on the pointer instances.
     */
    private updateBearingPointers;
    /**
     * Update the source of a bearing pointer.
     * @param data The new bearing source info.
     */
    private updateBearingSrc;
    /**
     * Update the validity of a bearing source.
     * @param data The validity event.
     */
    private updateBearingValidity;
    /**
     * Update the heading of a bearing pointer.
     * @param data The BearingDirection message.
     */
    private updateBearingDir;
    /**
     * Get the index in navStates for a given nav source.  This is a bit of a hack to
     * tie together two distinct data models, but it will do the job for now.
     * @param source The NavSourceId of the desired source.
     * @returns The index of that source in navStates or -1 if not found.
     */
    private getNavSourceIndex;
}

/**
 * Utility class for working with ICAO region codes in a Garmin context.
 */
declare class Regions {
    private static readonly NAME_TABLE;
    /**
     * Gets the Garmin display name of the region associated with a specified ICAO region code.
     * @param code - the 2 character ICAO region code.
     * @returns the Garmin display name of the region.
     */
    static getName(code: string): string;
}

/**
 * Configuration options for {@link WaypointInfoStore}.
 */
type WaypointInfoStoreOptions = {
    /**
     * Whether to fall back to using an airport's city name for region text if the airport's region cannot be found.
     * Defaults to `true`.
     */
    useRegionFallbackForAirport?: boolean;
};
/**
 * A store for commonly used waypoint info.
 */
declare class WaypointInfoStore {
    private readonly planePos?;
    private static readonly NULL_LOCATION;
    /** This store's current waypoint. */
    readonly waypoint: Subject<Waypoint | null>;
    private readonly _facility;
    /** The facility associated with this store's current waypoint. */
    readonly facility: Subscribable<Facility | null>;
    private readonly _location;
    /** The location of this store's current waypoint. */
    get location(): Subscribable<GeoPointInterface>;
    /** The name of this store's current waypoint, or `undefined` if there is no such value. */
    readonly name: Subscribable<string | undefined>;
    /** The region of this store's current waypoint, or `undefined` if there is no such value. */
    readonly region: Subscribable<string | undefined>;
    /** The city associated with this store's current waypoint, or `undefined` if there is no such value. */
    readonly city: Subscribable<string | undefined>;
    private readonly _distance;
    /** The distance from the airplane to this store's current waypoint. */
    get distance(): Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    private readonly _bearing;
    /** The true bearing, in degrees, from the airplane to this store's current waypoint. */
    get bearing(): Subscribable<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
    private readonly _radial;
    /** The radial relative to true north, in degrees, from this store's current waypoint along which the airplane lies. */
    get radial(): Subscribable<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>>;
    private waypointPipe?;
    private waypointSub?;
    private pposSub?;
    private locationSub?;
    private facilityPipe?;
    /**
     * Constructor.
     * @param waypoint A subscribable which provides this store's waypoint, or an initial value to set this store's
     * waypoint. If not defined, this store's waypoint can still be set via its `.waypoint` property.
     * @param planePos A subscribable which provides the current airplane position for this store. If not defined, then
     * this store will not provide distance- or bearing-to-waypoint information.
     * @param options Options with which to configure the store.
     */
    constructor(waypoint?: Waypoint | null | Subscribable<Waypoint | null>, planePos?: Subscribable<GeoPointInterface> | undefined, options?: Readonly<WaypointInfoStoreOptions>);
    /**
     * Gets the region text for a facility.
     * @param useFallbackForAirport Whether to fall back
     * @param facility The facility for which to get region text.
     * @returns The region text for the specified facility, or `undefined` if the region text could not be retrieved.
     */
    private getFacilityRegion;
    /**
     * A callback which is called when this store's waypoint changes.
     * @param waypoint The new waypoint.
     */
    private onWaypointChanged;
    /**
     * A callback which is called when this store's plane position changes.
     * @param planePos The new plane position.
     */
    private onPlanePosChanged;
    /**
     * Updates this store's location information.
     * @param waypoint The store's current waypoint.
     */
    private updateLocation;
    /**
     * Updates this store's distance-to-waypoint information.
     * @param waypoint The store's current waypoint.
     * @param planePos The current position of the airplane.
     */
    private updateDistance;
    /**
     * Updates this store's bearing-to-waypoint information.
     * @param waypoint The store's current waypoint.
     * @param planePos The current position of the airplane.
     */
    private updateBearingRadial;
    /**
     * Destroys this store.
     */
    destroy(): void;
}

/**
 * Information pertaining to a navigation reference. A navigation reference consists of a geographic position and
 * optionally a lateral course defining a great-circle path passing through the reference position, and a vertical
 * path profile.
 */
interface NavReferenceBase {
    /** The ident of the reference. */
    readonly ident: Subscribable<string | null>;
    /** Signal strength received from the reference. A value of zero indicates no signal. */
    readonly signalStrength: Subscribable<number | null>;
    /** The magnetic bearing, in degrees, from the airplane to the reference position. */
    readonly bearing: Subscribable<number | null>;
    /** The distance, in nautical miles, from the airplane to the reference position. */
    readonly distance: Subscribable<number | null>;
    /** The magnetic bearing, in degrees, of the reference course at the reference position. */
    readonly course: Subscribable<number | null>;
    /** The fixed magnetic course, in degrees, of the reference localizer. Only available if the reference is a localizer. */
    readonly localizerCourse: Subscribable<number | null>;
    /** The location of the reference position. */
    readonly location: Subscribable<GeoPointInterface | null>;
    /** Whether the reference is a localizer. */
    readonly isLocalizer: Subscribable<boolean | null>;
    /** Whether the reference has a VOR component. */
    readonly hasNav: Subscribable<boolean | null>;
    /** Whether the reference has a DME component. */
    readonly hasDme: Subscribable<boolean | null>;
    /** Whether the reference has a localizer component. */
    readonly hasLocalizer: Subscribable<boolean | null>;
    /** Whether the reference has a glideslope component. */
    readonly hasGlideSlope: Subscribable<boolean | null>;
    /** The radio frequency of the reference. Only available if the reference is a navaid. */
    readonly activeFrequency: Subscribable<number | null>;
    /** Whether the airplane is heading TO or FROM the reference position as judged from the reference course. */
    readonly toFrom: Subscribable<VorToFrom | null>;
    /**
     * Lateral deviation from the reference course scaled such that a value of +/-1 is equal to full-scale CDI deflection
     * (i.e. the `lateralDeviationScaling` value). Positive values indicate deflection of the CDI to the right (i.e. the
     * airplane is situated to the left of the reference).
     */
    readonly lateralDeviation: Subscribable<number | null>;
    /** The magnitude of full-scale CDI deflection, in nautical miles. */
    readonly lateralDeviationScale: Subscribable<number | null>;
    /** The lateral deviation scaling mode. */
    readonly lateralDeviationScalingMode: Subscribable<number | null>;
    /**
     * Vertical deviation from the reference vertical path profile scaled such that a value of +/-1 is equal to full-
     * scale VDI deflection (i.e. the `verticalDeviationScaling` value). Positive values indicate upward deflection of
     * the VDI (i.e. the airplane is situated below the reference).
     */
    readonly verticalDeviation: Subscribable<number | null>;
    /** The magnitude of full-scale VDI deflection, in feet. */
    readonly verticalDeviationScale: Subscribable<number | null>;
}
/**
 * An abstract implementation of {@link NavReferenceBase}.
 */
declare abstract class AbstractNavReferenceBase implements NavReferenceBase {
    /** @inheritdoc */
    readonly ident: Subject<string | null>;
    /** @inheritdoc */
    readonly signalStrength: Subject<number | null>;
    /** @inheritdoc */
    readonly bearing: Subject<number | null>;
    /** @inheritdoc */
    readonly distance: Subject<number | null>;
    /** @inheritdoc */
    readonly course: Subject<number | null>;
    /** @inheritdoc */
    readonly localizerCourse: Subject<number | null>;
    private readonly _locationRefs;
    private _locationRefPointer;
    /** @inheritdoc */
    readonly location: ComputedSubject<LatLonInterface | null, GeoPointInterface | null>;
    /** @inheritdoc */
    readonly isLocalizer: Subject<boolean | null>;
    /** @inheritdoc */
    readonly hasNav: Subject<boolean | null>;
    /** @inheritdoc */
    readonly hasDme: Subject<boolean | null>;
    /** @inheritdoc */
    readonly hasLocalizer: Subject<boolean | null>;
    /** @inheritdoc */
    readonly hasGlideSlope: Subject<boolean | null>;
    /** @inheritdoc */
    readonly activeFrequency: Subject<number | null>;
    /** @inheritdoc */
    readonly toFrom: Subject<VorToFrom | null>;
    /** @inheritdoc */
    readonly lateralDeviation: Subject<number | null>;
    /** @inheritdoc */
    readonly lateralDeviationScale: Subject<number | null>;
    /** @inheritdoc */
    readonly lateralDeviationScalingMode: Subject<number | null>;
    /** @inheritdoc */
    readonly verticalDeviation: Subject<number | null>;
    /** @inheritdoc */
    readonly verticalDeviationScale: Subject<number | null>;
    protected readonly fields: Map<keyof NavReferenceBase, MutableSubscribable<any, any>>;
    /**
     * Sets all fields to `null`.
     */
    protected clearAll(): void;
}

/**
 * A source of navigation reference data.
 */
interface NavReferenceSource<NameType extends string> extends NavReferenceBase {
    /** The name of this source. */
    readonly name: NameType;
    /** The index of this source. */
    readonly index: number;
    /**
     * Gets the type of this source.
     * @returns The type of this source.
     */
    getType(): NavSourceType;
}
/**
 * A collection of {@link NavReferenceSource|NavReferenceSources}.
 * @template SourceName The names of the navigation reference sources supported by the collection.
 */
interface NavReferenceSources<SourceName extends string> {
    /**
     * Gets a navigation reference source with a given name.
     * @param name The name of the source to get.
     * @returns The specified navigation reference source.
     * @throws Error if a source with the specified name could not be found.
     */
    get(name: SourceName): NavReferenceSource<SourceName>;
}
/**
 * A basic implementation of {@link NavReferenceSources} which stores the sources in a Map.
 * @template SourceName The names of the navigation reference sources supported by the collection.
 */
declare class NavReferenceSourceCollection<SourceName extends string> implements NavReferenceSources<SourceName> {
    private readonly sources;
    /**
     * Creates a new instance of NavReferenceSourceCollection.
     * @param sources The navigation reference sources to include in the collection.
     */
    constructor(...sources: readonly NavReferenceSource<SourceName>[]);
    /** @inheritdoc */
    get(name: SourceName): NavReferenceSource<SourceName>;
}

/**
 * An indicator which presents data derived from a navigation reference source. An indicator may only have up to one
 * source at a time, but its source can be changed.
 */
interface NavReferenceIndicator<SourceName extends string> extends NavReferenceBase {
    /** This indicator's source. */
    readonly source: Subscribable<NavReferenceSource<SourceName> | null>;
    /**
     * Sets this indicator's source. Once the source is set, this indicator's data will be derived from the new source.
     * If the new source is `null`, all of this indicator's data will be set to `null`.
     * @param sourceName The name of a nav source.
     */
    setSource(sourceName: SourceName | null): void;
}
/**
 * A basic implementation of {@link NavReferenceIndicator} whose data is derived directly from its source.
 */
declare class BasicNavReferenceIndicator<SourceName extends string> extends AbstractNavReferenceBase implements NavReferenceIndicator<SourceName> {
    protected readonly navSources: NavReferenceSources<SourceName>;
    private readonly _source;
    /** @inheritdoc */
    readonly source: Subscribable<NavReferenceSource<SourceName> | null>;
    protected readonly sourceSubs: Subscription[];
    /**
     * Creates a new instance of BasicNavReferenceIndicator.
     * @param navSources The possible nav sources from which this indicator can derive data.
     * @param sourceName The initial source to use, if any.
     */
    constructor(navSources: NavReferenceSources<SourceName>, sourceName?: SourceName | null);
    /** @inheritdoc */
    setSource(sourceName: SourceName | null): void;
    /**
     * Updates this nav indicator from a new source.
     * @param newSource The new nav source.
     * @param oldSource The old nav source.
     */
    protected updateFromSource(newSource: NavReferenceSource<SourceName> | null, oldSource: NavReferenceSource<SourceName> | null): void;
}
/**
 * A collection of {@link NavReferenceIndicator|NavReferenceIndicators}.
 * @template SourceName The names of the nav sources supported by the nav indicators contained in the collection.
 * @template IndicatorName The names of the nav indicators contained in the collection.
 */
interface NavReferenceIndicators<SourceName extends string, IndicatorName extends string> {
    /**
     * Gets a nav indicator with a given name.
     * @param name The name of the indicator to get.
     * @returns The specified nav indicator.
     * @throws Error if an indicator with the specified name could not be found.
     */
    get(name: IndicatorName): NavReferenceIndicator<SourceName>;
}
/**
 * A basic implementation of {@link NavReferenceIndicators} which stores the indicators in a Map.
 * @template SourceName The names of the nav sources supported by the nav indicators contained in the collection.
 * @template IndicatorName The names of the nav indicators contained in the collection.
 */
declare class NavReferenceIndicatorsCollection<SourceName extends string, IndicatorName extends string> implements NavReferenceIndicators<SourceName, IndicatorName> {
    private readonly indicators;
    /**
     * Creates a new instance of NavReferenceIndicatorsCollection.
     * @param indicators A map of this collection's nav indicators, keyed by name.
     */
    constructor(indicators?: Map<IndicatorName, NavReferenceIndicator<SourceName>>);
    /** @inheritdoc */
    get(name: IndicatorName): NavReferenceIndicator<SourceName>;
}

/**
 * A {@link NavReferenceSource} which derives its data from an ADF radio signal.
 */
declare class AdfRadioNavSource<NameType extends string> extends AbstractNavReferenceBase implements NavReferenceSource<NameType> {
    readonly name: NameType;
    readonly index: AdfRadioIndex;
    private readonly signal;
    private readonly relativeBearing;
    private readonly heading;
    /**
     * Creates a new instance of AdfRadioNavSource.
     * @param bus The event bus.
     * @param name The name of this source.
     * @param index The index of this source.
     */
    constructor(bus: EventBus, name: NameType, index: AdfRadioIndex);
    /** @inheritdoc */
    getType(): NavSourceType.Adf;
}

/**
 * Configuration options for {@link GpsNavSource}.
 */
type GpsNavSourceOptions = {
    /** The index of the LNAV from which to source data. Defaults to `0`. */
    lnavIndex?: number | Subscribable<number>;
    /** The index of the VNAV from which to source data. Defaults to `0`. */
    vnavIndex?: number | Subscribable<number>;
};
/**
 * A {@link NavReferenceSource} which derives its data from LNAV.
 */
declare class GpsNavSource<NameType extends string> extends AbstractNavReferenceBase implements NavReferenceSource<NameType> {
    readonly name: NameType;
    readonly index: number;
    private readonly lnavIndex;
    private readonly vnavIndex;
    private readonly lnavIsTracking;
    private readonly lnavIsTrackingSource;
    private readonly lnavIdent;
    private readonly lnavBrgMag;
    private readonly lnavDis;
    private readonly lnavDtkMag;
    private readonly lnavXtk;
    private readonly lnavToFrom;
    private readonly lnavCdiScaleLabel;
    private readonly lnavCdiScale;
    private readonly gpAvailable;
    private readonly gpDeviation;
    private readonly gpScale;
    /**
     * Creates a new instance of GpsNavSource.
     * @param bus The event bus.
     * @param name The name of this source.
     * @param index The index of this source.
     * @param options Options with which to configure the source.
     */
    constructor(bus: EventBus, name: NameType, index: number, options?: Readonly<GpsNavSourceOptions>);
    /** @inheritdoc */
    getType(): NavSourceType.Gps;
}

/**
 * A {@link NavReferenceSource} which derives its data from a NAV radio signal.
 */
declare class NavRadioNavSource<NameType extends string> extends AbstractNavReferenceBase implements NavReferenceSource<NameType> {
    readonly name: NameType;
    readonly index: NavRadioIndex;
    private readonly hasSignal;
    private readonly glideSlopeErrorDegrees;
    private readonly navLocalizerCrsRad;
    private readonly navCdi;
    private readonly dmePipe;
    private readonly bearingPipe;
    private readonly vorLla;
    private readonly dmeLla;
    private readonly toFromPipe;
    /**
     * Creates a new instance of NavRadioNavSource.
     * @param bus The event bus.
     * @param name The name of this source.
     * @param index The index of this source.
     */
    constructor(bus: EventBus, name: NameType, index: NavRadioIndex);
    /** @inheritdoc */
    getType(): NavSourceType;
    /**
     * Updates whether this source's reference is a localizer.
     */
    private updateIsLocalizer;
    /**
     * Updates this source's localizer course.
     */
    private updateLocalizerCourse;
    /**
     * Updates this source's vertical deviation.
     */
    private updateVerticalDeviation;
    /**
     * Updates this source's lateral deviation.
     */
    private updateLateralDeviation;
}

/**
 * A `NavReferenceSource` that always provides null data.
 */
declare class NullNavSource<NameType extends string> extends AbstractNavReferenceBase implements NavReferenceSource<NameType> {
    readonly name: NameType;
    private readonly type;
    readonly index: number;
    /**
     * Creates a new instance of EmptyNavSource.
     * @param name The name of this source.
     * @param type The type of this source.
     * @param index The index of this source.
     */
    constructor(name: NameType, type: NavSourceType, index: number);
    /** @inheritDoc */
    getType(): NavSourceType;
}

/**
 * A manager for COM radio channel spacing. Syncs COM radio spacing modes with the COM radio spacing user setting and
 * intercepts COM radio spacing toggle key events in order to have them toggle the value of the user setting instead.
 */
declare class ComRadioSpacingManager {
    private readonly bus;
    private readonly comRadioSettingManager;
    private readonly comRadioCount;
    private keyEventManager?;
    private readonly spacingSetting;
    private readonly keys;
    private isDebouncing;
    private isAlive;
    private isInit;
    private spacingSettingSub?;
    private keyEventSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param comRadioSettingManager A manager for COM radio user settings.
     * @param comRadioCount The number of supported COM radios. Defaults to `2`.
     */
    constructor(bus: EventBus, comRadioSettingManager: UserSettingManager<ComRadioUserSettingTypes>, comRadioCount?: 0 | 1 | 2 | 3);
    /**
     * Initializes this manager. Once this manager is initialized, it will automatically set the spacing mode of COM
     * radios based on the COM radio spacing user setting and intercept COM radio spacing toggle key events in order to
     * have them toggle the value of the user setting instead. If this manager is not yet ready to intercept key events
     * when this method is called, initialization will be suspended until the manager is ready to intercept key events.
     * @throws Error if this manager has been destroyed.
     */
    init(): void;
    /**
     * Performs initialization of this manager.
     * @param keyEventManager A key event manager.
     */
    private doInit;
    /**
     * Updates the spacing mode of this manager's supported COM radios based on the COM radio spacing user setting.
     * @param keyEventManager A key event manager.
     */
    private updateSpacing;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * A system that manages Garmin softkey menus.
 *
 * Individual softkey menus are registered with the menu system under a unique string name. After a menu is registered,
 * it can be pushed onto the system's menu stack. The top-most menu in the stack is considered the current menu. Menu
 * navigation is achieved using operations on the stack:
 * * push: navigates to a new menu while preserving history.
 * * replace: navigates to a new menu without preserving history.
 * * pop: return to the previous menu stored in history.
 * * clear: removes the current menu and clears all history.
 */
declare class SoftKeyMenuSystem {
    readonly bus: EventBus;
    /** This system's menu stack. */
    private readonly menuStack;
    /** This system's registered menus. */
    private readonly registeredMenus;
    /** The top element in this system's menu stack. */
    private get menuStackTop();
    private readonly _currentMenu;
    /** The current menu, or `null` if there is no current menu. */
    readonly currentMenu: Subscribable<SoftKeyMenu | null>;
    /**
     * Creates an instance of SoftKeyMenuSystem.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus: EventBus);
    /**
     * Registers a softkey menu with this menu system under a given name. If an existing menu is registered under the
     * same name, it will be replaced by the new menu.
     * @param name The name under which to register the menu.
     * @param factory A function which creates the menu to register.
     */
    registerMenu(name: string, factory: (menuSystem: SoftKeyMenuSystem) => SoftKeyMenu): void;
    /**
     * Gets the softkey menu registered under a given name.
     * @param menuName The name of the menu.
     * @returns The softkey menu registered under the specified name, or `undefined` if there is no such menu.
     */
    getMenu(menuName: string): SoftKeyMenu | undefined;
    /**
     * Pushes a menu onto this system's menu stack. The pushed menu will become the new current menu.
     * @param name The name of the menu to push.
     * @throws Error if this system has no menu registered under the given name.
     */
    pushMenu(name: string): void;
    /**
     * Replaces the current menu with another menu. The current menu will be removed from the stack and the replacement
     * menu will become the new current menu.
     * @param name The name of the replacement menu.
     * @throws Error if this system has no menu registered under the given name.
     */
    replaceMenu(name: string): void;
    /**
     * Removes this system's current menu from the menu stack and makes the next highest menu on the stack the new
     * current menu.
     */
    back(): void;
    /**
     * Clears this system's menu stack of all menus.
     */
    clear(): void;
    /**
     * Handles a softkey press.
     * @param index The index of the pressed softkey.
     */
    onSoftKeyPressed(index: number): void;
}

/**
 * A Garmin softkey menu item. Defines the display and behavior of a softkey.
 */
interface SoftKeyMenuItem {
    /** The label for this menu item. */
    readonly label: Subject<string>;
    /** The handler to invoke when this menu item is pressed. */
    handler?: (menu: SoftKeyMenu) => void;
    /** Whether this menu item is disabled. */
    readonly disabled: Subject<boolean>;
    /** An event that fires when this menu item is pressed. */
    readonly pressed: SubEvent<SoftKeyMenu, void>;
    /** The value of this menu item, if any. */
    readonly value: Subject<boolean | string | undefined>;
    /** Whether this menu item is highlighted. */
    readonly highlighted: Subject<boolean>;
}
/**
 * A Garmin softkey menu. Each menu contains up to 12 indexed menu items, each of which defines the display and
 * behavior of a corresponding softkey.
 */
declare class SoftKeyMenu {
    protected menuSystem: SoftKeyMenuSystem;
    /** The number of softkeys in each menu. */
    static readonly SOFTKEY_COUNT = 12;
    /** The menu items in this menu. */
    private readonly menuItems;
    /**
     * Creates an instance of a SoftKeyMenu.
     * @param menuSystem The menu system that will manage this menu.
     */
    constructor(menuSystem: SoftKeyMenuSystem);
    /**
     * Adds a menu item to the softkey menu.
     * @param index The softkey index to add the menu item to. Must be between 0 and 11, inclusive.
     * @param label The label of the menu item.
     * @param handler The handler to call when the menu item is selected.
     * @param value The value of the menu item, if any.
     * @param disabled Whether or not the menu item is disabled.
     * @returns The new menu item.
     * @throws Error if `index` is out of bounds.
     */
    addItem(index: number, label: string, handler?: (menu: SoftKeyMenu) => void, value?: boolean | string, disabled?: boolean): SoftKeyMenuItem;
    /**
     * Removes a menu item from the menu.
     * @param index The softkey index to remove the menu item from. Must be between 0 and 11, inclusive.
     * @throws Error if `index` is out of bounds.
     */
    removeItem(index: number): void;
    /**
     * Gets a menu item.
     * @param index The index of the menu item. Must be between 0 and 11, inclusive.
     * @returns The requested menu item.
     * @throws Error if `index` is out of bounds.
     */
    getItem(index: number): SoftKeyMenuItem | null;
    /**
     * Handles a back menu action.
     */
    handleBack(): void;
    /**
     * Iterates over the menu items.
     * @param each The function to run over each menu item.
     */
    forEach(each: (menuItem: SoftKeyMenuItem | null, index: number) => void): void;
    /**
     * Handles when a menu item is pressed.
     * @param index The index of the menu item that was pressed.
     */
    handleItemPressed(index: number): void;
    /**
     * Destroys this menu.
     */
    destroy(): void;
}

/**
 * Component props for SoftKey.
 */
interface SoftKeyProps extends ComponentProps {
    /** The menu item to bind to the softkey. */
    menuItem: Subscribable<SoftKeyMenuItem | null>;
    /**
     * The amount of time, in milliseconds, to display the softkey pressed animation after the softkey has been pressed.
     * Defaults to {@link SoftKey.DEFAULT_PRESSED_DURATION}.
     */
    pressedDuration?: number;
    /** CSS class(es) to apply to the softkey's root element. */
    class?: string | SubscribableSet<string>;
}
/**
 * An individual Garmin softkey tab display.
 */
declare class SoftKey extends DisplayComponent<SoftKeyProps> {
    private static readonly DEFAULT_PRESSED_DURATION;
    private static readonly RESERVED_CSS_CLASSES;
    private readonly rootCssClass;
    private readonly label;
    private readonly disabled;
    private readonly highlighted;
    private readonly value;
    private readonly toggleStatusBarState;
    private readonly valueText;
    private readonly pressedTimer;
    private readonly pressedDuration;
    private cssClassSub?;
    private menuItemSub?;
    private labelPipe?;
    private disabledPipe?;
    private highlightedPipe?;
    private valuePipe?;
    private pressedSub?;
    private readonly onPressedHandler;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Unsubscribes from change events on the menu item.
     */
    private unsubscribeFromMenuItem;
    /**
     * Responds to changes in this softkey's disabled state.
     * @param isDisabled Whether this softkey is disabled.
     */
    private onDisabledChanged;
    /**
     * Responds to changes in this softkey's highlighted state.
     * @param isHighlighted Whether this softkey is highlighted.
     */
    private onHighlightedChanged;
    /**
     * Responds to changes in this softkey's value.
     * @param value The new value.
     */
    private onValueChanged;
    /**
     * Responds to when this softkey is pressed.
     */
    private onPressed;
    /**
     * Renders the component.
     * @returns The rendered component VNode.
     */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for SoftKeyBar.
 */
interface SoftKeyBarProps {
    /** An instance of the softkey menu system. */
    menuSystem: SoftKeyMenuSystem;
    /**
     * The amount of time, in milliseconds, to display the softkey pressed animation after a softkey has been pressed.
     * Defaults to {@link SoftKey.DEFAULT_PRESSED_DURATION}.
     */
    pressedDuration?: number;
}
/**
 * A Garmin softkey bar display. Each softkey bar has 12 softkey tabs. The behavior and display of each softkey tab is
 * defined by the current softkey menu of the display's softkey menu system.
 */
declare class SoftKeyBar extends DisplayComponent<SoftKeyBarProps> {
    private readonly softkeyRefs;
    private readonly menuItems;
    private menuSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Renders the component.
     * @returns The rendered component.
     */
    render(): VNode;
    /**
     * Builds the softkeys tab elements.
     * @returns A collection of soft key div elements.
     */
    private buildSoftKeys;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A controller which binds a softkey to a boolean state. Once bound, the softkey will display the bound state and
 * each press of the softkey will toggle the value of the state.
 */
declare class SoftKeyBooleanController {
    private readonly softkeyMenu;
    private readonly softkeyIndex;
    private readonly softkeyLabel;
    private readonly state;
    private item?;
    private statePipe?;
    private isAlive;
    private isInit;
    /**
     * Constructor.
     * @param softkeyMenu The softkey menu to which this controller's softkey belongs.
     * @param softkeyIndex The index in the softkey menu at which this controller's softkey is located.
     * @param softkeyLabel The text label of this controller's softkey.
     * @param state The state bound to this controller's softkey.
     */
    constructor(softkeyMenu: SoftKeyMenu, softkeyIndex: number, softkeyLabel: string, state: MutableSubscribable<boolean>);
    /**
     * Initializes this controller. This will create a softkey menu item and bind it to this controller's state.
     * @returns The softkey menu item bound to this controller's state.
     * @throws Error if this controller has been destroyed.
     */
    init(): SoftKeyMenuItem;
    /**
     * Destroys this controller. This will remove the softkey menu item bound to this controller's state.
     */
    destroy(): void;
}
/**
 * A controller which binds a softkey to a state which can take one of several enumerated values. Once bound, the
 * softkey will display the bound state and each press of the softkey will cycle the state through possible values.
 */
declare class SoftKeyEnumController<T> {
    private readonly softkeyMenu;
    private readonly softkeyIndex;
    private readonly softkeyLabel;
    private readonly state;
    private readonly textMap;
    private readonly nextFunc;
    private item?;
    private statePipe?;
    private isAlive;
    private isInit;
    /**
     * Constructor.
     * @param softkeyMenu The softkey menu to which this controller's softkey belongs.
     * @param softkeyIndex The index in the softkey menu at which this controller's softkey is located.
     * @param softkeyLabel The text label of this controller's softkey.
     * @param state The state bound to this controller's softkey.
     * @param textMap A function which maps values to their text representations.
     * @param nextFunc A function which gets the next value given the current value.
     */
    constructor(softkeyMenu: SoftKeyMenu, softkeyIndex: number, softkeyLabel: string, state: MutableSubscribable<T>, textMap: (value: T) => string, nextFunc: (currentValue: T) => T);
    /**
     * Initializes this controller. This will create a softkey menu item and bind it to this controller's state.
     * @returns The softkey menu item bound to this controller's state.
     * @throws Error if this controller has been destroyed.
     */
    init(): SoftKeyMenuItem;
    /**
     * Destroys this controller. This will remove the softkey menu item bound to this controller's state.
     */
    destroy(): void;
}
/**
 * A definition for a softkey bound to a state by MultipleSoftKeyEnumController.
 */
type MultipleSoftkeyEnumDef<V> = {
    /** The index of the softkey. */
    index: number;
    /** The label of the softkey. */
    label: string;
    /** The setting value bound to the softkey. */
    value: V;
};
/**
 * A controller which binds one or more softkeys to a state which can take one or more enumerated values. Each
 * softkey is bound to a specific value. Once bound, each softkey will display whether the state is equal to its bound
 * value, and each press of the softkey will set the state to its bound value.
 */
declare class MultipleSoftKeyEnumController<T> {
    private readonly softkeyMenu;
    private readonly state;
    private readonly softkeyDefs;
    private readonly menuItems;
    private readonly statePipes;
    private isAlive;
    private isInit;
    /**
     * Constructor.
     * @param softkeyMenu The softkey menu to which this controller's bound softkeys belong.
     * @param state The state bound to this controller's softkeys.
     * @param softkeyDefs The definitions for the softkeys bound to this controller's setting.
     */
    constructor(softkeyMenu: SoftKeyMenu, state: MutableSubscribable<T>, softkeyDefs: MultipleSoftkeyEnumDef<T>[]);
    /**
     * Initializes this controller. This will create softkey menu items and bind them to this controller's state.
     * @returns The softkey menu items bound to this controller's state. The order of the items is the same as the order
     * of the softkey definitions passed to this controller's constructor.
     * @throws Error if this controller has been destroyed.
     */
    init(): readonly SoftKeyMenuItem[];
    /**
     * Destroys this controller. This will remove the softkey menu items bound to this controller's state.
     */
    destroy(): void;
}

/**
 * Topics for bus events from which ADC data is sourced.
 */
type AdcDataSourceTopics = 'ias' | 'indicated_alt' | 'pressure_alt' | 'vertical_speed' | 'altimeter_baro_setting_inhg' | 'altimeter_baro_preselect_inhg' | 'altimeter_baro_preselect_mb' | 'altimeter_baro_preselect_raw' | 'altimeter_baro_is_std' | 'ambient_temp_c' | 'ambient_pressure_inhg' | 'isa_temp_c' | 'ram_air_temp_c';
/**
 * Data events published by the ADC system.
 */
type AdcDataEvents = {
    [P in keyof Pick<BaseAdcEvents, AdcDataSourceTopics> as `adc_${P}_${number}`]: BaseAdcEvents[P];
};
/**
 * Events fired by the ADC system.
 */
interface AdcSystemEvents extends AdcDataEvents {
    /** An event fired when the ADC system state changes. */
    [adc_state: `adc_state_${number}`]: AvionicsSystemStateEvent;
    /** An event fired when the ADC system state changes. */
    [adc_altitude_data_valid: `adc_altitude_data_valid_${number}`]: boolean;
    /** An event fired when the ADC system state changes. */
    [adc_airspeed_data_valid: `adc_airspeed_data_valid_${number}`]: boolean;
    /** An event fired when the ADC system state changes. */
    [adc_temperature_data_valid: `adc_temperature_data_valid_${number}`]: boolean;
    /** The airplane's measured true airspeed, in knots. */
    [adc_tas: `adc_tas_${number}`]: number;
    /** The airplane's measured mach number. */
    [adc_mach_number: `adc_mach_number_${number}`]: number;
    /** The conversion factor from measured mach number to knots indicated airspeed in the airplane's current environment. */
    [adc_mach_to_kias_factor: `adc_mach_to_kias_factor_${number}`]: number;
    /** The conversion factor from measured true airspeed to knots indicated airspeed in the airplane's current environment. */
    [adc_tas_to_ias_factor: `adc_tas_to_ias_factor_${number}`]: number;
}
/**
 * A Garmin ADC system.
 */
declare class AdcSystem extends BasicAvionicsSystem<AdcSystemEvents> {
    private readonly airspeedIndicatorIndex;
    private readonly altimeterIndex;
    protected initializationTime: number;
    private isAltitudeDataValid;
    private isAirspeedDataValid;
    private isTemperatureDataValid;
    private readonly altitudeDataSourceTopicMap;
    private readonly airspeedDataSourceTopicMap;
    private readonly temperatureDataSourceTopicMap;
    private readonly otherDataSourceTopicMap;
    private readonly dataSourceSubscriber;
    private readonly altitudeDataSubs;
    private readonly airspeedDataSubs;
    private readonly temperatureDataSubs;
    private readonly otherDataSubs;
    /**
     * Creates an instance of an ADC system.
     * @param index The index of the ADC.
     * @param bus An instance of the event bus.
     * @param airspeedIndicatorIndex The index of the sim airspeed indicator from which this ADC derives its data.
     * @param altimeterIndex The index of the sim altimeter from which this ADC derives its data.
     * @param powerSource The source from which to retrieve the system's power state. Can be an event bus topic defined
     * in {@link ElectricalEvents} with boolean-valued data, an XML logic element that evaluates to zero (false) or
     * non-zero (true) values, or a boolean-valued subscribable. If not defined, then the system will be considered
     * always powered on.
     */
    constructor(index: number, bus: EventBus, airspeedIndicatorIndex: number, altimeterIndex: number, powerSource?: SystemPowerKey | CompositeLogicXMLElement | Subscribable<boolean>);
    /**
     * Starts publishing ADC data on the event bus.
     */
    private startDataPublish;
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     * @param sourceTopic The topic that is the data source of the subscribed topic.
     * @param dataSubArray The array to which to add the data source subscription created for the subscribed topoic.
     * @param isDataValid Whether the data published to the subscribed topic is currently valid.
     */
    private onTopicSubscribed;
    /** @inheritDoc */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
}

/**
 * The state of an ADC used for selection.
 */
type AdcSystemSelectionState = readonly [
    isAltitudeDataValid: boolean,
    isAirspeedDataValid: boolean,
    isTemperatureDataValid: boolean
];
/**
 * Configuration options for {@link AdcSystemSelector}.
 */
type AdcSystemSelectorOptions = {
    /**
     * The priorities for selecting individual ADC systems. If two systems have the same desirability, then the one with
     * the higher priority will be selected. If a system's priority is not defined, then it will default to a value of
     * `0`. The priorities can be specified as an array of ADC system indexes or a map of ADC system indexes to the
     * priorities for selecting those systems. If specified as an array of indexes, then each system whose index appears
     * in the array will be assigned a priority equal to `array.length - array.indexOf(index)`.
     */
    systemPriorities?: readonly number[] | ReadonlyMap<number, number> | SubscribableMap<number, number>;
    /**
     * A function that compares the desirability of two ADC systems.
     * @param a The state of the first ADC system.
     * @param b The state of the second ADC system.
     * @returns A number representing the relative desirability of the two ADC systems: `-1` if system `a` is more
     * desirable than `b`, `1` if system `b` is more desirable than `a`, and `0` if both are equally desirable.
     */
    desirabilityComparator?: (a: AdcSystemSelectionState, b: AdcSystemSelectionState) => number;
};
/**
 * Automatically selects the best ADC from a set of candidates based on the current states of all systems. System state
 * desiribility depends on whether it is providing valid airspeed and altitude data.
 */
declare class AdcSystemSelector {
    private readonly bus;
    private readonly candidateSystemIndexes;
    private readonly systemPriorities;
    private readonly _selectedIndex;
    /** The index of the selected ADC, or `-1` if one could not be selected. */
    readonly selectedIndex: Subscribable<number>;
    private readonly _isSelectedAltitudeDataValid;
    /** Whether the selected ADC is providing valid altitude data. */
    readonly isSelectedAltitudeDataValid: Subscribable<boolean>;
    private readonly _isSelectedAirspeedDataValid;
    /** Whether the selected ADC is providing valid airspeed data. */
    readonly isSelectedAirspeedDataValid: Subscribable<boolean>;
    private readonly _isSelectedTemperatureDataValid;
    /** Whether the selected ADC is providing valid temperature data. */
    readonly isSelectedTemperatureDataValid: Subscribable<boolean>;
    private readonly adcEntries;
    private readonly adcOrder;
    private readonly adcPriorityComparator;
    private readonly desirabilityComparator;
    private needReselect;
    private isAlive;
    private isInit;
    private candidateSystemIndexesSub?;
    private systemPrioritiesSub?;
    private updateSub?;
    /**
     * Creates a new instance of AdcSystemSelector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the ADC systems from which to select.
     * @param options Options with which to configure the selector.
     */
    constructor(bus: EventBus, candidateSystemIndexes: Iterable<number> | SubscribableSet<number>, options?: Readonly<AdcSystemSelectorOptions>);
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best ADC among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init(): void;
    /**
     * Updates this selector.
     */
    private update;
    /**
     * Selects the index of the ADC with the most desirable state.
     */
    private selectIndex;
    /**
     * Destroys this selector.
     */
    destroy(): void;
    /**
     * A function that compares the desirability of two ADC systems using a set of default criteria. Systems are
     * assigned one point for each set of valid data they provide: altitude, airspeed, and temperature. A system is
     * deemed more desirable than another if and only if the former is assigned more points than the latter.
     * @param a The state of the first ADC system.
     * @param b The state of the second ADC system.
     * @returns A number representing the relative desirability of the two ADC systems: `-1` if system `a` is more
     * desirable than `b`, `1` if system `b` is more desirable than `a`, and `0` if both are equally desirable.
     */
    private static defaultDesirabilityComparator;
}

/**
 * Events fired by the AGL system.
 */
interface AglSystemEvents {
    /** An event fired when the AGL system state changes. */
    [agl_state: `agl_state_${number}`]: AvionicsSystemStateEvent;
    /** An event fired when the position data validity of an AGL system changes. */
    [agl_gps_data_valid: `agl_gps_data_valid_${number}`]: boolean;
    /** The above ground height, in feet, calculated from position data. */
    [agl_gps_height: `agl_gps_height_${number}`]: number;
    /** The rate of change of above ground height, in feet per minute, calculated from position data. */
    [agl_gps_height_rate: `agl_gps_height_rate_${number}`]: number;
    /** An event fired when the radar altitude data validity of an AGL system changes. */
    [agl_radaralt_data_valid: `agl_radaralt_data_valid_${number}`]: boolean;
    /** The above ground height, in feet, calculated from radar altitude data. */
    [agl_radaralt_height: `agl_radaralt_height_${number}`]: number;
    /**
     * Whether above ground height calculated from radar altitude data is clamped to the maximum reliable radar altitude.
     * If the height is clamped, then the rate of change of the height is fixed to zero and is not valid.
     */
    [agl_radaralt_height_maxed: `agl_radaralt_height_maxed_${number}`]: boolean;
    /** The rate of change of above ground height, in feet per minute, calculated from radar altitude data. */
    [agl_radaralt_height_rate: `agl_radaralt_height_rate_${number}`]: number;
}
/**
 * Parameters for exponential smoothers used by {@link AglSystem}.
 */
type AglSystemSmootherParams = {
    /**
     * The smoothing time constant, in milliseconds. The larger the constant, the greater the smoothing effect. A value
     * less than or equal to 0 is equivalent to no smoothing.
     */
    tau?: number;
    /**
     * The time constant, in milliseconds, for smoothing the estimated velocity of the input value. The larger the
     * constant, the greater the smoothing effect applied to the estimated velocity. A value less than or equal to 0 is
     * equivalent to no smoothing. If not defined, then estimated velocity will not be used to calculate the final
     * smoothed value.
     */
    tauVelocity?: number;
    /**
     * The time constant, in milliseconds, for smoothing the estimated acceleration of the input value. The larger the
     * constant, the greater the smoothing effect applied to the estimated acceleration. A value less than or equal to 0
     * is equivalent to no smoothing. If this value or `tauVelocity` is not defined, then estimated acceleration will not
     * be used to calculate the final smoothed value.
     */
    tauAccel?: number;
    /**
     * The elapsed time threshold, in milliseconds, above which smoothing will not be applied to a new input value.
     * Defaults to 10000.
     */
    dtThreshold?: number;
};
/**
 * Configuration options for {@link AglSystem}.
 */
type AglSystemOptions = {
    /**
     * The index of the FMS position system from which to source data. Specifying an invalid index (less than or equal to
     * zero) will prevent the system from sourcing position data. Defaults to `-1`.
     */
    fmsPosIndex?: number | Subscribable<number>;
    /**
     * The FMS position system data modes that provide valid position data for calculating AGL data. Defaults to
     * `[FmsPositionMode.Gps, FmsPositionMode.Hns, FmsPositionMode.Dme]`.
     */
    validFmsPosModes?: Iterable<Exclude<FmsPositionMode, FmsPositionMode.None>>;
    /**
     * Parameters for smoothing applied to GPS above ground height. `tau` defaults to `1000 / Math.LN2`, `tauVelocity`
     * defaults to undefined, and `tauAccel` defaults to `undefined.
     */
    gpsAglSmootherParams?: Readonly<AglSystemSmootherParams>;
    /**
     * The index of the radar altimeter system from which to source data. Specifying an invalid index (less than or equal
     * to zero) will prevent the system from sourcing radar altitude data. Defaults to `-1`.
     */
    radarAltIndex?: number | Subscribable<number>;
    /**
     * The maximum reliable radar altitude, in feet. Radar altitude values above the maximum will be clamped to the
     * maximum and cannot be used to calculate height rate. Defaults to `Infinity`.
     */
    maxRadarAlt?: number | Accessible<number>;
    /**
     * Parameters for smoothing applied to radar altitude. `tau` defaults to `1000 / Math.LN2`, `tauVelocity` defaults to
     * undefined, and `tauAccel` defaults to `undefined.
     */
    radarAltSmootherParams?: Readonly<AglSystemSmootherParams>;
};
/**
 * A Garmin system that calculates data related to the airplane's above ground height/level. The system supports
 * sourcing FMS position data (plus terrain database) or radar altitude data.
 *
 * Requires the event bus topics defined in {@link ClockEvents} to be published. In order to source FMS position data,
 * requires the event bus topics defined in {@link GNSSEvents} and {@link FmsPositionSystemEvents} to be published. In
 * order to source radar altitude data, requires the event bus topics defined in {@link RadarAltimeterSystemEvents} to
 * be published.
 */
declare class AglSystem extends BasicAvionicsSystem<AglSystemEvents> {
    protected initializationTime: number;
    private readonly dataSourceSubscriber;
    private readonly fmsPosIndex;
    private readonly radarAltIndex;
    private readonly simRate;
    private readonly validFmsPosModes;
    private readonly fmsPosMode;
    private readonly gpsPos;
    private readonly gpsGroundAltitude;
    private radarAltStateSub?;
    private readonly maxRadarAlt;
    private readonly radarAlt;
    private readonly gpsAglSmoother;
    private readonly radarAltSmoother;
    private readonly gpsTopics;
    private readonly radarAltTopics;
    private isGpsDataSubbed;
    private publishedGpsDataValid;
    private lastGpsHeight;
    private isRadarAltDataSubbed;
    private publishedRadarAltDataValid;
    private lastRadarAltHeight;
    private lastUpdateTime;
    /**
     * Creates an instance of an angle of attack computer system.
     * @param index The index of the AoA computer.
     * @param bus An instance of the event bus.
     * @param powerSource The source from which to retrieve the system's power state. Can be an event bus topic defined
     * in {@link ElectricalEvents} with boolean-valued data, an XML logic element that evaluates to zero (false) or
     * non-zero (true) values, or a boolean-valued subscribable. If not defined, then the system will be considered
     * always powered on.
     * @param options Options with which to configure the system.
     */
    constructor(index: number, bus: EventBus, powerSource?: SystemPowerKey | CompositeLogicXMLElement | Subscribable<boolean>, options?: Readonly<AglSystemOptions>);
    /**
     * Starts publishing angle of attack data on the event bus.
     */
    private startDataPublish;
    /**
     * Responds to when someone first subscribes to one of this system's position data topics on the event bus.
     */
    private onGpsTopicSubscribed;
    /**
     * Responds to when someone first subscribes to one of this system's radar altitude data topics on the event bus.
     */
    private onRadarAltTopicSubscribed;
    /** @inheritDoc */
    onUpdate(): void;
    /**
     * Updates data sourced from position data.
     * @param dt The elapsed time since the previous update, in milliseconds.
     */
    private updateGpsData;
    /**
     * Resets data sourced from position data and marks them as invalid.
     */
    private resetGpsData;
    /**
     * Updates data sourced from radar altitude data.
     * @param dt The elapsed time since the previous update, in milliseconds.
     */
    private updateRadarAltData;
    /**
     * Resets data sourced from radar altitude data and marks them as invalid.
     */
    private resetRadarAltData;
}

/**
 * Data events published by the AHRS system.
 */
type AhrsDataEvents = {
    [P in keyof BaseAhrsEvents as `ahrs_${P}_${number}`]: BaseAhrsEvents[P];
};
/**
 * Events published by AHRS systems.
 */
interface AhrsSystemEvents extends AhrsDataEvents {
    /** An event fired when an AHRS system state changes. */
    [ahrs_state: `ahrs_state_${number}`]: AvionicsSystemStateEvent;
    /** An event fired when the heading data state of an AHRS system changes. */
    [ahrs_heading_data_valid: `ahrs_heading_data_valid_${number}`]: boolean;
    /** An event fired when the attitude data state of an AHRS system changes. */
    [ahrs_attitude_data_valid: `ahrs_attitude_data_valid_${number}`]: boolean;
}
/**
 * A Garmin AHRS system.
 */
declare class AhrsSystem extends BasicAvionicsSystem<AhrsSystemEvents> {
    private readonly attitudeIndicatorIndex;
    private readonly directionIndicatorIndex;
    protected initializationTime: number;
    private magnetometerState;
    private adcState;
    private isHeadingDataValid;
    private isAttitudeDataValid;
    private readonly rollSub;
    private readonly headingDataSourceTopicMap;
    private readonly attitudeDataSourceTopicMap;
    private readonly dataSourceSubscriber;
    private readonly headingDataSubs;
    private readonly attitudeDataSubs;
    /**
     * Creates an instance of an AHRS system.
     * @param index The index of the AHRS.
     * @param bus An instance of the event bus.
     * @param attitudeIndicatorIndex The index of the sim attitude indicator from which this AHRS derives its data.
     * @param directionIndicatorIndex The index of the sim direction indicator from which this AHRS derives its data.
     * @param powerSource The source from which to retrieve the system's power state. Can be an event bus topic defined
     * in {@link ElectricalEvents} with boolean-valued data, an XML logic element that evaluates to zero (false) or
     * non-zero (true) values, or a boolean-valued subscribable. If not defined, then the system will be considered
     * always powered on.
     */
    constructor(index: number, bus: EventBus, attitudeIndicatorIndex: number, directionIndicatorIndex: number, powerSource?: SystemPowerKey | CompositeLogicXMLElement | Subscribable<boolean>);
    /** @inheritdoc */
    protected onPowerChanged(isPowered: boolean): void;
    /**
     * Starts publishing AHRS data on the event bus.
     */
    private startDataPublish;
    /**
     * Responds to when someone first subscribes to one of this system's heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    private onHeadingTopicSubscribed;
    /**
     * Responds to when someone first subscribes to one of this system's attitude data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    private onAttitudeTopicSubscribed;
    /** @inheritdoc */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
    /**
     * Updates the validity state of this system's heading data. If heading data is valid, this system will start
     * publishing heading data. If heading data is invalid, this system will stop publishing heading data.
     */
    private updateHeadingDataState;
    /**
     * Updates the validity state of this system's attitude data. If attitude data is valid, this system will start
     * publishing attitude data. If attitude data is invalid, this system will stop publishing attitude data.
     */
    private updateAttitudeDataState;
    /**
     * Handles when the bank angle changes while AHRS is initializing.
     * @param bankAngle The bank angle of the aircraft.
     */
    private onRollChanged;
}

/**
 * The state of an AHRS used for selection.
 */
type AhrsSystemSelectionState = readonly [
    isAttitudeDataValid: boolean,
    isHeadingDataValid: boolean
];
/**
 * Configuration options for {@link AhrsSystemSelector}.
 */
type AhrsSystemSelectorOptions = {
    /**
     * The priorities for selecting individual AHRS systems. If two systems have the same desirability, then the one with
     * the higher priority will be selected. If a system's priority is not defined, then it will default to a value of
     * `0`. The priorities can be specified as an array of AHRS system indexes or a map of AHRS system indexes to the
     * priorities for selecting those systems. If specified as an array of indexes, then each system whose index appears
     * in the array will be assigned a priority equal to `array.length - array.indexOf(index)`.
     */
    systemPriorities?: readonly number[] | ReadonlyMap<number, number> | SubscribableMap<number, number>;
    /**
     * A function that compares the desirability of two AHRS systems.
     * @param a The state of the first AHRS system.
     * @param b The state of the second AHRS system.
     * @returns A number representing the relative desirability of the two AHRS systems: `-1` if system `a` is more
     * desirable than `b`, `1` if system `b` is more desirable than `a`, and `0` if both are equally desirable.
     */
    desirabilityComparator?: (a: AhrsSystemSelectionState, b: AhrsSystemSelectionState) => number;
};
/**
 * Automatically selects the best AHRS from a set of candidates based on the current states of all systems. System state
 * desiribility depends on whether it is providing valid airspeed and altitude data.
 */
declare class AhrsSystemSelector {
    private readonly bus;
    private readonly candidateSystemIndexes;
    private readonly systemPriorities;
    private readonly _selectedIndex;
    /** The index of the selected AHRS, or `-1` if one could not be selected. */
    readonly selectedIndex: Subscribable<number>;
    private readonly _isSelectedAttitudeDataValid;
    /** Whether the selected AHRS is providing valid attitude data. */
    readonly isSelectedAttitudeDataValid: Subscribable<boolean>;
    private readonly _isSelectedHeadingDataValid;
    /** Whether the selected AHRS is providing valid heading data. */
    readonly isSelectedHeadingDataValid: Subscribable<boolean>;
    private readonly adcEntries;
    private readonly ahrsOrder;
    private readonly ahrsPriorityComparator;
    private readonly desirabilityComparator;
    private needReselect;
    private isAlive;
    private isInit;
    private candidateSystemIndexesSub?;
    private systemPrioritiesSub?;
    private updateSub?;
    /**
     * Creates a new instance of AhrsSystemSelector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the AHRS systems from which to select.
     * @param options Options with which to configure the selector.
     */
    constructor(bus: EventBus, candidateSystemIndexes: Iterable<number> | SubscribableSet<number>, options?: Readonly<AhrsSystemSelectorOptions>);
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best AHRS among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init(): void;
    /**
     * Updates this selector.
     */
    private update;
    /**
     * Selects the index of the ADC with the most desirable state.
     */
    private selectIndex;
    /**
     * Destroys this selector.
     */
    destroy(): void;
    /**
     * A function that compares the desirability of two AHRS systems using a set of default criteria. Systems are
     * assigned one point for each set of valid data they provide: attitude and heading. A system is deemed more
     * desirable than another if and only if the former is assigned more points than the latter.
     * @param a The state of the first AHRS system.
     * @param b The state of the second AHRS system.
     * @returns A number representing the relative desirability of the two ADC systems: `-1` if system `a` is more
     * desirable than `b`, `1` if system `b` is more desirable than `a`, and `0` if both are equally desirable.
     */
    private static defaultDesirabilityComparator;
}

/**
 * Topics for bus events from which AoA data is sourced.
 */
type AoaDataSourceTopics = 'aoa' | 'stall_aoa' | 'zero_lift_aoa';
/**
 * Data events published by the AoA system.
 */
type AoaDataEvents = {
    [P in keyof Pick<BaseAdcEvents, AoaDataSourceTopics> as `aoa_${P}_${number}`]: BaseAdcEvents[P];
} & {
    /** Normalized angle of attack. A value of `0` is equal to zero-lift AoA, and a value of `1` is equal to stall AoA. */
    [aoa_norm_aoa: `aoa_norm_aoa_${number}`]: number;
};
/**
 * Events fired by the AoA system.
 */
interface AoaSystemEvents extends AoaDataEvents {
    /** An event fired when the AoA system state changes. */
    [aoa_state: `aoa_state_${number}`]: AvionicsSystemStateEvent;
    /** An event fired when the data state of an AoA system changes. */
    [aoa_data_valid: `aoa_data_valid_${number}`]: boolean;
}
/**
 * Configuration options for {@link AoaSystem}.
 */
type AoaSystemOptions = {
    /**
     * The airplane's critical (stall) angle of attack, in degrees. If not defined, then the system will use the value
     * reported by the sim.
     */
    stallAoa?: number | Subscribable<number>;
    /**
     * The airplane's zero-lift angle of attack, in degrees. If not defined, then the system will use the value reported
     * by the sim.
     */
    zeroLiftAoa?: number | Subscribable<number>;
};
/**
 * A Garmin angle of attack computer system.
 */
declare class AoaSystem extends BasicAvionicsSystem<AoaSystemEvents> {
    protected initializationTime: number;
    private readonly dataSourceSubscriber;
    private readonly dataSubs;
    private readonly customStallAoa?;
    private readonly customZeroLiftAoa?;
    private aoa?;
    private stallAoa?;
    private zeroLiftAoa?;
    private isAoaSubbed;
    private isStallAoaSubbed;
    private isZeroLiftAoaSubbed;
    private isDataValid;
    private readonly aoaDataValidTopic;
    private readonly normAoaTopic;
    /**
     * Creates an instance of an angle of attack computer system.
     * @param index The index of the AoA computer.
     * @param bus An instance of the event bus.
     * @param powerSource The source from which to retrieve the system's power state. Can be an event bus topic defined
     * in {@link ElectricalEvents} with boolean-valued data, an XML logic element that evaluates to zero (false) or
     * non-zero (true) values, or a boolean-valued subscribable. If not defined, then the system will be considered
     * always powered on.
     * @param options Options with which to configure the system.
     */
    constructor(index: number, bus: EventBus, powerSource?: SystemPowerKey | CompositeLogicXMLElement | Subscribable<boolean>, options?: Readonly<AoaSystemOptions>);
    /**
     * Starts publishing angle of attack data on the event bus.
     */
    private startDataPublish;
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    private onTopicSubscribed;
    /** @inheritDoc */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
    /** @inheritDoc */
    onUpdate(): void;
}

/**
 * Topics for bus events from which GPS receiver data is sourced.
 */
type GpsReceiverDataSourceTopics = `gps_system_nominal_channel_count_${number}` | `gps_system_state_changed_${number}` | `gps_system_sbas_state_changed_${number}` | `gps_sat_pos_calculated_${number}` | `gps_sat_state_changed_${number}` | `gps_system_pdop_${number}` | `gps_system_hdop_${number}` | `gps_system_vdop_${number}`;
/**
 * Data events published by the GPS receiver system sourced from GPSSatComputer.
 */
type GpsReceiverGPSSatComputerDataEvents = {
    [P in Extract<GpsReceiverDataSourceTopics, keyof GPSSatComputerEvents> as `gps_rec_${P}`]: GPSSatComputerEvents[P];
};
/**
 * Events fired by the GPS receiver system.
 */
interface GpsReceiverSystemEvents extends GpsReceiverGPSSatComputerDataEvents {
    /** An event fired when the GPS receiver system state changes. */
    [gps_rec_state: `gps_rec_state_${number}`]: AvionicsSystemStateEvent;
}
/**
 * Options for {@link GpsReceiverSystem}.
 */
type GpsReceiverSystemOptions = {
    /**
     * Whether the system should execute a warm start instead of a cold start on initial power-up. During a warm start,
     * the system uses almanac data to predict satellite geometry in order to choose a set of satellites to acquire
     * that will minimize time to first fix. Defaults to `false`.
     */
    warmStartOnInit?: boolean;
};
/**
 * A Garmin GPS receiver system.
 */
declare class GpsReceiverSystem extends BasicAvionicsSystem<GpsReceiverSystemEvents> {
    private readonly gpsSatComputer;
    protected initializationTime: number;
    private readonly cachedDataSourceTopicMap;
    private readonly uncachedDataSourceTopicMap;
    private readonly dopDataSourceTopicMap;
    private readonly dataSourceSubscriber;
    private readonly dataSubs;
    private readonly dopSources;
    private readonly sbasState;
    private readonly warmStartOnInit;
    /**
     * Creates an instance of a GPS receiver system.
     * @param index The index of the GPS receiver.
     * @param bus An instance of the event bus.
     * @param gpsSatComputer This system's GPS computer system.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     * @param options Options with which to configure the system.
     */
    constructor(index: number, bus: EventBus, gpsSatComputer: GPSSatComputer, powerSource?: SystemPowerKey | CompositeLogicXMLElement, options?: Readonly<GpsReceiverSystemOptions>);
    /**
     * Starts publishing data on the event bus.
     */
    private startDataPublish;
    /** @inheritdoc */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * Events fired by the magnetometer system.
 */
interface MagnetometerSystemEvents {
    /** An event fired when the AHRS system state changes. */
    [magnetometer_state: `magnetometer_state_${number}`]: AvionicsSystemStateEvent;
}
/**
 * The GMU44 magnetometer system.
 */
declare class MagnetometerSystem extends BasicAvionicsSystem<MagnetometerSystemEvents> {
    readonly index: number;
    protected readonly bus: EventBus;
    protected initializationTime: number;
    /**
     * Creates an instance of the MagnetometerSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index: number, bus: EventBus, powerSource?: SystemPowerKey | CompositeLogicXMLElement);
}

/**
 * Events fired by the marker beacon system.
 */
interface MarkerBeaconSystemEvents {
    /** An event fired when the marker beacon system state changes. */
    [marker_state: `marker_state_${number}`]: AvionicsSystemStateEvent;
    /** The marker beacon receiving state. */
    [marker_mkr_bcn_state: `marker_mkr_bcn_state_${number}`]: MarkerBeaconState;
}
/**
 * A Garmin marker beacon receiver system.
 */
declare class MarkerBeaconSystem extends BasicAvionicsSystem<MarkerBeaconSystemEvents> {
    private beaconStateSub?;
    /**
     * Creates an instance of a marker beacon system.
     * @param index The index of the marker beacon system.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index: number, bus: EventBus, powerSource?: SystemPowerKey | CompositeLogicXMLElement);
    /**
     * Responds to when someone first subscribes to this system's marker beacon state data topic on the event bus.
     */
    private onMarkerBeaconStateTopicSubscribed;
    /** @inheritdoc */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
}

/**
 * Events fired by the radar altimeter system.
 */
interface RadarAltimeterSystemEvents {
    /** An event fired when the radar altimeter system state changes. */
    [radaralt_state: `radaralt_state_${number}`]: AvionicsSystemStateEvent;
    /** The radar altitude, in feet. */
    [radaralt_radio_alt: `radaralt_radio_alt_${number}`]: number;
}
/**
 * A Garmin radar altimeter system.
 */
declare class RadarAltimeterSystem extends BasicAvionicsSystem<RadarAltimeterSystemEvents> {
    private radioAltSub?;
    /**
     * Creates an instance of a radar altimeter system.
     * @param index The index of the radar altimeter.
     * @param bus An instance of the event bus.
     * @param powerSource The source from which to retrieve the system's power state. Can be an event bus topic defined
     * in {@link ElectricalEvents} with boolean-valued data, an XML logic element that evaluates to zero (false) or
     * non-zero (true) values, or a boolean-valued subscribable. If not defined, then the system will be considered
     * always powered on.
     */
    constructor(index: number, bus: EventBus, powerSource?: SystemPowerKey | CompositeLogicXMLElement | Subscribable<boolean>);
    /**
     * Responds to when someone first subscribes to this system's radar altitude data topic on the event bus.
     */
    private onRadioAltTopicSubscribed;
    /** @inheritDoc */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
}

/**
 * Events fired by the traffic avionics system.
 */
interface TrafficAvionicsSystemEvents {
    /** An event fired when the traffic avionics system state changes. */
    traffic_avionics_state: AvionicsSystemStateEvent;
}
/**
 * A Garmin traffic avionics system.
 */
declare class TrafficAvionicsSystem<T extends TrafficSystem = TrafficSystem> extends BasicAvionicsSystem<TrafficAvionicsSystemEvents> {
    readonly trafficSystem: T;
    /**
     * Creates an instance of a traffic avionics system.
     * @param bus An instance of the event bus.
     * @param trafficSystem This system's traffic system.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     * @param initializationTime The time required for the system to initialize, in milliseconds. Defaults to 0.
     */
    constructor(bus: EventBus, trafficSystem: T, powerSource?: SystemPowerKey | CompositeLogicXMLElement, initializationTime?: number);
    /** @inheritdoc */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
}

/**
 * Events fired by the weather radar avionics system.
 */
interface WeatherRadarAvionicsSystemEvents {
    /** An event fired when the weather radar system state changes. */
    wx_radar_state: AvionicsSystemStateEvent;
}
/**
 * A Garmin weather radar avionics system.
 */
declare class WeatherRadarAvionicsSystem extends BasicAvionicsSystem<WeatherRadarAvionicsSystemEvents> {
    protected readonly isRadarScanActive?: Subscribable<boolean> | undefined;
    protected isActivePowered: boolean | undefined;
    protected electricalActivePowerSub?: Subscription;
    protected electricalActivePowerLogic?: CompositeLogicXMLElement;
    /**
     * Creates an instance of a weather radar avionics system.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link AvionicsSystemPowerEvents} topic or electricity logic element to which to connect
     * the system's power.
     * @param activePowerSource The {@link AvionicsSystemPowerEvents} topic or electricity logic element to which to
     * connect the system's power when radar is actively scanning. If defined, then the system will enter the failed
     * state if the radar is actively scanning and the active radar power source is unpowered.
     * @param isRadarScanActive Whether the weather radar is actively scanning. Ignored if {@linkcode activePowerSource}
     * is not defined.
     * @param initializationTime The time required for the system to initialize, in milliseconds. Defaults to 0.
     */
    constructor(bus: EventBus, powerSource?: SystemPowerKey | CompositeLogicXMLElement, activePowerSource?: SystemPowerKey | CompositeLogicXMLElement, isRadarScanActive?: Subscribable<boolean> | undefined, initializationTime?: number);
    /** @inheritdoc */
    protected onPowerValid(): void;
    /**
     * Connects this system's active radar power state to an {@link AvionicsSystemPowerEvents} topic or electricity logic
     * element.
     * @param source The source to which to connect this system's active radar power state.
     */
    protected connectToActivePower(source: SystemPowerKey | CompositeLogicXMLElement): void;
    /** @inheritdoc */
    protected onPowerChanged(isPowered: boolean): void;
    /**
     * A callback called when the connected active radar power state of the avionics system changes.
     * @param isPowered Whether or not the system is powered.
     */
    protected onActivePowerChanged(isPowered: boolean): void;
    /**
     * Responds to when whether the radar is actively scanning changes.
     */
    protected onRadarScanActiveChanged(): void;
    /**
     * Updates this system's state from its active radar power state and whether the radar is actively scanning.
     */
    protected updateStateFromActivePower(): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Updates this system's active radar power state from an electricity logic element.
     */
    protected updateActivePowerFromLogic(): void;
}

/**
 * A module for a Garmin terrain alerting system. Modules are attached to a parent system, which update the modules and
 * provide them with data.
 */
interface TerrainSystemModule {
    /**
     * A method that is called when this module is attached to an initialized system, or when this module's parent
     * system is initialized.
     */
    onInit(): void;
    /**
     * A method that is called every time this module's parent system is updated.
     * @param operatingMode The parent system's current operating mode.
     * @param inhibits The parent system's currently active inhibits.
     * @param data The data provided by the parent system.
     * @param realTime The current real (operating system) time, as a Javascript timestamp.
     * @param simRate The current simulation rate factor.
     * @param simTime The current sim time, as a Javascript timestamp.
     * @param alertController A controller for alerts issued by the parent system.
     */
    onUpdate(operatingMode: TerrainSystemOperatingMode, statuses: ReadonlySet<string>, inhibits: ReadonlySet<string>, data: Readonly<TerrainSystemData>, alertController: TerrainSystemAlertController): void;
    /**
     * A method that is called when this module's parent system is destroyed.
     */
    onDestroy(): void;
}

/**
 * Parameters for exponential smoothers used by {@link GarminExcessiveClosureRateModule}.
 */
type GarminExcessiveClosureRateModuleSmootherParams = {
    /**
     * The smoothing time constant, in milliseconds. The larger the constant, the greater the smoothing effect. A value
     * less than or equal to 0 is equivalent to no smoothing. Defaults to `1000 / Math.LN2`.
     */
    tau?: number;
    /**
     * The time constant, in milliseconds, for smoothing the estimated velocity of the input value. The larger the
     * constant, the greater the smoothing effect applied to the estimated velocity. A value less than or equal to 0 is
     * equivalent to no smoothing. If not defined, then estimated velocity will not be used to calculate the final
     * smoothed value.
     */
    tauVelocity?: number;
    /**
     * The time constant, in milliseconds, for smoothing the estimated acceleration of the input value. The larger the
     * constant, the greater the smoothing effect applied to the estimated acceleration. A value less than or equal to 0
     * is equivalent to no smoothing. If this value or `tauVelocity` is not defined, then estimated acceleration will not
     * be used to calculate the final smoothed value.
     */
    tauAccel?: number;
    /**
     * The elapsed time threshold, in milliseconds, above which smoothing will not be applied to a new input value.
     * Defaults to 10000.
     */
    dtThreshold?: number;
};
/**
 * Configuration options for {@link GarminExcessiveClosureRateModule}.
 */
type GarminExcessiveClosureRateModuleOptions = {
    /**
     * Whether alerting should function as a GPWS alert. If `true`, then radar altimeter data (up to 2500 feet AGL) will
     * be used to measure height above terrain, and alerting will be inhibited when the `GarminTawsStatus.GpwsFailed`
     * status is active. If `false`, then GPS altitude in conjunction with terrain database ground elevation will be used
     * to measure height above terrain, and alerting will be inhibited when the `GarminTawsStatus.TawsFailed` or
     * `GarminTawsStatus.TawsNotAvailable` statuses are active. Defaults to `false`.
     */
    functionAsGpws?: boolean;
    /**
     * Whether to force the module to always consider FLTA as not available. If `false`, then FLTA will be considered not
     * available if and only if either the `GarminTawsStatus.TawsFailed` or `GarminTawsStatus.TawsNotAvailable` status
     * flag is active. Defaults to `false`.
     */
    forceNoFlta?: boolean;
    /**
     * The flaps extension angle range, as `[min, max]` in degrees, that defines the landing flaps configuration. If not
     * defined, then flaps will never be considered to be in the landing configuration.
     */
    flapsLandingAngle?: readonly [number, number];
    /** Parameters for smoothing applied to terrain closure rate. */
    closureRateSmootherParams?: Readonly<GarminExcessiveClosureRateModuleSmootherParams>;
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must be met
     * before the alert is triggered. Defaults to `2000`.
     */
    triggerDebounce?: number;
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must not be
     * met before the alert is untriggered. Defaults to `2000`.
     */
    untriggerDebounce?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes triggered before it can be untriggered. Defaults to
     * `5000`.
     */
    triggerHysteresis?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes untriggered before it can be triggered. Defaults to
     * `0`.
     */
    untriggerHysteresis?: number;
    /** The inhibit flags that should inhibit alerting. If not defined, then no flags will inhibit alerting. */
    inhibitFlags?: Iterable<string>;
};
/**
 * A Garmin terrain alerting system module that handles excessive closure rate (ECR) alerts.
 */
declare class GarminExcessiveClosureRateModule implements TerrainSystemModule {
    private readonly functionAsGpws;
    private readonly forceNoFlta;
    private readonly flapsLandingAngle;
    private readonly triggerDebounce;
    private readonly untriggerDebounce;
    private readonly triggerHysteresis;
    private readonly untriggerHysteresis;
    private readonly inhibitFlags;
    private isReset;
    private isInhibited;
    private triggeredAlert;
    private warningTriggerDebounceTimer;
    private cautionTriggerDebounceTimer;
    private warningUntriggerDebounceTimer;
    private cautionUntriggerDebounceTimer;
    private triggerHysteresisTimer;
    private untriggerHysteresisTimer;
    private readonly closureRateSmoother;
    private lastAgl;
    private lastUpdateTime;
    /**
     * Creates a new instance of GarminExcessiveClosureRateModule.
     * @param options Options with which to configure the module.
     */
    constructor(options?: Readonly<GarminExcessiveClosureRateModuleOptions>);
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: TerrainSystemOperatingMode, statuses: ReadonlySet<string>, inhibits: ReadonlySet<string>, data: Readonly<TerrainSystemData>, alertController: TerrainSystemAlertController): void;
    /**
     * Updates whether this module's alerts are inhibited.
     * @param inhibits The parent system's currently active inhibits.
     * @param alertController A controller for alerts issued by the parent system.
     */
    private updateInhibits;
    /**
     * Updates whether to issue an excessive closure rate alert.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param data Terrain system data.
     * @param noFlta Whether FLTA is not available.
     * @param agl The airplane's current height above ground level, in feet.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private updateAlerts;
    /**
     * Resolves a desired triggered alert to an alert to trigger.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param desiredTriggeredAlert The desired triggered alert, or `null` if all alerts are desired to be untriggered.
     * @returns The alert to trigger, or `null` if no alert should be triggered.
     */
    private resolveTriggeredAlert;
    /**
     * Resolves a desired triggered alert that is of higher severity than this module's existing triggered alert.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param desiredTriggeredAlert The desired triggered alert.
     * @returns The alert to trigger, or `null` if no alert should be triggered.
     */
    private resolveTriggeredAlertUpgrade;
    /**
     * Resolves a desired triggered alert that is of lower severity than this module's existing triggered alert.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param desiredTriggeredAlert The desired triggered alert, or `null` if all alerts are desired to be untriggered.
     * @returns The alert to trigger, or `null` if no alert should be triggered.
     */
    private resolveTriggeredAlertDowngrade;
    /**
     * Deactivates all excessive closure rate alerts.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private reset;
    /** @inheritDoc */
    onDestroy(): void;
    private static readonly WARNING_NO_FLTA_BREAKPOINTS;
    private static readonly CAUTION_NO_FLTA_BREAKPOINTS;
    private static readonly WARNING_GEAR_UP_BREAKPOINTS;
    private static readonly CAUTION_GEAR_UP_BREAKPOINTS;
    private static readonly WARNING_GEAR_DOWN_BREAKPOINTS;
    private static readonly CAUTION_GEAR_DOWN_BREAKPOINTS;
    private static readonly WARNING_FLAPS_LANDING_BREAKPOINTS;
    private static readonly CAUTION_FLAPS_LANDING_BREAKPOINTS;
    private static readonly WARNING_FLAPS_LANDING_NO_FLTA_BREAKPOINTS;
    private static readonly CAUTION_FLAPS_LANDING_NO_FLTA_BREAKPOINTS;
    /**
     * Checks whether a closure rate meets the threshold for an excessive closure rate warning alert for a given height
     * above ground level.
     * @param agl The height above ground level, in feet.
     * @param closureRate The closure rate, in feet per minute.
     * @param noFlta Whether FLTA is not available.
     * @param isFlapsLanding Whether flaps are in the landing configuration.
     * @param isGearDown Whether landing gear are extended.
     * @returns Whether the specified closure rate meets the threshold for an excessive closure rate warning alert.
     */
    private static isWarning;
    /**
     * Checks whether a closure rate meets the threshold for an excessive closure rate caution alert for a given height
     * above ground level.
     * @param agl The height above ground level, in feet.
     * @param closureRate The closure rate, in feet per minute.
     * @param noFlta Whether FLTA is not available.
     * @param isFlapsLanding Whether flaps are in the landing configuration.
     * @param isGearDown Whether landing gear are extended.
     * @returns Whether the specified closure rate meets the threshold for an excessive closure rate caution alert.
     */
    private static isCaution;
    /**
     * Checks whether a closure rate meets the threshold for an excessive closure rate alert for a given height above
     * ground level.
     * @param breakpoints The closure rate threshold vs. height above ground level breakpoints to use.
     * @param agl The height above ground level, in feet.
     * @param closureRate The closure rate, in feet per minute.
     * @returns Whether the specified closure rate meets the threshold for an excessive closure rate caution alert.
     */
    private static isAlert;
}

/**
 * Garmin TAWS status flags.
 */
declare enum GarminTawsStatus {
    TawsFailed = "TawsFailed",
    TawsNotAvailable = "TawsNotAvailable",
    GpwsFailed = "TawsGpwsFailed"
}
/**
 * Garmin TAWS inhibit flags.
 */
declare enum GarminTawsInhibit {
    /** FLTA and PDA alerts inhibited. */
    FltaPda = "TawsFltaPda",
    /** GPWS alerts (EDR, ECR, FIT, NCR) inhibited. */
    Gpws = "TawsGpws",
    /** FIT alerts based on flap position inhibited. */
    FitFlaps = "TawsFitFlaps",
    /** GSD glideslope alerts inhibited. */
    GsdGlideslope = "TawsGsdGlideslope",
    /** GSD glidepath alerts inhibited. */
    GsdGlidepath = "TawsGsdGlidepath"
}
/**
 * Voice callout altitudes, in feet AGL, supported by Garmin TAWS.
 */
type GarminTawsVoiceCalloutAltitude = 500 | 450 | 400 | 350 | 300 | 250 | 200 | 150 | 100 | 50 | 40 | 30 | 20 | 10;
/**
 * Garmin TAWS alerts.
 */
declare enum GarminTawsAlert {
    RtcWarning = "TawsRtcWarning",
    RtcCaution = "TawsRtcCaution",
    ItiWarning = "TawsItiWarning",
    ItiCaution = "TawsItiCaution",
    RocWarning = "TawsRocWarning",
    RocCaution = "TawsRocCaution",
    IoiWarning = "TawsIoiWarning",
    IoiCaution = "TawsIoiCaution",
    PdaCaution = "TawsPdaCaution",
    EdrWarning = "TawsEdrWarning",
    EdrCaution = "TawsEdrCaution",
    EcrWarning = "TawsEcrWarning",
    EcrCaution = "TawsEcrCaution",
    FitTerrainCaution = "TawsFitTerrainCaution",
    FitGearCaution = "TawsFitGearCaution",
    FitFlapsCaution = "TawsFitFlapsCaution",
    FitTakeoffCaution = "TawsFitTakeoffCaution",
    NcrCaution = "TawsNcrCaution",
    GsdGlideslopeCaution = "TawsGsdGlideslopeCaution",
    GsdGlidepathCaution = "TawsGsdGlidepathCaution",
    Vco500 = "TawsVco500",
    Vco450 = "TawsVco450",
    Vco400 = "TawsVco400",
    Vco350 = "TawsVco350",
    Vco300 = "TawsVco300",
    Vco250 = "TawsVco250",
    Vco200 = "TawsVco200",
    Vco150 = "TawsVco150",
    Vco100 = "TawsVco100",
    Vco50 = "TawsVco50",
    Vco40 = "TawsVco40",
    Vco30 = "TawsVco30",
    Vco20 = "TawsVco20",
    Vco10 = "TawsVco10"
}

/**
 * Alerts issued by `GarminExcessiveClosureRateModule`.
 */
type GarminExcessiveClosureRateAlert = GarminTawsAlert.EcrWarning | GarminTawsAlert.EcrCaution;

/**
 * Configuration options for {@link GarminExcessiveDescentRateModule}.
 */
type GarminExcessiveDescentRateModuleOptions = {
    /**
     * Whether alerting should function as a GPWS alert. If `true`, then radar altimeter data (up to 2500 feet AGL) will
     * be used to measure height above terrain, and alerting will be inhibited when the `GarminTawsStatus.GpwsFailed`
     * status is active. If `false`, then GPS altitude in conjunction with terrain database ground elevation will be used
     * to measure height above terrain, and alerting will be inhibited when the `GarminTawsStatus.TawsFailed` or
     * `GarminTawsStatus.TawsNotAvailable` statuses are active. Defaults to `false`.
     */
    functionAsGpws?: boolean;
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must be met
     * before the alert is triggered. Defaults to `2000`.
     */
    triggerDebounce?: number;
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must not be
     * met before the alert is untriggered. Defaults to `2000`.
     */
    untriggerDebounce?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes triggered before it can be untriggered. Defaults to
     * `5000`.
     */
    triggerHysteresis?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes untriggered before it can be triggered. Defaults to
     * `0`.
     */
    untriggerHysteresis?: number;
    /** The inhibit flags that should inhibit alerting. If not defined, then no flags will inhibit alerting. */
    inhibitFlags?: Iterable<string>;
};
/**
 * A Garmin terrain alerting system module that handles excessive descent rate (EDR) alerts.
 */
declare class GarminExcessiveDescentRateModule implements TerrainSystemModule {
    private readonly functionAsGpws;
    private readonly triggerDebounce;
    private readonly untriggerDebounce;
    private readonly triggerHysteresis;
    private readonly untriggerHysteresis;
    private readonly inhibitFlags;
    private isReset;
    private isInhibited;
    private triggeredAlert;
    private warningTriggerDebounceTimer;
    private cautionTriggerDebounceTimer;
    private warningUntriggerDebounceTimer;
    private cautionUntriggerDebounceTimer;
    private triggerHysteresisTimer;
    private untriggerHysteresisTimer;
    private lastUpdateTime;
    /**
     * Creates a new instance of GarminExcessiveDescentRateModule.
     * @param options Options with which to configure the module.
     */
    constructor(options?: Readonly<GarminExcessiveDescentRateModuleOptions>);
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: TerrainSystemOperatingMode, statuses: ReadonlySet<string>, inhibits: ReadonlySet<string>, data: Readonly<TerrainSystemData>, alertController: TerrainSystemAlertController): void;
    /**
     * Updates whether this module's alerts are inhibited.
     * @param inhibits The parent system's currently active inhibits.
     * @param alertController A controller for alerts issued by the parent system.
     */
    private updateInhibits;
    /**
     * Updates whether to issue an excessive descent rate alert.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param agl The airplane's current height above ground level, in feet.
     * @param verticalSpeed The airplane's current vertical speed, in feet per minute.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private updateAlerts;
    /**
     * Resolves a desired triggered alert to an alert to trigger.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param desiredTriggeredAlert The desired triggered alert, or `null` if all alerts are desired to be untriggered.
     * @returns The alert to trigger, or `null` if no alert should be triggered.
     */
    private resolveTriggeredAlert;
    /**
     * Resolves a desired triggered alert that is of higher severity than this module's existing triggered alert.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param desiredTriggeredAlert The desired triggered alert.
     * @returns The alert to trigger, or `null` if no alert should be triggered.
     */
    private resolveTriggeredAlertUpgrade;
    /**
     * Resolves a desired triggered alert that is of lower severity than this module's existing triggered alert.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param desiredTriggeredAlert The desired triggered alert, or `null` if all alerts are desired to be untriggered.
     * @returns The alert to trigger, or `null` if no alert should be triggered.
     */
    private resolveTriggeredAlertDowngrade;
    /**
     * Deactivates all excessive descent rate alerts.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private reset;
    /** @inheritDoc */
    onDestroy(): void;
    /**
     * Checks whether a descent rate meets the threshold for an excessive descent rate warning alert for a given height
     * above ground level.
     * @param agl The height above ground level, in feet.
     * @param descentRate The descent rate, in feet per minute.
     * @returns Whether the specified descent rate meets the threshold for an excessive descent rate warning alert.
     */
    private static isWarning;
    /**
     * Checks whether a descent rate meets the threshold for an excessive descent rate caution alert for a given height
     * above ground level.
     * @param agl The height above ground level, in feet.
     * @param descentRate The descent rate, in feet per minute.
     * @returns Whether the specified descent rate meets the threshold for an excessive descent rate caution alert.
     */
    private static isCaution;
}

/**
 * Alerts issued by `GarminExcessiveDescentRateModule`.
 */
type GarminExcessiveDescentRateAlert = GarminTawsAlert.EdrWarning | GarminTawsAlert.EdrCaution;

/**
 * Configuration options for {@link GarminGlideslopeDeviationModule}.
 */
type GarminGlideslopeDeviationModuleOptions = {
    /**
     * Whether alerting should function as a GPWS alert. If `true`, then radar altimeter data (up to 2500 feet AGL) will
     * be used to measure height above terrain, and alerting will be inhibited when the `GarminTawsStatus.GpwsFailed`
     * status is active. If `false`, then GPS altitude in conjunction with terrain database ground elevation will be used
     * to measure height above terrain, and alerting will be inhibited when the `GarminTawsStatus.TawsFailed` or
     * `GarminTawsStatus.TawsNotAvailable` statuses are active. Defaults to `false`.
     */
    functionAsGpws?: boolean;
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must be met
     * before the alert is triggered. Defaults to `2000`.
     */
    triggerDebounce?: number;
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must not be
     * met before the alert is untriggered. Defaults to `2000`.
     */
    untriggerDebounce?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes triggered before it can be untriggered. Defaults to
     * `5000`.
     */
    triggerHysteresis?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes untriggered before it can be triggered. Defaults to
     * `0`.
     */
    untriggerHysteresis?: number;
    /**
     * The inhibit flags that should inhibit glideslope alerting. If not defined, then no flags will inhibit glideslope
     * alerting.
     */
    glideslopeInhibitFlags?: Iterable<string>;
    /**
     * The inhibit flags that should inhibit glidepath alerting. If not defined, then no flags will inhibit glidepath
     * alerting.
     */
    glidepathInhibitFlags?: Iterable<string>;
};
/**
 * A Garmin terrain alerting system module that handles glideslope/glidepath deviation (GSD) alerts.
 */
declare class GarminGlideslopeDeviationModule implements TerrainSystemModule {
    private readonly functionAsGpws;
    private readonly triggerDebounce;
    private readonly untriggerDebounce;
    private readonly triggerHysteresis;
    private readonly untriggerHysteresis;
    private readonly glideslopeInhibitFlags;
    private readonly glidepathInhibitFlags;
    private isReset;
    private isGlideslopeInhibited;
    private isGlidepathInhibited;
    private triggeredAlert;
    private triggerDebounceTimer;
    private untriggerDebounceTimer;
    private triggerHysteresisTimer;
    private untriggerHysteresisTimer;
    private lastUpdateTime;
    /**
     * Creates a new instance of GarminGlideslopeDeviationModule.
     * @param options Options with which to configure the module.
     */
    constructor(options?: Readonly<GarminGlideslopeDeviationModuleOptions>);
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: TerrainSystemOperatingMode, statuses: ReadonlySet<string>, inhibits: ReadonlySet<string>, data: Readonly<TerrainSystemData>, alertController: TerrainSystemAlertController): void;
    /**
     * Updates whether this module's alerts are inhibited.
     * @param inhibits The parent system's currently active inhibits.
     * @param alertController A controller for alerts issued by the parent system.
     */
    private updateInhibits;
    /**
     * Updates whether to issue an excessive descent rate alert.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param approachType The active approach type.
     * @param agl The airplane's current height above ground level, in feet.
     * @param gsGpDeviation The airplane's current glideslope/glidepath deviation, scaled such that 1 represents
     * full-scale deviation. Positive deviation indicates the airplane is below the glideslope/glidepath.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private updateAlerts;
    /**
     * Resolves a desired triggered alert to an alert to trigger.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param desiredTriggeredAlert The desired triggered alert, or `null` if all alerts are desired to be untriggered.
     * @returns The alert to trigger, or `null` if no alert should be triggered.
     */
    private resolveTriggeredAlert;
    /**
     * Untriggers all of this module's alerts.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private reset;
    /** @inheritDoc */
    onDestroy(): void;
    /**
     * Checks whether a glideslope/glidepath deviation meets the threshold for a glideslope/glidepath deviation alert for
     * a given height above ground level.
     * @param agl The height above ground level, in feet.
     * @param gsGpDeviation The glideslope/glidepath deviation, scaled such that 1 represents full-scale deviation.
     * Positive deviation indicates the airplane is below the glideslope/glidepath.
     * @returns Whether the specified deviation meets the threshold for a glideslope/glidepath deviation alert.
     */
    private static isAlert;
}

/**
 * Alerts issued by `GarminGlideslopeDeviationModule`.
 */
type GarminGlideslopeDeviationAlert = GarminTawsAlert.GsdGlideslopeCaution | GarminTawsAlert.GsdGlidepathCaution;

/**
 * Configuration options for {@link GarminNegativeClimbRateModule}.
 */
type GarminNegativeClimbRateModuleOptions = {
    /**
     * Whether alerting should function as a GPWS alert. If `true`, then radar altimeter data (up to 2500 feet AGL) will
     * be used to measure height above terrain, and alerting will be inhibited when the `GarminTawsStatus.GpwsFailed`
     * status is active. If `false`, then GPS altitude in conjunction with runway threshold elevation data will be used
     * to measure height above terrain, and alerting will be inhibited when the `GarminTawsStatus.TawsFailed` or
     * `GarminTawsStatus.TawsNotAvailable` statuses are active. Defaults to `false`.
     */
    functionAsGpws?: boolean;
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must be met
     * before the alert is triggered. Defaults to `2000`.
     */
    triggerDebounce?: number;
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must not be
     * met before the alert is untriggered. Defaults to `2000`.
     */
    untriggerDebounce?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes triggered before it can be untriggered. Defaults to
     * `5000`.
     */
    triggerHysteresis?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes untriggered before it can be triggered. Defaults to
     * `0`.
     */
    untriggerHysteresis?: number;
    /** The inhibit flags that should inhibit alerting. If not defined, then no flags will inhibit alerting. */
    inhibitFlags?: Iterable<string>;
};
/**
 * A Garmin terrain alerting system module that handles negative climb rate after takeoff (NCR) alerts.
 */
declare class GarminNegativeClimbRateModule implements TerrainSystemModule {
    private static readonly MAX_DISTANCE_FROM_AIRPORT;
    private readonly functionAsGpws;
    private readonly triggerDebounce;
    private readonly untriggerDebounce;
    private readonly triggerHysteresis;
    private readonly untriggerHysteresis;
    private readonly inhibitFlags;
    private isReset;
    private isInhibited;
    private altitudeLossReference;
    private isAlertTriggered;
    private triggerDebounceTimer;
    private untriggerDebounceTimer;
    private triggerHysteresisTimer;
    private untriggerHysteresisTimer;
    private lastUpdateTime;
    /**
     * Creates a new instance of GarminNegativeClimbRateModule.
     * @param options Options with which to configure the module.
     */
    constructor(options?: Readonly<GarminNegativeClimbRateModuleOptions>);
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: TerrainSystemOperatingMode, statuses: ReadonlySet<string>, inhibits: ReadonlySet<string>, data: Readonly<TerrainSystemData>, alertController: TerrainSystemAlertController): void;
    /**
     * Updates whether this module's alerts are inhibited.
     * @param inhibits The parent system's currently active inhibits.
     * @param alertController A controller for alerts issued by the parent system.
     */
    private updateInhibits;
    /**
     * Updates whether to issue a negative climb rate after takeoff alert.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param agl The airplane's current height above ground level, in feet.
     * @param altitude The airplane's current altitude, in feet.
     * @param verticalSpeed The airplane's current vertical speed, in feet per minute.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private updateAlerts;
    /**
     * Resolves a desired alert trigger state to a trigger state to set.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param isTriggerDesired Whether the desired alert trigger state is to trigger the alert.
     * @returns The trigger state to set.
     */
    private resolveAlertTriggerState;
    /**
     * Deactivates all negative climb rate after takeoff alerts.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private reset;
    /** @inheritDoc */
    onDestroy(): void;
    /**
     * Checks whether a descent rate meets the threshold for an altitude loss alert for a given height above ground
     * level.
     * @param agl The height above ground level, in feet.
     * @param altitudeLoss The altitude loss, in feet.
     * @returns Whether the specified descent rate meets the threshold for an altitude loss alert.
     */
    private static isAltitudeLoss;
    /**
     * Checks whether a descent rate meets the threshold for a sink rate alert for a given height above ground level.
     * @param agl The height above ground level, in feet.
     * @param descentRate The descent rate, in feet per minute.
     * @returns Whether the specified descent rate meets the threshold for a sink rate alert.
     */
    private static isSinkRate;
}

/**
 * Alerts issued by `GarminNegativeClimbRateModule`.
 */
type GarminNegativeClimbRateAlert = GarminTawsAlert.NcrCaution;

/**
 * Configuration options for {@link GarminPrematureDescentModule}.
 */
type GarminPrematureDescentModuleOptions = {
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must be met
     * before the alert is triggered. Defaults to `2000`.
     */
    triggerDebounce?: number;
    /**
     * The consecutive amount of time, in milliseconds, that the conditions for one of the module's alerts must not be
     * met before the alert is untriggered. Defaults to `2000`.
     */
    untriggerDebounce?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes triggered before it can be untriggered. Defaults to
     * `5000`.
     */
    triggerHysteresis?: number;
    /**
     * The amount of time, in milliseconds, after an alert becomes untriggered before it can be triggered. Defaults to
     * `0`.
     */
    untriggerHysteresis?: number;
    /** The inhibit flags that should inhibit alerting. If not defined, then no flags will inhibit alerting. */
    inhibitFlags?: Iterable<string>;
};
/**
 * A Garmin terrain alerting system module that handles premature descent (PDA) alerts.
 */
declare class GarminPrematureDescentModule implements TerrainSystemModule {
    private static readonly MAX_DISTANCE_FROM_RUNWAY;
    private static readonly MIN_DISTANCE_FROM_RUNWAY;
    private readonly triggerDebounce;
    private readonly untriggerDebounce;
    private readonly triggerHysteresis;
    private readonly untriggerHysteresis;
    private readonly inhibitFlags;
    private isReset;
    private isInhibited;
    private isAlertTriggered;
    private triggerDebounceTimer;
    private untriggerDebounceTimer;
    private triggerHysteresisTimer;
    private untriggerHysteresisTimer;
    private lastUpdateTime;
    /**
     * Creates a new instance of GarminPrematureDescentModule.
     * @param options Options with which to configure the module.
     */
    constructor(options?: Readonly<GarminPrematureDescentModuleOptions>);
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: TerrainSystemOperatingMode, statuses: ReadonlySet<string>, inhibits: ReadonlySet<string>, data: Readonly<TerrainSystemData>, alertController: TerrainSystemAlertController): void;
    /**
     * Updates whether this module's alerts are inhibited.
     * @param inhibits The parent system's currently active inhibits.
     * @param alertController A controller for alerts issued by the parent system.
     */
    private updateInhibits;
    /**
     * Updates whether to issue a premature descent alert.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param distanceToRunway The airplane's current distance from the destination runway, in nautical miles.
     * @param agl The airplane's current height above destination, in feet.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private updateAlerts;
    /**
     * Resolves a desired alert trigger state to a trigger state to set.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param isTriggerDesired Whether the desired alert trigger state is to trigger the alert.
     * @returns The trigger state to set.
     */
    private resolveAlertTriggerState;
    /**
     * Deactivates all premature descent alerts.
     * @param dt The amount of simulation time elapsed since the last update, in milliseconds.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private reset;
    /** @inheritDoc */
    onDestroy(): void;
    /**
     * Checks whether a height above destination meets the threshold for a premature descent alert for a given distance
     * to the destination runway.
     * @param distanceToRunway The distance to the destination runway, in nautical miles.
     * @param agl The height above destination, in feet.
     * @returns Whether the specified height above destination meets the threshold for a premature descent alert.
     */
    private static isAlert;
}

/**
 * Alerts issued by `GarminPrematureDescentModule`.
 */
type GarminPrematureDescentAlert = GarminTawsAlert.PdaCaution;

/**
 * Configuration options for {@link GarminVoiceCalloutModule}.
 */
type GarminVoiceCalloutModuleOptions = {
    /** Whether to inhibit the 500-feet callout when the autopilot's GS or GP mode is active. Defaults to `false`. */
    inhibit500WhenGsGpActive?: boolean;
    /** The interval at which the module's nearest runway data should be updated, in milliseconds. Defaults to 3000. */
    nearestRunwayUpdateInterval?: number;
};
/**
 * A Garmin terrain alerting system module that handles touchdown voice callouts.
 */
declare class GarminVoiceCalloutModule implements TerrainSystemModule {
    private readonly entries;
    private readonly nearestRunwayRefreshInterval;
    private nearestAirport;
    private nearestAirportRunways;
    private nearestRunwayAltitude;
    private lastNearestRunwayRefreshTime;
    private readonly inhibit500WhenGsGpActive;
    private isReset;
    /**
     * Creates a new instance of GarminVoiceCalloutModule.
     * @param options Options with which to configure the module.
     */
    constructor(options?: Readonly<GarminVoiceCalloutModuleOptions>);
    /** @inheritDoc */
    onInit(): void;
    /** @inheritDoc */
    onUpdate(operatingMode: TerrainSystemOperatingMode, statuses: ReadonlySet<string>, inhibits: ReadonlySet<string>, data: Readonly<TerrainSystemData>, alertController: TerrainSystemAlertController): void;
    /**
     * Updates the nearest runway to the airplane.
     * @param nearestAirport The nearest airport to the airplane.
     * @param data The current terrain system data.
     */
    private updateNearestRunway;
    /**
     * Updates the state of all callout alerts.
     * @param altitudeAbove The current altitude, in feet, of the airplane above the reference (either the nearest runway
     * threshold or the ground).
     * @param isGsGpActive Whether the autopilot's GS or GP mode is active.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private updateCallouts;
    /**
     * Disarms and deactivates all touchdown callout alerts.
     * @param alertController A controller for alerts tracked by this module's parent system.
     */
    private reset;
    /** @inheritDoc */
    onDestroy(): void;
}

/**
 * Alerts issued by `GarminVoiceCalloutModule`.
 */
type GarminVoiceCalloutAlert = GarminTawsAlert.Vco500 | GarminTawsAlert.Vco450 | GarminTawsAlert.Vco400 | GarminTawsAlert.Vco350 | GarminTawsAlert.Vco300 | GarminTawsAlert.Vco250 | GarminTawsAlert.Vco200 | GarminTawsAlert.Vco150 | GarminTawsAlert.Vco100 | GarminTawsAlert.Vco50 | GarminTawsAlert.Vco40 | GarminTawsAlert.Vco30 | GarminTawsAlert.Vco20 | GarminTawsAlert.Vco10;

/**
 * A Garmin terrain alerting system.
 */
interface TerrainSystem {
    /** This system's ID. */
    readonly id: string;
    /** This system's type. */
    readonly type: string;
    /**
     * Adds a module to this system.
     * @param module The module to add.
     */
    addModule(module: TerrainSystemModule): void;
    /**
     * Initializes this system. Once the system is initialized, it can begin updating its internal state and issuing
     * alerts and will publish its state to the event bus.
     */
    init(): void;
    /**
     * Turns this system on.
     */
    turnOn(): void;
    /**
     * Turns this system off.
     */
    turnOff(): void;
    /**
     * Begins a self-test of this system.
     */
    startTest(): void;
    /**
     * Adds an inhibit flag to this system.
     * @param inhibit The flag to add.
     */
    addInhibit(inhibit: string): void;
    /**
     * Removes an inhibit flag from this system.
     * @param inhibit The flag to remove.
     */
    removeInhibit(inhibit: string): void;
    /**
     * Removes all inhibit flags from this system.
     */
    removeAllInhibits(): void;
    /**
     * Updates this system.
     */
    update(): void;
    /**
     * Destroys this system. Once destroyed, this system can no longer be updated.
     */
    destroy(): void;
}

/**
 * A provider of Garmin terrain alerting system data.
 */
interface TerrainSystemDataProvider {
    /** The current terrain system data. */
    readonly data: Readonly<TerrainSystemData>;
}

/**
 * Events published by Garmin terrain alerting systems, keyed by base topic name.
 */
type BaseTerrainSystemEvents = {
    /** The terrain system type. */
    terrainsys_type: string;
    /** The current terrain system operating mode. */
    terrainsys_operating_mode: TerrainSystemOperatingMode;
    /** The terrain system's active status flags. */
    terrainsys_status_flags: readonly string[];
    /** A status flag was added to the terrain system. */
    terrainsys_status_added: string;
    /** A status flag was removed from the terrain system. */
    terrainsys_status_removed: string;
    /** The terrain system's active inhibit flags. */
    terrainsys_inhibit_flags: readonly string[];
    /** An inhibit flag was added to the terrain system. */
    terrainsys_inhibit_added: string;
    /** An inhibit flag was removed from the terrain system. */
    terrainsys_inhibit_removed: string;
    /** The terrain system's triggered alerts. */
    terrainsys_triggered_alerts: readonly string[];
    /** An alert was triggered by the terrain system. */
    terrainsys_alert_triggered: string;
    /** An alert was untriggered by the terrain system. */
    terrainsys_alert_untriggered: string;
    /** The terrain system's inhibited alerts. */
    terrainsys_inhibited_alerts: readonly string[];
    /** An alert was inhibited by the terrain system. */
    terrainsys_alert_inhibited: string;
    /** An alert was uninhibited by the terrain system. */
    terrainsys_alert_uninhibited: string;
    /** The terrain system's active alerts. */
    terrainsys_active_alerts: readonly string[];
    /** An alert was activated by the terrain system. */
    terrainsys_alert_activated: string;
    /** An alert was deactivated by the terrain system. */
    terrainsys_alert_deactivated: string;
    /** The terrain system's current prioritized active alert. */
    terrainsys_prioritized_alert: string | null;
};
/**
 * Events used to control Garmin terrain alerting systems, keyed by base topic name.
 */
type BaseTerrainSystemControlEvents = {
    /** Turns the terrain system on. */
    terrainsys_turn_on: void;
    /** Turns the terrain system off. */
    terrainsys_turn_off: void;
    /** Starts a test of the terrain system. */
    terrainsys_start_test: void;
    /** Adds an inhibit flag. */
    terrainsys_add_inhibit: string;
    /** Removes an inhibit flag. */
    terrainsys_remove_inhibit: string;
    /** Removes all inhibit flags. */
    terrainsys_remove_all_inhibits: void;
};
/**
 * The event bus topic suffix for a Garmin terrain alerting system with a specific ID.
 */
type TerrainSystemEventSuffix<ID extends string> = ID extends '' ? '' : `_${ID}`;
/**
 * Events published by a Garmin terrain alerting system with a specific ID.
 */
type TerrainSystemEventsForId<ID extends string> = {
    [P in keyof BaseTerrainSystemEvents as `${P}${TerrainSystemEventSuffix<ID>}`]: BaseTerrainSystemEvents[P];
};
/**
 * All possible events published by Garmin terrain alerting systems.
 */
interface TerrainSystemEvents extends TerrainSystemEventsForId<''>, TerrainSystemEventsForId<string> {
}
/**
 * Events used to control a Garmin terrain alerting system with a specific ID.
 */
type TerrainSystemControlEventsForId<ID extends string> = {
    [P in keyof BaseTerrainSystemControlEvents as `${P}${TerrainSystemEventSuffix<ID>}`]: BaseTerrainSystemControlEvents[P];
};
/**
 * All possible events used to control Garmin terrain alerting systems.
 */
interface TerrainSystemControlEvents extends TerrainSystemControlEventsForId<''>, TerrainSystemControlEventsForId<string> {
}

/**
 * An abstract implementation of {@link TerrainSystem}. This class handles adding, initializing, updating, and
 * destroying modules. It also handles publishing topics to the event bus in responses to changes in state. Finally, it
 * handles listening to and responding to control events published to the event bus.
 */
declare abstract class AbstractTerrainSystem<ID extends string> implements TerrainSystem {
    readonly id: ID;
    readonly type: string;
    protected readonly bus: EventBus;
    protected readonly dataProvider: TerrainSystemDataProvider;
    protected readonly prioritizedAlertSelector: (alerts: Iterable<string>) => string | null;
    protected readonly idSuffix: TerrainSystemEventSuffix<ID>;
    protected readonly topicMap: {
        [P in keyof BaseTerrainSystemEvents]: `${P}${TerrainSystemEventSuffix<ID>}`;
    };
    protected readonly publisher: _microsoft_msfs_sdk.Publisher<TerrainSystemEvents>;
    protected readonly operatingMode: Subject<TerrainSystemOperatingMode>;
    protected readonly statuses: SetSubject<string>;
    protected readonly inhibits: SetSubject<string>;
    protected readonly triggeredAlerts: SetSubject<string>;
    protected readonly inhibitedAlerts: SetSubject<string>;
    protected readonly activeAlerts: SetSubject<string>;
    protected readonly prioritizedAlert: Subject<string | null>;
    protected readonly modules: TerrainSystemModule[];
    protected readonly alertController: TerrainSystemAlertController;
    protected isAlive: boolean;
    protected isInit: boolean;
    protected readonly subscriptions: Subscription[];
    /**
     * Creates a new instance of AbstractTerrainSystem.
     * @param id This terrain system's ID.
     * @param type This terrain system's type.
     * @param bus The event bus.
     * @param dataProvider A provider of terrain system data.
     * @param prioritizedAlertSelector A function that this system uses to select a prioritized alert from an iterable of
     * active alerts each time the set of active alerts changes.
     */
    constructor(id: ID, type: string, bus: EventBus, dataProvider: TerrainSystemDataProvider, prioritizedAlertSelector: (alerts: Iterable<string>) => string | null);
    /** @inheritDoc */
    addModule(module: TerrainSystemModule): void;
    /** @inheritDoc */
    init(): void;
    /**
     * A method that is called when this system is initialized.
     */
    protected onInit(): void;
    /**
     * Initializes publishing of this system's operating mode to the event bus.
     */
    protected initOperatingModePublishing(): void;
    /**
     * Initializes publishing of this system's status flags to the event bus.
     */
    protected initStatusPublishing(): void;
    /**
     * Initializes publishing of this system's inhibit flags to the event bus.
     */
    protected initInhibitPublishing(): void;
    /**
     * Initializes publishing of this system's active alerts to the event bus.
     */
    protected initAlertPublishing(): void;
    /**
     * Initializes listeners for control events published to the event bus.
     */
    protected initControlEventListeners(): void;
    /**
     * Initializes this system's modules.
     */
    protected initModules(): void;
    /** @inheritDoc */
    turnOn(): void;
    /** @inheritDoc */
    turnOff(): void;
    /** @inheritDoc */
    startTest(): void;
    /** @inheritDoc */
    addInhibit(inhibit: string): void;
    /** @inheritDoc */
    removeInhibit(inhibit: string): void;
    /** @inheritDoc */
    removeAllInhibits(): void;
    /**
     * Responds to when this system's operating mode changes.
     * @param mode The new operating mode.
     */
    protected onOperatingModeChanged(mode: TerrainSystemOperatingMode): void;
    /**
     * Responds to when the set of this system's triggered alerts changes.
     * @param alerts The set of triggered alerts.
     * @param type The type of change that occurred.
     * @param alert The alert that was changed.
     */
    protected onTriggeredAlertsChanged(alerts: ReadonlySet<string>, type: SubscribableSetEventType, alert: string): void;
    /**
     * Responds to when the set of this system's inhibited alerts changes.
     * @param alerts The set of inhibited alerts.
     * @param type The type of change that occurred.
     * @param alert The alert that was changed.
     */
    protected onInhibitedAlertsChanged(alerts: ReadonlySet<string>, type: SubscribableSetEventType, alert: string): void;
    /**
     * Responds to when the set of this system's active alerts changes.
     * @param alerts The set of active alerts.
     * @param type The type of change that occurred.
     * @param alert The alert that was changed.
     */
    protected onActiveAlertsChanged(alerts: ReadonlySet<string>, type: SubscribableSetEventType, alert: string): void;
    /**
     * Publishes data to event bus alert topics based on a change to this system's active alerts.
     * @param alerts The set of active alerts.
     * @param type The type of change that occurred.
     * @param alert The alert that was changed.
     */
    protected publishTriggeredAlert(alerts: ReadonlySet<string>, type: SubscribableSetEventType, alert: string): void;
    /**
     * Publishes data to event bus alert topics based on a change to this system's active alerts.
     * @param alerts The set of active alerts.
     * @param type The type of change that occurred.
     * @param alert The alert that was changed.
     */
    protected publishInhibitedAlert(alerts: ReadonlySet<string>, type: SubscribableSetEventType, alert: string): void;
    /**
     * Publishes data to event bus alert topics based on a change to this system's active alerts.
     * @param alerts The set of active alerts.
     * @param type The type of change that occurred.
     * @param alert The alert that was changed.
     */
    protected publishActiveAlert(alerts: ReadonlySet<string>, type: SubscribableSetEventType, alert: string): void;
    /**
     * A method that is called when this system receives a command to turn on.
     */
    protected onTurnOn(): void;
    /**
     * A method that is called when this system receives a command to turn off.
     */
    protected onTurnOff(): void;
    /**
     * A method that is called when this system receives a command to start a self-test.
     */
    protected onStartTest(): void;
    /**
     * A method that is called when this system receives a command to add an inhibit flag.
     * @param inhibit The flag to add.
     */
    protected onAddInhibit(inhibit: string): void;
    /**
     * A method that is called when this system receives a command to remove an inhibit flag.
     * @param inhibit The flag to remove.
     */
    protected onRemoveInhibit(inhibit: string): void;
    /**
     * A method that is called when this system receives a command to remove all inhibit flags.
     */
    protected onRemoveAllInhibits(): void;
    /**
     * Triggers an alert.
     * @param alert The alert to trigger.
     */
    protected triggerAlert(alert: string): void;
    /**
     * Untriggers an alert.
     * @param alert The alert to untrigger.
     */
    protected untriggerAlert(alert: string): void;
    /**
     * Inhibits an alert.
     * @param alert The alert to inhibit.
     */
    protected inhibitAlert(alert: string): void;
    /**
     * Uninhibits an alert.
     * @param alert The alert to uninhibit.
     */
    protected uninhibitAlert(alert: string): void;
    /** @inheritDoc */
    update(): void;
    /**
     * A method that is called when this system is updated.
     */
    protected onUpdate(): void;
    /**
     * Updates this system's modules.
     */
    protected updateModules(): void;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * Parameters for exponential smoothers used by {@link DefaultTerrainSystemDataProvider}.
 */
type DefaultTerrainSystemDataProviderSmootherParams = {
    /**
     * The smoothing time constant, in milliseconds. The larger the constant, the greater the smoothing effect. A value
     * less than or equal to 0 is equivalent to no smoothing.
     */
    tau?: number;
    /**
     * The time constant, in milliseconds, for smoothing the estimated velocity of the input value. The larger the
     * constant, the greater the smoothing effect applied to the estimated velocity. A value less than or equal to 0 is
     * equivalent to no smoothing. If not defined, then estimated velocity will not be used to calculate the final
     * smoothed value.
     */
    tauVelocity?: number;
    /**
     * The time constant, in milliseconds, for smoothing the estimated acceleration of the input value. The larger the
     * constant, the greater the smoothing effect applied to the estimated acceleration. A value less than or equal to 0
     * is equivalent to no smoothing. If this value or `tauVelocity` is not defined, then estimated acceleration will not
     * be used to calculate the final smoothed value.
     */
    tauAccel?: number;
    /**
     * The elapsed time threshold, in milliseconds, above which smoothing will not be applied to a new input value.
     * Defaults to 10000.
     */
    dtThreshold?: number;
};
/**
 * Configuration options for {@link DefaultTerrainSystemDataProvider}.
 */
type DefaultTerrainSystemDataProviderOptions = {
    /** The index of the FMS geo-positioning system from which to source data. */
    fmsPosIndex: number | Subscribable<number>;
    /** The index of the radar altimeter from which to source data. */
    radarAltIndex: number | Subscribable<number>;
    /** The index of the ADC from which to source data. */
    adcIndex: number | Subscribable<number>;
    /** The index of the AHRS from which to source data. */
    ahrsIndex: number | Subscribable<number>;
    /**
     * Parameters for smoothing applied to GPS vertical speed. `tau` defaults to `1000 / Math.LN2`, `tauVelocity` and
     * `tauAccel` default to `undefined.
     */
    gpsVerticalSpeedSmootherParams?: Readonly<DefaultTerrainSystemDataProviderSmootherParams>;
    /**
     * Parameters for smoothing applied to GPS above ground height. `tau` defaults to `2000 / Math.LN2`, `tauVelocity`
     * defaults to `1000 / Math.LN2`, and `tauAccel` defaults to `undefined.
     */
    gpsAglSmootherParams?: Readonly<DefaultTerrainSystemDataProviderSmootherParams>;
    /**
     * Parameters for smoothing applied to radar altitude. `tau` defaults to `2000 / Math.LN2`, `tauVelocity` defaults to
     * `1000 / Math.LN2`, and `tauAccel` defaults to `undefined.
     */
    radarAltitudeSmootherParams?: Readonly<DefaultTerrainSystemDataProviderSmootherParams>;
    /** The interval at which the module's nearest airport data should be updated, in milliseconds. Defaults to 3000. */
    nearestAirportUpdateInterval?: number;
};
/**
 * A default provider of Garmin terrain alerting system data which sources data from FMS geo-positioning, radar
 * altimeter, ADC, and AHRS systems.
 */
declare class DefaultTerrainSystemDataProvider implements TerrainSystemDataProvider {
    private readonly bus;
    private readonly fms;
    private readonly activeNavReferenceIndicator;
    private static readonly NEAREST_AIRPORT_RADIUS_METERS;
    private static readonly NEAREST_AIRPORT_RADIUS_GAR;
    private static readonly RUNWAY_NO_WATER_MASK;
    private readonly fmsPosIndex;
    private readonly radarAltIndex;
    private readonly adcIndex;
    private readonly ahrsIndex;
    private readonly simTime;
    private readonly simRate;
    private readonly isOnGround;
    private readonly gearPosition;
    private readonly flapsAngle;
    private isFmsPosIndexValid;
    private readonly fmsPosMode;
    private readonly gpsPosSource;
    private readonly gpsVerticalSpeedSource;
    private readonly gpsGroundSpeed;
    private readonly groundElevationSource;
    private readonly gpsAglSource;
    private readonly gpsPos;
    private readonly gpsVerticalSpeedSmoother;
    private readonly gpsAglSmoother;
    private isRadarAltIndexValid;
    private readonly radarAltimeterState;
    private readonly radarAltitudeSource;
    private readonly radarAltitudeSmoother;
    private isAdcIndexValid;
    private readonly isAltitudeDataValid;
    private readonly baroAltitude;
    private readonly baroVerticalSpeed;
    private readonly baroAglSmoother;
    private isAhrsIndexValid;
    private readonly isAttitudeDataValid;
    private readonly isHeadingDataValid;
    private readonly headingTrue;
    private readonly fmaData;
    private readonly nearestSubscription;
    private readonly nearestSubscriptionUpdateInterval;
    private lastNearestSubscriptionUpdateTime;
    private departureAirportIcao;
    private departureAirport;
    private destinationAirportIcao;
    private destinationAirport;
    private readonly approachDetails;
    private readonly flightPhase;
    private readonly gpServiceLevel;
    private readonly _data;
    /** @inheritDoc */
    readonly data: Readonly<TerrainSystemData>;
    private lastUpdateRealTime;
    private isAlive;
    private isInit;
    private readonly subscriptions;
    /**
     * Creates a new instance of DefaultTerrainSystemDataProvider.
     * @param bus The event bus.
     * @param fms The FMS instance.
     * @param activeNavReferenceIndicator The navigation reference indicator for the active navigation source.
     * @param options Options with which to configure the data provider.
     */
    constructor(bus: EventBus, fms: Fms, activeNavReferenceIndicator: NavReferenceIndicator<string>, options: Readonly<DefaultTerrainSystemDataProviderOptions>);
    /**
     * Initializes this system. Once this system is initialized, it will begin collecting data and updating its modules.
     * @throws Error if this data provider has been destroyed.
     */
    init(): void;
    /**
     * Updates this data provider.
     * @param realTime The current real (operating system) time, as a Javascript timestamp.
     * @throws Error if this data provider has been destroyed.
     */
    update(realTime: number): void;
    /**
     * Updates this provider's airplane control surfaces data.
     */
    private updateControlSurfaces;
    /**
     * Updates this provider's GPS data.
     * @param realTime The current real (operating system) time, as a Javascript timestamp.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    private updateGps;
    /**
     * Updates this module's nearest airport subscription, if necessary.
     * @param realTime The current real (operating system) time, as a UNIX timestamp in milliseconds.
     * @param position The current position of the airplane.
     */
    private updateNearestAirportSubscription;
    /**
     * Updates this provider's radar altimeter data.
     * @param dt dt The elapsed time, in milliseconds, since the last update.
     */
    private updateRadarAltitude;
    /**
     * Updates this provider's barometric altitude data.
     * @param dt dt The elapsed time, in milliseconds, since the last update.
     */
    private updateBaroAltitude;
    /**
     * Updates this provider's attitude and heading data.
     */
    private updateAttitudeHeading;
    /**
     * Updates this provider's autopilot data.
     */
    private updateAutopilot;
    /**
     * Updates this provider's flight plan data.
     */
    private updateFlightPlan;
    /**
     * Retrieves a departure airport.
     * @param icao The ICAO of the airport to retrieve.
     */
    private retrieveDepartureAirport;
    /**
     * Retrieves a destination airport.
     * @param icao The ICAO of the airport to retrieve.
     */
    private retrieveDestinationAirport;
    /**
     * Updates this provider's glideslope/glidepath data.
     */
    private updateGlideslopeGlidepath;
    /**
     * Destroys this data provider.
     */
    destroy(): void;
}

/**
 * A provider of Garmin terrain alerting system state data.
 */
interface TerrainSystemStateDataProvider {
    /** The terrain system's type, or `undefined` if the type is not yet known. */
    readonly type: Subscribable<string | undefined>;
    /** The terrain system's current operating mode. */
    readonly operatingMode: Subscribable<TerrainSystemOperatingMode>;
    /** The terrain system's active status flags. */
    readonly statusFlags: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    /** The terrain system's active inhibit flags. */
    readonly inhibitFlags: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    /** The terrain system's triggered alerts. */
    readonly triggeredAlerts: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    /** The terrain system's inhibited alerts. */
    readonly inhibitedAlerts: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    /** The terrain system's active alerts. */
    readonly activeAlerts: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    /** The terrain system's current prioritized active alert. */
    readonly prioritizedAlert: Subscribable<string | null>;
}

/**
 * A default implementation of {@link TerrainSystemStateDataProvider}.
 */
declare class DefaultTerrainSystemStateDataProvider implements TerrainSystemStateDataProvider {
    private readonly bus;
    private readonly id;
    private readonly _type;
    /** @inheritDoc */
    readonly type: Subscribable<string | undefined>;
    private readonly _operatingMode;
    /** @inheritDoc */
    readonly operatingMode: Subscribable<TerrainSystemOperatingMode>;
    private readonly statusFlagsSource;
    private readonly _statusFlags;
    /** @inheritDoc */
    readonly statusFlags: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    private readonly inhibitFlagsSource;
    private readonly _inhibitFlags;
    /** @inheritDoc */
    readonly inhibitFlags: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    private readonly triggeredAlertsSource;
    private readonly _triggeredAlerts;
    /** @inheritDoc */
    readonly triggeredAlerts: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    private readonly inhibitedAlertsSource;
    private readonly _inhibitedAlerts;
    /** @inheritDoc */
    readonly inhibitedAlerts: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    private readonly activeAlertsSource;
    private readonly _activeAlerts;
    /** @inheritDoc */
    readonly activeAlerts: SubscribableSet<string> & Subscribable<ReadonlySet<string>>;
    private readonly _prioritizedAlert;
    /** @inheritDoc */
    readonly prioritizedAlert: Subscribable<string | null>;
    private isInit;
    private isAlive;
    private isPaused;
    private readonly pauseable;
    private readonly subscriptions;
    /**
     * Creates a new instance of DefaultTerrainSystemStateDataProvider.
     * @param bus The event bus.
     * @param id The ID of the terrain alerting system for which to provide data.
     */
    constructor(bus: EventBus, id: string);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Configuration options for {@link GarminTaws}.
 */
type GarminTawsOptions = {
    /** Whether to include support for the GPWS failure status flag. */
    supportGpwsFailStatus?: boolean;
    /** The duration of the system's self-test, in milliseconds. Defaults to 15000. */
    testDuration?: number;
    /**
     * A function that selects a prioritized alert from an iterable of active alerts each time the set of active alerts
     * changes. If not defined, then a default prioritization scheme based on TSO-151c will be used.
     */
    prioritizedAlertSelector?: (alerts: Iterable<string>) => string | null;
};
/**
 * A Garmin TAWS-A/B terrain alerting system.
 */
declare class GarminTaws<ID extends string> extends AbstractTerrainSystem<ID> {
    private readonly supportGpwsFailStatus;
    private readonly testDuration;
    private testTimeRemaining;
    private lastUpdateSimTime;
    /**
     * Creates a new instance of GarminTaws.
     * @param id This terrain system's ID.
     * @param type This terrain system's type.
     * @param bus The event bus.
     * @param dataProvider A provider of terrain system data.
     * @param options Options with which to configure the system.
     */
    constructor(id: ID, type: string, bus: EventBus, dataProvider: TerrainSystemDataProvider, options?: Readonly<GarminTawsOptions>);
    /** @inheritDoc */
    protected onTurnOn(): void;
    /** @inheritDoc */
    protected onTurnOff(): void;
    /** @inheritDoc */
    protected onStartTest(): void;
    /** @inheritDoc */
    protected untriggerAlert(alert: string): void;
    /** @inheritDoc */
    protected onUpdate(): void;
    private static readonly DEFAULT_ALERT_PRIORITIES;
    /**
     * Selects a prioritized alert from an iterable of active alerts based on the criteria published in TSO-151c.
     * @param alerts An iterable of active alerts.
     * @returns The prioritized alert from the specified set of active alerts, or `null` if a prioritized alert could not
     * be selected.
     */
    private static selectDefaultPrioritizedAlert;
}

/**
 * A utility class for working with Garmin terrain alerting systems.
 */
declare class TerrainSystemUtils {
    /**
     * Gets the event bus topic suffix for a terrain system ID.
     * @param id The ID for which to get the suffix.
     * @returns The event bus topic suffix for the specified terrain system ID.
     */
    static getIdSuffix<ID extends string>(id: ID): TerrainSystemEventSuffix<ID>;
    /**
     * Subscribes to one of the event bus topics related to a terrain system with a given ID.
     * @param id The ID of the terrain system.
     * @param bus The event bus to which to subscribe.
     * @param baseTopic The base name of the topic to which to subscribe.
     * @returns A consumer for the specified event bus topic.
     */
    static onEvent<ID extends string, K extends keyof BaseTerrainSystemEvents>(id: ID, bus: EventBus, baseTopic: K): Consumer<BaseTerrainSystemEvents[K]>;
    /**
     * Subscribes to one of the event bus topics related to a terrain system with a given ID.
     * @param id The ID of the terrain system.
     * @param subscriber The event subscriber to use to subscribe.
     * @param baseTopic The base name of the topic to which to subscribe.
     * @returns A consumer for the specified event bus topic.
     */
    static onEvent<ID extends string, K extends keyof BaseTerrainSystemEvents>(id: ID, subscriber: EventSubscriber<TerrainSystemEventsForId<ID>>, baseTopic: K): Consumer<BaseTerrainSystemEvents[K]>;
}

/**
 * Non-indexed events used to control Garmin timers.
 */
type BaseNonIndexedGarminTimerControlEvents = {
    /** Resets the flight timer. */
    garmin_flt_timer_reset: void;
};
/**
 * Indexed events used to control Garmin timers, keyed by base topic names.
 */
type BaseIndexedGarminTimerControlEvents = {
    /** Sets the active mode for a generic timer. */
    garmin_gen_timer_set_mode: FlightTimerMode;
    /** Sets the initial and current values, in milliseconds, for a generic timer. Stops the timer if it is running. */
    garmin_gen_timer_set_value: number;
    /** Starts a generic timer. */
    garmin_gen_timer_start: void;
    /** Stops a generic timer. */
    garmin_gen_timer_stop: void;
    /** Resets a generic timer value to its initial value. Stops the timer if it is running. */
    garmin_gen_timer_reset: void;
};
/**
 * Events related to flight timers with a specific ID.
 */
type GarminTimerControlEventsForId<ID extends string> = {
    [P in keyof BaseNonIndexedGarminTimerControlEvents as `${P}${FlightTimerEventSuffix<ID>}`]: BaseNonIndexedGarminTimerControlEvents[P];
} & {
    [P in keyof BaseIndexedGarminTimerControlEvents as `${P}${FlightTimerEventSuffix<ID>}_${number}`]: BaseIndexedGarminTimerControlEvents[P];
};
/**
 * All events used to control Garmin timers.
 */
type GarminTimerControlEvents = GarminTimerControlEventsForId<''> & GarminTimerControlEventsForId<string>;

/**
 * Configuration options for {@link GarminTimerManager}.
 */
type GarminTimerManagerOptions = {
    /** The ID of the managed timers. Defaults to the empty ID (`''`). */
    id?: string;
    /** The number of supported generic timers. */
    genericTimerCount: number;
};
/**
 * A manager of timers for Garmin avionics. Manages one flight timer and an arbitrary number of generic timers.
 */
declare class GarminTimerManager {
    private readonly bus;
    /** The index of the flight timer. */
    static readonly FLIGHT_TIMER_INDEX = 1;
    /** The index of the first generic timer. */
    static readonly GENERIC_TIMER_INDEX = 2;
    /** The maximum value of a generic timer, in milliseconds, exclusive. */
    static readonly MAX_GENERIC_TIMER_VALUE: number;
    private readonly id;
    private readonly genericTimerCount;
    private readonly genericTimers;
    private isAlive;
    private isInit;
    private readonly controlSubs;
    /**
     * Creates a new instance of GarminTimerManager.
     * @param bus The event bus.
     * @param options The number of supported generic timers.
     */
    constructor(bus: EventBus, options: Readonly<GarminTimerManagerOptions>);
    /**
     * Creates a new instance of GarminTimerManager.
     * @param bus The event bus.
     * @param genericTimerCount The number of supported generic timers.
     */
    constructor(bus: EventBus, genericTimerCount: number);
    /**
     * Initializes this manager.
     * @throws Error if this manager has been destroyed.
     */
    init(): void;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

export { APExternalGlidepathGuidanceSimVars, APExternalGpsSteerCommandSimVars, APExternalGuidanceProvider, APExternalGuidanceProviderOptions, APExternalVNavGuidanceSimVars, APExternalVerticalPathGuidanceSimVars, AbstractFlightPlanLegWaypointsRecord, AbstractNavReferenceBase, AbstractTerrainSystem, ActiveNavSource, AdcSystem, AdcSystemEvents, AdcSystemSelectionState, AdcSystemSelector, AdcSystemSelectorOptions, AdfRadioNavSource, AdsbSensitivityParameters, AglSystem, AglSystemEvents, AglSystemOptions, AglSystemSmootherParams, AhrsSystem, AhrsSystemEvents, AhrsSystemSelectionState, AhrsSystemSelector, AhrsSystemSelectorOptions, AircraftSymbolOptions, AirportSize, AirportWaypoint, AirspaceShowType, AirspeedAlert, AirspeedAlertOptions, AirspeedAoaDataProvider, AirspeedApproachCueBugOptions, AirspeedDefinition, AirspeedDefinitionContext, AirspeedDefinitionFactory, AirspeedIndicator, AirspeedIndicatorBottomDisplayMode, AirspeedIndicatorBottomDisplayOptions, AirspeedIndicatorColorRange, AirspeedIndicatorColorRangeColor, AirspeedIndicatorColorRangeWidth, AirspeedIndicatorDataProvider, AirspeedIndicatorDataProviderOptions, AirspeedIndicatorProps, AirspeedTapeScaleOptions, AirspeedTrendVectorOptions, AirwayLegType, Altimeter, AltimeterDataProvider, AltimeterProps, AltimeterTapeScaleOptions, AltimeterTrendVectorOptions, AltimeterUserSettingTypes, AltitudeAlertState, AltitudeAlerter, AltitudeAlerterControlEvents, AltitudeArcOptions, AoAIndicatorProps, AoaDataProvider, AoaIndicator, AoaSystem, AoaSystemEvents, AoaSystemOptions, ApproachDetails, ApproachListItem, ApproachNameDisplay, ApproachNameDisplayProps, ApproachNameParts, ArtificalHorizonProps, ArtificialHorizon, ArtificialHorizonColorStop, ArtificialHorizonOptions, ArtificialHorizonSkyColor, AttitudeAircraftSymbol, AttitudeAircraftSymbolColor, AttitudeAircraftSymbolFormat, AttitudeAircraftSymbolProps, BaseFmsEvents, BaseGarminVNavDataEvents, BaseGarminVNavEvents, BaseIndexedGarminTimerControlEvents, BaseLNavDataEvents, BaseNavDataFieldTypeRendererOptions, BaseNonIndexedGarminTimerControlEvents, BaseTerrainSystemControlEvents, BaseTerrainSystemEvents, BasicNavReferenceIndicator, BearingDisplay, BearingDisplayProps, BearingNavDataFieldTypes, BgImgTouchButton, BgImgTouchButtonProps, CASAlertCounts, CASDisplay, CASProps, CDIScaleLabel, CasDisplay2, CasDisplay2Props, CasDisplay2ScrollState, CdiScaleFormatter, ComRadioSpacingManager, ComRadioSpacingSettingMode, ComRadioUserSettingTypes, ComRadioUserSettings, ConnextMapUserSettingTypes, DateTimeFormatSettingMode, DateTimeUserSettingTypes, DateTimeUserSettings, DefaultAirspeedIndicatorDataProvider, DefaultAltimeterDataProvider, DefaultAltimeterDataProviderOptions, DefaultAoaDataProvider, DefaultBaseFlightPathPlanRenderer, DefaultFlightDirectorDataProvider, DefaultFlightPathPlanRenderer, DefaultFullFlightPathPlanRenderer, DefaultGpsIntegrityDataProvider, DefaultMapRunwayDesignationImageCache, DefaultMarkerBeaconDataProvider, DefaultMinimumsDataProvider, DefaultNavDataBarFieldModelFactory, DefaultNavDataBarFieldModelFactoryOptions, DefaultNavStatusBoxDataProvider, DefaultObsSuspDataProvider, DefaultObsSuspDataProviderOptions, DefaultRadarAltimeterDataProvider, DefaultTcasRaCommandDataProvider, DefaultTerrainSystemDataProvider, DefaultTerrainSystemDataProviderOptions, DefaultTerrainSystemDataProviderSmootherParams, DefaultTerrainSystemStateDataProvider, DefaultUnitsUserSettingManager, DefaultVNavDataProvider, DefaultVNavDataProviderOptions, DefaultVSpeedAnnunciationDataProvider, DefaultVSpeedAnnunciationDataProviderOptions, DefaultVsiDataProvider, DefaultWaypointIconImageCache, DefaultWaypointIconImageKey, DefaultWindDataProvider, DirectToState, DmeTuneSettingMode, DmeUserSettingTypes, DmeUserSettings, DurationNavDataFieldTypes, DynamicList, DynamicListData, Esp, EspAirspeedModule, EspAirspeedModuleEngageData, EspAirspeedModuleOptions, EspAoaModule, EspAoaModuleEngageData, EspAoaModuleOptions, EspControlInputManager, EspControlInputManagerAxisIncrOptions, EspControlInputManagerForceData, EspControlInputManagerOptions, EspData, EspDataProvider, EspForceController, EspModule, EspOperatingMode, EspOptions, EspPitchModule, EspPitchModuleEngageData, EspPitchModuleOptions, EspRollModule, EspRollModuleEngageData, EspRollModuleOptions, EventBusNavDataBarFieldTypeModelFactory, FailureBox, FailureBoxProps, FixIcaoWaypointsRecord, FlightDirectorDataProvider, FlightDirectorDualCue, FlightDirectorDualCueOptions, FlightDirectorDualCueProps, FlightDirectorFormat, FlightDirectorOptions, FlightDirectorSingleCue, FlightDirectorSingleCueOptions, FlightDirectorSingleCueProps, FlightPathCalculatorManager, FlightPathCalculatorManagerOptions, FlightPathMarker, FlightPathMarkerOptions, FlightPathMarkerProps, FlightPathTerminatorWaypointsRecord, FlightPlanFocus, FlightPlanLegWaypointsRecord, FmaData, FmaDataEvents, FmaMasterSlot, FmaMasterSlotProps, FmaMasterSlotState, FmaModeSlot, FmaModeSlotActiveData, FmaModeSlotProps, FmaVNavState, Fms, FmsEvents, FmsEventsForId, FmsFlightPhase, FmsFplUserDataKey, FmsFplUserDataTypeMap, FmsFplVfrApproachData, FmsFplVisualApproachData, FmsOptions, FmsPositionMode, FmsPositionSystem, FmsPositionSystemEvents, FmsPositionSystemSelector, FmsUtils, FmsVisualApproachOptions, GPDisplayMode, GarminAPConfig, GarminAPConfigInterface, GarminAPConfigOptions, GarminAPEvents, GarminAPSimVarEvents, GarminAPSimVarPublisher, GarminAPStateManager, GarminAPUtils, GarminAPVars, GarminAdditionalApproachType, GarminAdsb, GarminAirspaceShowTypeMap, GarminAirspaceShowTypes, GarminApproachProcedure, GarminApproachType, GarminAutopilot, GarminAutopilotOptions, GarminChecklistActionableItemDef, GarminChecklistBranchItemDef, GarminChecklistBranchItemLinkItemDef, GarminChecklistDOMParser, GarminChecklistItem, GarminChecklistItemDef, GarminChecklistItemTextColor, GarminChecklistItemTypeDefMap, GarminChecklistItemTypeMap, GarminChecklistLinkItemDef, GarminChecklistLinkItemType, GarminChecklistNormalLinkItemDef, GarminChecklistNoteItemDef, GarminChecklistSetDef, GarminChecklistSpacerItemDef, GarminChecklistTitleItemDef, GarminControlEvents, GarminExcessiveClosureRateAlert, GarminExcessiveClosureRateModule, GarminExcessiveClosureRateModuleOptions, GarminExcessiveClosureRateModuleSmootherParams, GarminExcessiveDescentRateAlert, GarminExcessiveDescentRateModule, GarminExcessiveDescentRateModuleOptions, GarminExistingUserWaypointsArray, GarminExistingUserWaypointsArrayOptions, GarminFacilityWaypointCache, GarminFlightPlanRouteLoader, GarminFlightPlanRouteProvider, GarminFlightPlanRouteSyncManager, GarminFlightPlanRouteUtils, GarminGlidepathComputer, GarminGlidepathComputerOptions, GarminGlideslopeDeviationAlert, GarminGlideslopeDeviationModule, GarminGlideslopeDeviationModuleOptions, GarminGoAroundManager, GarminGoAroundManagerOptions, GarminHeadingSyncManager, GarminHeadingSyncManagerOptions, GarminLNavDirectorOptions, GarminLowBankManager, GarminLowBankManagerOptions, GarminMapBuilder, GarminMapBuilderActiveFlightPlanOptions, GarminMapBuilderWaypointsLayerOptions, GarminMapKeys, GarminNavEvents, GarminNavSimVarPublisher, GarminNavToNavComputer, GarminNavToNavComputerOptions, GarminNavToNavManager2, GarminNavToNavManager2Guidance, GarminNavToNavManager2Options, GarminNavVars, GarminNegativeClimbRateAlert, GarminNegativeClimbRateModule, GarminNegativeClimbRateModuleOptions, GarminObsLNavModule, GarminObsLNavModuleOptions, GarminPrematureDescentAlert, GarminPrematureDescentModule, GarminPrematureDescentModuleOptions, GarminPrimaryFlightPlanRouteLoader, GarminPrimaryFlightPlanRouteLoaderOptions, GarminPrimaryFlightPlanRouteProvider, GarminSpeedConstraintStore, GarminTaws, GarminTawsAlert, GarminTawsInhibit, GarminTawsOptions, GarminTawsStatus, GarminTawsVoiceCalloutAltitude, GarminTcasII, GarminTcasIISensitivity, GarminTcasIntruder, GarminTimerControlEvents, GarminTimerControlEventsForId, GarminTimerManager, GarminTimerManagerOptions, GarminTodBodDetails, GarminVNavComputer, GarminVNavComputerAPValues, GarminVNavComputerOptions, GarminVNavDataEvents, GarminVNavEvents, GarminVNavFlightPhase, GarminVNavGlidepathGuidance, GarminVNavGuidance, GarminVNavManager2, GarminVNavManager2Options, GarminVNavManagerEvents, GarminVNavPathGuidance, GarminVNavTrackAlertType, GarminVNavTrackingPhase, GarminVNavUtils, GarminVfrApproachProcedure, GarminVoiceCalloutAlert, GarminVoiceCalloutModule, GarminVoiceCalloutModuleOptions, GarminXpdrTcasManager, GenericNavDataBarFieldModelFactory, GenericNavDataFieldRenderer, GlidepathServiceLevel, GlidepathServiceLevelCalculator, GpsIntegrityDataProvider, GpsNavSource, GpsNavSourceOptions, GpsReceiverSelectionState, GpsReceiverSelector, GpsReceiverSelectorOptions, GpsReceiverSystem, GpsReceiverSystemEvents, GpsReceiverSystemOptions, HeadingSyncEvents, HorizonDisplay, HorizonDisplayProps, HorizonLine, HorizonLineOptions, HorizonLineProps, HorizonOcclusionArea, HorizonPitchLadderOptions, HorizonPitchLimitIndicatorOptions, HorizonRollLimitIndicatorsOptions, HsiCompass, HsiCompassProps, HsiGpsIntegrityAnnunciation, HsiGpsIntegrityAnnunciationMode, HsiGpsIntegrityAnnunciationProps, HsiSource, ImgTouchButton, ImgTouchButtonProps, IndexedGarminVNavDataEvents, IndexedGarminVNavEvents, IndexedLNavDataEvents, IndicatorGroupCallbacks, LNavDataDtkVector, LNavDataEvents, LatLonDisplay, LatLonDisplayFormat, LatLonDisplayProps, LegIndexes, LocalDateTimeUserSettingTypes, LocalUnitsUserSettingTypes, MagVarDisplay, MagVarDisplayProps, MagnetometerSystem, MagnetometerSystemEvents, MapActiveFlightPlanDataProvider, MapAirportIcon, MapAirspaceRendering, MapAirspaceVisController, MapAirspaceVisControllerModules, MapAirspaceVisUserSettings, MapBannerIndicator, MapBannerIndicatorProps, MapCrosshairLayer, MapCrosshairLayerModules, MapCrosshairModule, MapDataIntegrityRTRController, MapDataIntegrityRTRControllerContext, MapDataIntegrityRTRControllerModules, MapDeadReckoningLayer, MapDeadReckoningLayerModules, MapDeadReckoningLayerProps, MapDeclutterMode, MapDeclutterModule, MapDeclutterSettingMode, MapDefaultFlightPlanWaypointRecordManager, MapDesiredOrientationController, MapDesiredOrientationControllerContext, MapDesiredOrientationControllerModules, MapDetailIndicator, MapDetailIndicatorProps, MapFlightPathPlanRenderer, MapFlightPathProcRenderer, MapFlightPathStyleFlags, MapFlightPathStyles, MapFlightPlanDataProvider, MapFlightPlanFocusCalculator, MapFlightPlanFocusModule, MapFlightPlanFocusRTRController, MapFlightPlanFocusRTRControllerContext, MapFlightPlanFocusRTRControllerControllers, MapFlightPlanFocusRTRControllerModules, MapFlightPlanFocusRangeTarget, MapFlightPlanWaypointRecordManager, MapFlightPlannerPlanDataProvider, MapFlightPlannerPlanDataProviderOptions, MapGarminAutopilotPropsBinding, MapGarminAutopilotPropsController, MapGarminAutopilotPropsControllerModules, MapGarminAutopilotPropsKey, MapGarminAutopilotPropsModule, MapGarminDataIntegrityModule, MapGarminFlightPlanEntry, MapGarminFlightPlanEntryFactory, MapGarminFlightPlanModule, MapGarminTrafficController, MapGarminTrafficControllerModules, MapGarminTrafficModule, MapMiniCompassLayer, MapMiniCompassLayerProps, MapNexradController, MapNexradControllerModules, MapNexradModule, MapNexradUserSettings, MapOrientation, MapOrientationController, MapOrientationControllerContext, MapOrientationControllerModules, MapOrientationControllerSettings, MapOrientationIndicator, MapOrientationIndicatorProps, MapOrientationModeController, MapOrientationModeControllerContext, MapOrientationModeControllerModules, MapOrientationModule, MapOrientationRTRController, MapOrientationRTRControllerContext, MapOrientationRTRControllerModules, MapOrientationSettingMode, MapOrientationSettingsController, MapOrientationSettingsControllerModules, MapOrientationSettingsControllerSettings, MapPanningModule, MapPanningRTRController, MapPanningRTRControllerContext, MapPanningRTRControllerModules, MapPointerController, MapPointerControllerModules, MapPointerInfoLayer, MapPointerInfoLayerModules, MapPointerInfoLayerProps, MapPointerInfoLayerSize, MapPointerLayer, MapPointerLayerModules, MapPointerModule, MapPointerRTRController, MapPointerRTRControllerContext, MapPointerRTRControllerModules, MapProcedurePreviewLayer, MapProcedurePreviewLayerModules, MapProcedurePreviewLayerProps, MapProcedurePreviewModule, MapRangeCompassController, MapRangeCompassControllerModules, MapRangeCompassLabelRenderer, MapRangeCompassLayer, MapRangeCompassLayerModules, MapRangeCompassLayerProps, MapRangeCompassModule, MapRangeController, MapRangeControllerModules, MapRangeControllerSettings, MapRangeDisplay, MapRangeDisplayProps, MapRangeRTRController, MapRangeRTRControllerModules, MapRangeRingLabelRenderer, MapRangeRingLayer, MapRangeRingLayerModules, MapRangeRingLayerProps, MapRangeRingModule, MapRangeValueDisplay, MapRangeValueDisplayProps, MapRelativeTerrainStatusIndicator, MapRelativeTerrainStatusIndicatorProps, MapResourcePriority, MapRunwayDesignationImageCache, MapRunwayLabelWaypoint, MapRunwayLabelWaypointCache, MapRunwayOutlineIcon, MapRunwayOutlineIconOptions, MapRunwayOutlineIconStyles, MapRunwayOutlineWaypoint, MapRunwayOutlineWaypointCache, MapSharedFlightPlanLayer, MapSharedFlightPlanLayerModules, MapSharedFlightPlanLayerProps, MapStandaloneFlightPlanPlanDataProvider, MapSymbolVisController, MapSymbolVisControllerModules, MapTerrainColorsController, MapTerrainColorsControllerModules, MapTerrainColorsDefinition, MapTerrainController, MapTerrainControllerModules, MapTerrainControllerOptions, MapTerrainMode, MapTerrainModule, MapTerrainScaleIndicator, MapTerrainScaleIndicatorProps, MapTerrainSettingMode, MapTerrainUserSettings, MapTerrainWxSettingCompatManager, MapTerrainWxUserSettings, MapTrackVectorLayer, MapTrackVectorLayerModules, MapTrackVectorLayerProps, MapTrackVectorModule, MapTrafficAlertLevelMode, MapTrafficAlertLevelSettingMode, MapTrafficAltitudeRestrictionMode, MapTrafficController, MapTrafficControllerModules, MapTrafficFailedIndicator, MapTrafficFailedIndicatorProps, MapTrafficIntruderIcon, MapTrafficIntruderIconOptions, MapTrafficMotionVectorMode, MapTrafficOffScaleIndicator, MapTrafficOffScaleIndicatorProps, MapTrafficOffScaleStatus, MapTrafficStatusIndicator, MapTrafficStatusIndicatorProps, MapTrafficUserSettings, MapUnitsModule, MapUserSettingTypes, MapUserSettingsUtils, MapUtils, MapWaypointDisplayBuilder, MapWaypointDisplayBuilderClass, MapWaypointHighlightIcon, MapWaypointHighlightIconOptions, MapWaypointHighlightLayer, MapWaypointHighlightLayerModules, MapWaypointHighlightLayerProps, MapWaypointHighlightModule, MapWaypointIconHighlightStyles, MapWaypointIconStyles, MapWaypointLabelStyles, MapWaypointRenderRole, MapWaypointRenderer, MapWaypointVisUserSettings, MapWaypointsLayer, MapWaypointsLayerModules, MapWaypointsLayerProps, MapWaypointsModule, MapWaypointsVisController, MapWaypointsVisControllerModules, MapWaypointsVisControllerOptions, MapWindVectorController, MapWindVectorControllerModules, MapWindVectorLayer, MapWindVectorLayerModules, MapWindVectorLayerProps, MapWindVectorModule, MapWindVectorUserSettings, MapWxrController, MapWxrControllerModules, MarkerBeaconDataProvider, MarkerBeaconDisplay, MarkerBeaconDisplayProps, MarkerBeaconSystem, MarkerBeaconSystemEvents, MinimumsAlertState, MinimumsAlerter, MinimumsDataProvider, MinimumsDisplay, MinimumsDisplayProps, MinimumsUnitsManager, MultipleSoftKeyEnumController, MultipleSoftkeyEnumDef, NavDataBar, NavDataBarFieldAglModelFactory, NavDataBarFieldBrgModelFactory, NavDataBarFieldCabinAltitudeModelFactory, NavDataBarFieldClgModelFactory, NavDataBarFieldClmModelFactory, NavDataBarFieldConsumerModel, NavDataBarFieldConsumerNumberUnitModel, NavDataBarFieldConsumerValueModel, NavDataBarFieldConsumerValueNumberUnitModel, NavDataBarFieldDensityAltitudeModelFactory, NavDataBarFieldDestModelFactory, NavDataBarFieldDisModelFactory, NavDataBarFieldDtgModelFactory, NavDataBarFieldDtkModelFactory, NavDataBarFieldEcoModelFactory, NavDataBarFieldEndModelFactory, NavDataBarFieldEnrModelFactory, NavDataBarFieldEtaModelFactory, NavDataBarFieldEteModelFactory, NavDataBarFieldFlightLevelModelFactory, NavDataBarFieldFobModelFactory, NavDataBarFieldFodModelFactory, NavDataBarFieldFuelFlowModelFactory, NavDataBarFieldGMeterModelFactory, NavDataBarFieldGenericModel, NavDataBarFieldGpsAltitudeModelFactory, NavDataBarFieldGsModelFactory, NavDataBarFieldIsaModelFactory, NavDataBarFieldLdgModelFactory, NavDataBarFieldMachModelFactory, NavDataBarFieldModel, NavDataBarFieldModelFactory, NavDataBarFieldOatModelFactory, NavDataBarFieldRatModelFactory, NavDataBarFieldTasModelFactory, NavDataBarFieldTkeModelFactory, NavDataBarFieldTrkModelFactory, NavDataBarFieldTypeModelFactory, NavDataBarFieldTypeModelMap, NavDataBarFieldUtcModelFactory, NavDataBarFieldVsrModelFactory, NavDataBarFieldWptModelFactory, NavDataBarFieldXtkModelFactory, NavDataBarProps, NavDataBarSettingName, NavDataBarSettingTypes, NavDataBarUserSettings, NavDataBearingField, NavDataBearingFieldProps, NavDataDurationField, NavDataDurationFieldProps, NavDataField, NavDataFieldBearingRenderer, NavDataFieldBearingRendererOptions, NavDataFieldDurationRenderer, NavDataFieldDurationRendererOptions, NavDataFieldGpsValidity, NavDataFieldLdgRenderer, NavDataFieldModel, NavDataFieldNumberUnitRenderer, NavDataFieldNumberUnitRendererOptions, NavDataFieldProps, NavDataFieldRenderer, NavDataFieldTextRenderer, NavDataFieldTextRendererOptions, NavDataFieldTimeRenderer, NavDataFieldTimeRendererOptions, NavDataFieldType, NavDataFieldTypeModelMap, NavDataFieldTypeRenderer, NavDataGenericField, NavDataGenericFieldProps, NavDataNumberFieldProps, NavDataNumberUnitField, NavDataNumberUnitFieldProps, NavDataTimeField, NavDataTimeFieldProps, NavEventsPublisher, NavIndicatorController, NavRadioNavSource, NavReferenceBase, NavReferenceIndicator, NavReferenceIndicators, NavReferenceIndicatorsCollection, NavReferenceSource, NavReferenceSourceCollection, NavReferenceSources, NavSensitivity, NavStatusBox, NavStatusBoxDataProvider, NavStatusBoxDtkAlert, NavStatusBoxDtkAlertProps, NavStatusBoxFieldBrgModel, NavStatusBoxFieldBrgModelFactory, NavStatusBoxFieldDisModel, NavStatusBoxFieldDisModelFactory, NavStatusBoxFieldEteModel, NavStatusBoxFieldEteModelFactory, NavStatusBoxFieldModel, NavStatusBoxFieldModelFactory, NavStatusBoxFieldRenderer, NavStatusBoxFieldType, NavStatusBoxFieldTypeModelFactory, NavStatusBoxFieldTypeModelMap, NavStatusBoxLegArrow, NavStatusBoxLegArrowProps, NavStatusBoxLegDisplay, NavStatusBoxLegDisplayProps, NavStatusBoxProps, NavStatusTrackedLegs, NavdataComputer, NavdataComputerOptions, NearestAirportUserSettingTypes, NearestAirportUserSettings, NearestMapRTRController, NearestMapRTRControllerContext, NearestMapRTRControllerControllers, NearestMapRTRControllerModules, NeedleAnimator, NextGenConnextMapBuilder, NextGenConnextMapOptions, NextGenDateTimeNavDataFieldTypeRenderer, NextGenDisplayUnitNavDataFieldTypeRenderer, NextGenGarminMapBuilder, NextGenGarminMapUtils, NextGenHsiMapBuilder, NextGenHsiMapOptions, NextGenHsiMapTrafficIconOptions, NextGenMapWaypointStyles, NextGenNavDataBarFieldRenderer, NextGenNavDataFieldBrgRenderer, NextGenNavDataFieldDestRenderer, NextGenNavDataFieldDisRenderer, NextGenNavDataFieldDtgRenderer, NextGenNavDataFieldDtkRenderer, NextGenNavDataFieldEndRenderer, NextGenNavDataFieldEnrRenderer, NextGenNavDataFieldEtaRenderer, NextGenNavDataFieldEteRenderer, NextGenNavDataFieldFobRenderer, NextGenNavDataFieldFodRenderer, NextGenNavDataFieldGsRenderer, NextGenNavDataFieldIsaRenderer, NextGenNavDataFieldTasRenderer, NextGenNavDataFieldTkeRenderer, NextGenNavDataFieldTrkRenderer, NextGenNavDataFieldVsrRenderer, NextGenNavDataFieldXtkRenderer, NextGenNavMapBuilder, NextGenNavMapOptions, NextGenNavMapTrafficIconOptions, NextGenNearestMapBuilder, NextGenNearestMapOptions, NextGenNearestMapTrafficIconOptions, NextGenProcMapBuilder, NextGenProcMapOptions, NextGenTawsAnnunciationDefs, NextGenTrafficMapIconOptions, NextGenTrafficMapOptions, NextGenWaypointMapBuilder, NextGenWaypointMapOptions, NullNavSource, NumberUnitDisplay, NumberUnitDisplayProps, NumberUnitNavDataFieldTypes, ObsSuspDataProvider, ObsSuspModes, PfdDeclutterManager, PfdTrafficAnnunciation, PfdTrafficAnnunciationProps, PitchLadder, PitchLadderOptions, PitchLadderProps, PitchLadderStyles, ProcMapFlightPathPlanRenderer, ProcMapFullFlightPathPlanRenderer, ProcMapTransitionWaypointRecordManager, ProcedureTurnLegWaypoint, ProcedureTurnLegWaypointsRecord, ProcedureType, RadarAltimeter, RadarAltimeterDataProvider, RadarAltimeterProps, RadarAltimeterSystem, RadarAltimeterSystemEvents, RangeCompassHeadingBugOptions, RangeCompassOptions, RangeRingOptions, Regions, RollIndicator, RollIndicatorOptions, RollIndicatorProps, RollIndicatorScaleComponent, RollIndicatorScaleComponentFactory, RollIndicatorScaleParameters, RollLimitIndicators, RollLimitIndicatorsProps, ScrollList, ScrollListProps, SetValueTouchButton, SetValueTouchButtonProps, SoftKey, SoftKeyBar, SoftKeyBarProps, SoftKeyBooleanController, SoftKeyEnumController, SoftKeyMenu, SoftKeyMenuItem, SoftKeyMenuSystem, SoftKeyProps, SpeedConstraintListItem, SynVisUserSettingTypes, SyntheticVision, SyntheticVisionProps, TasSensitivity, TasSensitivityParameters, TcasRaCommandDataProvider, TcasRaPitchCueLayer, TcasRaPitchCueLayerOptions, TcasRaPitchCueLayerProps, TerrainSystem, TerrainSystemAlertController, TerrainSystemAnnunciation, TerrainSystemAnnunciationDef, TerrainSystemAnnunciationLevel, TerrainSystemAnnunciationPriorityDef, TerrainSystemAnnunciationProps, TerrainSystemControlEvents, TerrainSystemControlEventsForId, TerrainSystemData, TerrainSystemDataProvider, TerrainSystemEventSuffix, TerrainSystemEvents, TerrainSystemEventsForId, TerrainSystemModule, TerrainSystemOperatingMode, TerrainSystemStateDataProvider, TerrainSystemType, TerrainSystemUtils, TimeDisplay, TimeDisplayFormat, TimeDisplayProps, TimeNavDataFieldTypes, TisSensitivity, TisSensitivityParameters, ToggleStatusBar, ToggleStatusBarProps, ToggleTouchButton, ToggleTouchButtonProps, TouchButton, TouchButtonHoldAction, TouchButtonHoldEndReason, TouchButtonOnTouchedAction, TouchButtonProps, TouchList, TouchListProps, TouchPad, TouchPadProps, TouchSlider, TouchSliderProps, TrackVectorOptions, TrafficAdvisorySystem, TrafficAltitudeModeSetting, TrafficAvionicsSystem, TrafficAvionicsSystemEvents, TrafficIconOptions, TrafficInfoService, TrafficInfoServiceOptions, TrafficMapAdsbModeIndicator, TrafficMapAdsbModeIndicatorProps, TrafficMapAdsbOffBannerIndicator, TrafficMapAdsbOffBannerIndicatorProps, TrafficMapAltitudeModeIndicator, TrafficMapAltitudeModeIndicatorProps, TrafficMapBuilder, TrafficMapFailedBannerIndicator, TrafficMapFailedBannerIndicatorProps, TrafficMapOperatingModeIndicator, TrafficMapOperatingModeIndicatorProps, TrafficMapOptions, TrafficMapRangeController, TrafficMapRangeControllerModules, TrafficMapRangeControllerSettings, TrafficMapRangeLabelRenderer, TrafficMapRangeLayer, TrafficMapRangeLayerModules, TrafficMapRangeLayerProps, TrafficMapStandbyBannerIndicator, TrafficMapStandbyBannerIndicatorProps, TrafficMotionVectorModeSetting, TrafficOperatingModeManager, TrafficOperatingModeSetting, TrafficRangeRingOptions, TrafficSystem, TrafficSystemType, TrafficUserSettingTypes, TrafficUserSettings, TransitionListItem, TurnRateIndicator, TurnRateProps, TypeOfNavDataFieldModel, UnitFormatter, UnitsAltitudeSettingMode, UnitsDistanceSettingMode, UnitsFuelSettingMode, UnitsNavAngleSettingMode, UnitsTemperatureSettingMode, UnitsUserSettingManager, UnitsUserSettingTypes, UnitsUserSettings, UnitsWeightSettingMode, VNavDataEvents, VNavDataProvider, VNavDisplayMode, VNavTargetAltitudeRestriction, VNavTargetAltitudeRestrictionType, VSpeedAnnunciation, VSpeedAnnunciationDataProvider, VSpeedBugColor, VSpeedBugDefinition, VSpeedBugOptions, VSpeedUserSettingTypes, VSpeedUserSettingUtils, ValueTouchButton, ValueTouchButtonProps, VdiDataProvider, VerticalDeviationIndicator, VerticalSpeedIndicator, VerticalSpeedIndicatorProps, VfrApproachListItem, VsiDataProvider, VsiScaleOptions, WaypointAlertComputer, WaypointAlertComputerOptions, WaypointAlertCourseType, WaypointAlertStateEvent, WaypointAlertingState, WaypointComponent, WaypointComponentProps, WaypointHighlightLineOptions, WaypointIcon, WaypointIconImageCache, WaypointIconProps, WaypointInfoStore, WaypointInfoStoreOptions, WaypointMapHighlightController, WaypointMapHighlightControllerModules, WaypointMapRTRController, WaypointMapRTRControllerContext, WaypointMapRTRControllerControllers, WaypointMapRTRControllerModules, WaypointMapSelectionModule, WeatherMapOrientationController, WeatherMapOrientationControllerContext, WeatherMapOrientationControllerModules, WeatherMapOrientationControllerSettings, WeatherMapOrientationSettingMode, WeatherMapOrientationSettingsController, WeatherMapOrientationSettingsControllerModules, WeatherMapOrientationSettingsControllerSettings, WeatherMapUserSettingTypes, WeatherMapUserSettingsUtils, WeatherRadar, WeatherRadarAvionicsSystem, WeatherRadarAvionicsSystemEvents, WeatherRadarOperatingMode, WeatherRadarProps, WeatherRadarScanMode, WeatherRadarUserSettingTypes, WeatherRadarUtils, WindDataProvider, WindDisplay, WindDisplayOption, WindDisplayProps };
