import { AirportFacility, ArraySubject, FacilityFrequency, FacilityLoader, GeoPointSubject, Subject, Subscribable } from '@microsoft/msfs-sdk';
import { AirportSize } from '@microsoft/msfs-garminsdk';
/** Shorthand for a collection of SurfaceTypes in a byte. */
export type SurfaceTypeOptions = number;
/** The data for an airport relevant to a nearest record. */
export type NearbyAirport = {
    /** The airport facility. */
    facility: AirportFacility | null;
    /** The distance to the airport in meters. */
    distance: number;
    /** The bearing to the airport */
    bearing: number;
    /** Best approach to the best runway. */
    bestApproach?: string;
    /** Heading of the best runway */
    bestHdg: number;
    /** Length of the best runway in meters. */
    bestLength: number;
    /** The best contact frequency. */
    frequency?: FacilityFrequency | undefined;
    /** Airport size */
    size?: AirportSize;
};
/**
 * A filter to be injected into a NearestStore.  This will allow the filtering
 * of a list of airports based upon their longest runway and its surface type.
 * This includes result cacheing to optimize performance of repeated filters.
 * Search parameters may be tweaked, and doing so will automatically invalidate
 * the cache.
 */
export declare class AirportFilter {
    static surfacesHard: never[];
    _minLength: number;
    _surfaceType: SurfaceTypeOptions;
    private cache;
    /**
     * Construct an airport filter.
     * @param minLength The minimum length in feet.
     * @param surfaceType The type of surfaces to look for.
     */
    constructor(minLength?: number, surfaceType?: SurfaceTypeOptions);
    /**
     * Perform the filter on a given list of airports.
     * @param airports An array of AirportFacilities.
     * @returns A list of airports meeting the filter criteria.
     */
    filter(airports: IterableIterator<AirportFacility>): Array<AirportFacility>;
    /**
     * Set a new minimum length and clear the cache.
     * @param minLength The new minimum length in feet.
     */
    set minLength(minLength: number);
    /**
     * Get the current minimum length.
     * @returns The minimum length in feet.
     */
    get minLength(): number;
    /**
     * Set a new surface type filter and clear the cache.
     * @param surfaceType The new surface type options.
     */
    set surfaceType(surfaceType: SurfaceTypeOptions);
    /**
     * Get the current surface type filter.
     * @returns A bitfield of the surface types to allow.
     */
    get surfaceType(): SurfaceTypeOptions;
}
/** A nearest store. */
export declare class NearestStore {
    readonly planePos: GeoPointSubject;
    readonly planeHeading: Subject<number>;
    loader?: FacilityLoader;
    private session?;
    private filter;
    nearestFacilities: Map<string, AirportFacility>;
    nearestAirports: Map<string, NearbyAirport>;
    nearestSubjects: Subject<NearbyAirport>[];
    readonly nearestSubjectList: ArraySubject<Subject<NearbyAirport>>;
    private readonly airportCountSub;
    readonly airportCount: Subscribable<number>;
    private static searchRange;
    private static maxFound;
    private static maxReturned;
    /**
     * Create a NearestStore.
     * @param loader A facility loader.
     * @param filter An instance of AirportFilter to use for filtration.
     */
    constructor(loader: FacilityLoader, filter?: AirportFilter);
    /**
     * Sets a new airport filter for the nearest search.
     * @param runwayLength The desired minimum runway length in feet.
     * @param surfaceType The allowable surface types.
     */
    setFilter(runwayLength: number, surfaceType: SurfaceTypeOptions): void;
    /**
     * Update our nearest airport list.
     */
    searchNearest(): void;
    /**
     * Update our nearest list with the latest search results.
     * @param results The results from a nearest search.
     * @returns A promise that resolves when the nearest list is updated.
     */
    private updateNearestFacilities;
    /**
     * Onces the nearby facilities have been updated, we need to update our
     * set of NearbyAirports to account for distance/bearing changes.
     */
    private updateNearestAirports;
    /**
     * Update our array of nearest airports sorted by distance.
     * @returns An array of nearby airports sorted by distance.
     */
    private get nearestByDistance();
    /**
     * Get the contact frequency for an aiport.  Since this really isn't defined
     * in the scenery details, we implement a pretty simple algorithm for determining
     * it:  iterate through al the frequencies and return the first of a) tower,
     * b) unicom, c) mulicom, d) ctaf that is found.
     * @param airport An airport.
     * @returns frequency The best frequency to use.
     */
    private getContactFrequency;
    /**
     * Create a NearbyAirport from an AirportFacility.
     * @param facility The AirportFacility record.
     * @returns The populated NearbyAirport
     */
    createNearbyAirport(facility: AirportFacility): NearbyAirport;
    /**
     * Update the dynamic data on a nearby airport.
     * @param airport The airport to update.
     * @returns An updated airport or undefined.
     */
    updateNearbyAirport(airport: NearbyAirport): NearbyAirport | undefined;
    /**
     * Update the nearest list with the current nearby airports.
     */
    private updateNearestSubjectList;
}
//# sourceMappingURL=NearestStore.d.ts.map