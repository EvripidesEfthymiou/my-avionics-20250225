import { EventBus, FlightPlanner } from '@microsoft/msfs-sdk';
import { Fms } from '@microsoft/msfs-garminsdk';
export declare enum BoxesColors {
    Magenta = 0,
    Green = 1,
    White = 2,
    Grey = 3
}
/** Collection of pointer related data: */
export interface PointerData {
    /** Flag that tells, whether this pointer object contains valid data (= the related box has pointers) */
    pointersAreValid: boolean;
    /** Array containg the coordinates for the 4 pointers: */
    boxesPointersResultVec: Float64Array;
}
/**
 * This class computes and stores the positional data of the pathway boxes
 *
 * The entire pathways processing works as follows:
 *
 * 1. Principally for all calculations any geographic coordinates are converted into a cartesian coordinate system
 * which has the zero point at the current aircraft position.
 *
 * 2. At a low (1Hz) rate, we compute the visible boxes and their corner cordinates in world space.
 *
 * 3. At a higher rate, the display component calls renderBoxesInScreenCoordinates to retrieve the corners in
 * screen coordinates. renderBoxesInScreenCoordinates uses the usual matrix rendering pipeline with a camera matrix based
 * on the aircraft position and attitude and a projection matrix for the translation into screen coordinates (but without
 * world matrix because the corners are computed in world coordinates already, see step 2).
 */
export declare class PathwaysDataProvider {
    private readonly bus;
    private readonly flightPlanner;
    private readonly fms;
    private readonly boxToBoxDistance;
    private readonly halfBoxWidth;
    private readonly halfBoxHeight;
    private readonly pointerLength;
    private readonly fovCalibration;
    private readonly halfFovVertical;
    private readonly halfFovHorizontal;
    private readonly nearClippingDistance;
    private readonly farClippingDistance;
    private readonly maxBoxCount;
    private readonly settingManager;
    private readonly sub;
    private readonly SimTime1HzConsumer;
    private readonly currentPosition;
    private readonly lnavTrackedVectorIndex;
    private readonly lnavTransitionMode;
    private readonly lnavIsSuspended;
    private readonly selectedAlt;
    private readonly currentAlt;
    private readonly currentAltAboveGround;
    private readonly pitchAngle;
    private readonly bankAngle;
    private readonly yawAngle;
    private readonly fmaModes;
    private readonly vnavFpa;
    private readonly vnavDeviation;
    private readonly gpDeviation;
    private readonly gpMode;
    private readonly gsDeviation;
    private readonly gsRawAngle;
    private readonly gsNavLocation;
    private readonly isTodValid;
    private readonly vnavTodDistance;
    private todDistance;
    private readonly vnavTargetAlt;
    private readonly vnavConstrainAlt;
    private readonly groundSpeed;
    private readonly timeToTod;
    private readonly closeToTod;
    private readonly isOnGround;
    private isEnabled;
    private isCalculationValid;
    private readonly passedLegIcaoIds;
    private apAltModeTargetAltitude;
    private readonly constantBoxesAltMeter;
    private readonly currentAltMeter;
    private boxesAltitudeLookup;
    private maxPointersDistanceLookup;
    private currentBoxesState;
    private currentBoxesCollectingState;
    private momentaryAltitudeTarget;
    private finalApproachArmed;
    private currentBoxColor;
    private boxPositionsCount;
    private activeLegSpilloverDistance;
    private nextActiveLegSpilloverDistance;
    private traversingSpilloverDistance;
    private currentToBoxDistance;
    private readonly boxesCornerPositions;
    private readonly boxesNormalsUnit;
    private readonly boxesColors;
    private readonly vec3Cache;
    private readonly geoCircleCache;
    private readonly geoPointCache;
    private readonly currentAircraftPos;
    private readonly aircraftFwdVecUnit;
    private readonly straightUpVec;
    private readonly boxCenterPos;
    private readonly previousBoxCenterPos;
    private readonly boxNormalVec;
    private readonly navGsStationVec;
    private readonly fafPos;
    private readonly mapPos;
    private readonly currentToBoxVec;
    private readonly currentToBoxVecUnit;
    private readonly turnCenterPos;
    private readonly turnBeginPos;
    private readonly turnEndPos;
    private readonly turnCenterToBoxVec;
    private readonly boxCenterToLEVec;
    private readonly boxEdgeVec;
    /**
     * Output data, this provider generates data with this format:
     * -> screenCoordsIndex
     * Accumulates all written screen coordinates
     *
     * -> renderedScreenCoordinates
     * This is the single container which contains the screen coordinates of all boxes and pointers. The boxes are stored one after another.
     * For each box without pointers, 16 floats are reserved, 4 coordinates for each corner.
     * And for each box with pointers, 32 floats are reserved, first 4 coordinates for each corner and the 4 coordinates for each pointer.
     *
     * -> renderedBoxHasPointers
     * Boolean array, that tells for each box, whether it has pointers or not.
     *
     * -> renderedBoxesColors
     * Array that contains the color of each box.
     *
     * -> renderedBoxesOpacities
     * Number array, containing the opacity of each box.
     *
     */
    private screenCoordsIndex;
    private renderedScreenCoordinates;
    private readonly renderedBoxHasPointers;
    private readonly renderedBoxesColors;
    private readonly renderedBoxesOpacities;
    private readonly aioMat4;
    private readonly boxPointersPositions;
    private readonly cameraMat4;
    private readonly screenProjectionMat4;
    private currentIsFafOrMapLeg;
    /**
     * Creates a PathwaysDataStore.
     * @param bus An instance of the event bus.
     * @param flightPlanner The flight planner.
     * @param fms Fms
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, fms: Fms);
    /**
     * Render the boxes from world space into screen coordinates:
     *
     * Allows to fetch the screen coordinates of the 4 corners for all visible boxes.
     * This method applies a render pipeline consisting of a camera matrix based on the aircraft attitude, altitude and yaw angle and a
     * projection matrix that converts any worldspace coordinate into a screen x,y-pair.
     *
     * This method is called from the display component at a sufficiantly high rate to make the movements of the boxes smooth.
     *
     * @returns the following data:
     * -> screenCoordsIndex
     * Accumulates all written screen coordinates
     *
     * -> renderedScreenCoordinates
     * This is the single container which contains the screen coordinates of all boxes and pointers. The boxes are stored one after another.
     * For each box without pointers, 16 floats are reserved, 4 coordinates for each corner.
     * And for each box with pointers, 32 floats are reserved, first 4 coordinates for each corner and the 4 coordinates for each pointer.
     *
     * -> renderedBoxHasPointers
     * Boolean array, that tells for each box, whether it has pointers or not.
     *
     * -> renderedBoxesColors
     * Array that contains the color of each box.
     *
     * -> renderedBoxesOpacities
     * Number array, containing the opacity of each box.
     */
    renderBoxesInScreenCoordinates(): [Float64Array, number, number[], BoxesColors[], boolean[], number];
    /**
     * This method stores the complete data of one box in the output arrays.
     * @param renderedBoxIndex  Index of the rendered box.
     * @param thisBoxHasPointers True if this box has pointers.
     * @param opacity Opacity of this box, is number in 0...1 range
     * @param inputBoxIndex Index of the box in the boxesCornerPositions array (which does not contain the grey boxes)
     * @param pointerVec vectors for the pointers.
     * @param color Color for this box.
     * @param vertBoxOffset Optional vertical offset from this.boxesCornerPositions, for grey boxes
     */
    private renderBoxToOutput;
    /**
     * Compute the visibles boxes in world space:
     *
     * This is the performance heavy main method, running at a low 1Hz rate, which calculates the boxes and their corners in world space.
     *
     * The method only adds these boxes, which horizontally lay inside the field of view (fov).
     *
     * The function works by traversing along the flight plan, starting at the active leg and check for every box center the
     * fov-criteria and if that yields true, calculate the 4 corners and add them to the boxesCornerVector-vector.
     */
    private computeBoxesInWorldSpace;
    /**
     * Calculates the lerp tables, that describe the altitude of a box vs their distance form the current aircraft position.
     * For each of the three boxes alt modes, we carefully construct the vertical profile ahead.
     * @param boxesAltitude Level flight target altitude
     * @param todDistance distance to TOD
     * @param bodAltitude altitude at BOD
     * @param isFinalApproachDefined true if a final approach is defined
     * @param fafLeg FAF leg
     * @param fafDistance distance to FAF
     * @param fafAltitude altitude at FAF
     * @param mapDistance distance to MAP
     * @param mapAltitude altitude at MAP
     */
    private calculateAltProfileAhead;
    /**
     * Return the vectors, which represent the flight path along this leg.
     * @param leg Input leg
     * @param isActiveLeg true if the leg is the active leg
     * @returns array of circleVectors
     */
    private getAllLegVectors;
    /**
     * Check all criteria whether enough boxes have been collected.
     * @param boxIndex currently collected box count
     * @returns true if no more boxes need to be collected.
     */
    private isCollectingCompleted;
    /** Calculate the two current to box vectors. */
    private setCurrentToBoxVectors;
    /**
     * Check wheather a point lays inside the fov.
     * @param currentToPointVec vector  from current to the test point. Needs to be a unit vector!
     * @returns true if point inside fov.
     */
    private isPointInFov;
    /**
     * Checks whether the current box center is inside the field-of-view:
     * @returns true if inside fov
     */
    private handleBoxFovState;
    /**
     * Calculates the position of boxes along a turn and adds the visible ones.
     * @param circleVec circle vector object for the turn
     * @param boxIndex current box index
     * @returns boxIndex after the turn is calculated
     */
    private computeBoxesAlongTurn;
    /**
     * Calculates the position of boxes along a great arc (straight legs) and adds the visible ones.
     * @param vector circle vector object for the turn
     * @param boxIndex current box index
     * @returns boxIndex after the boxes are calculated
     */
    private computeBoxesAlongGreatArc;
    /**
     * Generic calculation of the corners, based on the boxCenter-vector which positions the box and the
     * boxNormalVecUnit vector which rotates it as needed in world space.
     * @param boxIndex box index
     */
    private addGenericBox;
}
//# sourceMappingURL=PathwaysDataProvider.d.ts.map