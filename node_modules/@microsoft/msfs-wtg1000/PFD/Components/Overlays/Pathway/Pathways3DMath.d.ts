/**
 * Creates a new identity Mat4Math
 */
export declare class Pathways3DMath {
    private static EPSILON;
    private static referencePos;
    /**
     * Update the ref coordinate.
     * @param lat new current lat
     * @param long New current long
     */
    static updateReferencePoint(lat: number, long: number): void;
    /**
     * Returns a vector aligned with a north-zeroed radial.
     * @param radialDeg Radial angle.
     * @param length Length.
     * @param out Float array to store the result.
     * @returns the out array.
     */
    static getRadialVector(radialDeg: number, length: number, out: Float64Array): Float64Array;
    /**
     * Returns the course of a vector.
     * @param x coordinate.
     * @param z coordinate.
     * @returns the course.
     */
    static getBearing(x: number, z: number): number;
    /**
     * Get 2D vector from ref in meters (x -> east-west, y -> north - south).
     * @param latitude input latitude of position
     * @param longitude input longitude of position
     * @param altitude altitude in Meter
     * @param out vector which stores the output
     * @returns 3D vector
     */
    static getMetersFromRef(latitude: number, longitude: number, altitude: number, out: Float64Array): Float64Array;
    /**
     * Get the meters along the x-axis for a longitude delta:
     * @param dLong longitude delta
     * @param latitude latitude of the location
     * @returns the meters that are represented by the dLongitude.
     */
    static getRelativeMetersX(dLong: number, latitude: number): number;
    /**
     * Get the meters along the z-axis (N-S) for a latitude delta:
     * @param dLat Latitude delta
     * @returns the meters that are represented by the dLatitude.
     */
    static getRelativeMetersZ(dLat: number): number;
    /**
     * Set a Mat4Math to the identity matrix
     *
     * @param out the receiving matrix
     * @returns out
     */
    static identity(out: Float64Array): Float64Array;
    /**
     * Multiplies two mat4s
     *
     * @param out the receiving matrix
     * @param a the first operand
     * @param b the second operand
     * @returns out
     */
    static multiply(out: Float64Array, a: Float64Array, b: Float64Array): Float64Array;
    /**
     * Multiplies a mat4s with a vector
     *
     * @param a the first operand, matrix with 16 values
     * @param b the second operand
     * @param bPos starting from this position, 4 values are taken as input from b
     * @param out the receiving vector
     * @param outPos starting from this position, 4 values are written as output
     * @param vertOffset offset to subtract from the altitude of bPos
     * @returns out
     */
    static render3DPosOnScreen(a: Float64Array, b: Float64Array, bPos: number, out: Float64Array, outPos: number, vertOffset?: number): Float64Array;
    /**
     * Add two 3 component vectors taken from a specified index from an array and store the result at another indexed array position
     * @param v1 The first vector.
     * @param v1Pos Start reading from v1 at this position.
     * @param v2 The second vector.
     * @param v2Pos Start reading from v2 at this position.
     * @param out The vector to write the results to.
     * @param outPos Start writing to out at this position.
     */
    static add(v1: Float64Array, v1Pos: number, v2: Float64Array, v2Pos: number, out: Float64Array, outPos: number): void;
    /**
     * Copies one vector to the index of another.
     * @param from The vector from which to copy.
     * @param fromPos Start reading from from at this position.
     * @param to The vector to which to copy.
     * @param toPos Start writing the output at this index.
     * @returns the changed vector.
     */
    static copy(from: Float64Array, fromPos: number, to: Float64Array, toPos: number): Float64Array;
    /**
     * Generates a perspective projection matrix with the given field of view.
     * This is primarily useful for generating projection matrices to be used
     * with the still experiemental WebVR API.
     *
     * @param out Mat4Math frustum matrix will be written into
     * @param fovUpDegrees upDegrees
     * @param fovDownDegrees downDegrees
     * @param fovLeftDegrees leftDegrees
     * @param fovRightDegrees rightDegrees
     * @param near Near bound of the frustum
     * @param far Far bound of the frustum
     * @returns out
     */
    static perspectiveFromFieldOfView(out: Float64Array, fovUpDegrees: number, fovDownDegrees: number, fovLeftDegrees: number, fovRightDegrees: number, near: number, far: number): Float64Array;
    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis.
     * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
     *
     * @param out Mat4Math frustum matrix will be written into
     * @param eye Position of the viewer
     * @param center Point the viewer is looking at
     * @param up vec3 pointing up
     * @param bankAngle bank angle in rad
     * @returns out
     */
    static lookAtScherfgen(out: Float64Array, eye: Float64Array, center: Float64Array, up: Float64Array, bankAngle: number): Float64Array;
}
//# sourceMappingURL=Pathways3DMath.d.ts.map